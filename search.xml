<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[正则]]></title>
      <url>%2F2017%2F04%2F17%2F%E6%AD%A3%E5%88%99%2F</url>
      <content type="text"><![CDATA[1 . 校验密码强度密码的强度必须是包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间。 ^(?=.\d)(?=.[a-z])(?=.*[A-Z]).{8,10}$ 2. 校验中文字符串仅能是中文。 ^[\u4e00-\u9fa5]{0,}$ 3. 由数字、26个英文字母或下划线组成的字符串^\w+$ 4. 校验E-Mail 地址同密码一样，下面是E-mail地址合规性的正则检查语句。 [\w!#$%&amp;’+/=?^_`{|}~-]+(?:.[\w!#$%&amp;’+/=?^_`{|}~-]+)@(?:[\w](?:[\w-][\w])?.)+\w? 5. 校验身份证号码下面是身份证号码的正则校验。15 或 18位。 15位： ^[1-9]\d{7}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{3}$18位： ^[1-9]\d{5}[1-9]\d{3}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{3}([0-9]|X)$ 6. 校验日期“yyyy-mm-dd“ 格式的日期校验，已考虑平闰年。 ^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$ 7. 校验金额金额校验，精确到2位小数。 ^[0-9]+(.[0-9]{2})?$ 8. 校验手机号下面是国内 13、15、18开头的手机号正则表达式。（可根据目前国内收集号扩展前两位开头号码） ^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$ 9. 判断IE的版本IE目前还没被完全取代，很多页面还是需要做版本兼容，下面是IE版本检查的表达式。 ^.MSIE 5-8?(?!.Trident\/[5-9].0).*$ 10. 校验IP-v4地址IP4 正则语句。 \b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b 11. 校验IP-v6地址IP6 正则语句。 (([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])) 12. 检查URL的前缀应用开发中很多时候需要区分请求是HTTPS还是HTTP，通过下面的表达式可以取出一个url的前缀然后再逻辑判断。 if (!s.match(/^[a-zA-Z]+:\/\//)){ s = ‘http://‘ + s;} 13. 提取URL链接下面的这个表达式可以筛选出一段文本中的URL。 ^(f|ht){1}(tp|tps):\/\/([\w-]+.)+[\w-]+(\/[\w- ./?%&amp;=]*)? 14. 文件路径及扩展名校验验证windows下文件路径和扩展名（下面的例子中为.txt文件） ^([a-zA-Z]\:|\)\([^\]+\)[^\/:?”&lt;&gt;|]+.txt(l)?$ 15. 提取Color Hex Codes有时需要抽取网页中的颜色代码，可以使用下面的表达式。 ^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$ 16. 提取网页图片假若你想提取网页中所有图片信息，可以利用下面的表达式。 \&lt; [img][^\&gt;][src] = [\”\’]{0,1}([^\”\’\ &gt;]*) 17. 提取页面超链接提取html中的超链接。 (])(href=”https?:\/\/)((?!(?:(?:www.)?’.implode(‘|(?:www.)?’, $follow_list).’))[^”]+)”((?!.\brel=)[^&gt;])(?:[^&gt;])&gt; 18. 查找CSS属性通过下面的表达式，可以搜索到相匹配的CSS属性。 ^\s[a-zA-Z-]+\s[:]{1}\s[a-zA-Z0-9\s.#]+[;]{1} 19. 抽取注释如果你需要移除HMTL中的注释，可以使用如下的表达式。 20. 匹配HTML标签通过下面的表达式可以匹配出HTML中的标签属性。 &lt;\/?\w+((\s+\w+(\s=\s(?:”.?”|’.?’|[\^’”&gt;\s]+))?)+\s|\s)\/?&gt;| Item | Value || :——– | :–: ||元字符|描述||||将下一个字符标记符、或一个向后引用、或一个八进制转义符。例如，“\n”匹配\n。“\n”匹配换行符。序列“\”匹配“\”而“(”则匹配“(”。即相当于多种编程语言中都有的“转义字符”的概念。||^|匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\n”或“\r”之后的位置。||$|匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\n”或“\r”之前的位置。|||匹配前面的子表达式任意次。例如，zo能匹配“z”，“zo”以及“zoo”，但是不匹配“bo”。等价于{0,}。||+|匹配前面的子表达式一次或多次(大于等于1次）。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。||?|匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“do”或“does”中的“do”。?等价于{0,1}。||{n}|n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。||{n,}|n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o”。||{n,m}|m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。||?|当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。||.点|匹配除“\r\n”之外的任何单个字符。要匹配包括“\r\n”在内的任何字符，请使用像“[\s\S]”的模式。||(pattern)|匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“(”或“)”。||(?:pattern)|非获取匹配，匹配pattern但不获取匹配结果，不进行存储供以后使用。这在使用或字符“(|)”来组合一个模式的各个部分是很有用。例如“industr(?:y|ies)”就是一个比“industry|industries”更简略的表达式。||(?=pattern)|非获取匹配，正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如，“Windows(?=95|98|NT|2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。|(?!pattern)|非获取匹配，正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如“Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。||(?&lt;=pattern)|非获取匹配，反向肯定预查，与正向肯定预查类似，只是方向相反。例如，“(?&lt;=95|98|NT|2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。||(?&lt;!pattern)|非获取匹配，反向否定预查，与正向否定预查类似，只是方向相反。例如“(?&lt;!95|98|NT|2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。这个地方不正确，有问题||x|y|匹配x或y。例如，“z|food”能匹配“z”或“food”(此处请谨慎)。“(z|f)ood”则匹配“zood”或“food”。||[xyz]|字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。||[^xyz]|负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“plin”。||[a-z]|字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。注意:只有连字符在字符组内部时,并且出现在两个字符之间时,才能表示字符的范围; 如果出字符组的开头,则只能表示连字符本身.||[^a-z]|负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。||\b|匹配一个单词边界，也就是指单词和空格间的位置（即正则表达式的“匹配”有两种概念，一种是匹配字符，一种是匹配位置，这里的\b就是匹配位置的）。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。||\B|匹配非单词边界。“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。||\cx|匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。||\d|匹配一个数字字符。等价于[0-9]。||\D|匹配一个非数字字符。等价于[^0-9]。||\f|匹配一个换页符。等价于\x0c和\cL。||\n|匹配一个换行符。等价于\x0a和\cJ。||\r|匹配一个回车符。等价于\x0d和\cM。||\s|匹配任何不可见字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。||\S|匹配任何可见字符。等价于[^ \f\n\r\t\v]。||\t|匹配一个制表符。等价于\x09和\cI。||\v|匹配一个垂直制表符。等价于\x0b和\cK。||\w|匹配包括下划线的任何单词字符。类似但不等价于“[A-Za-z0-9]”，这里的”单词”字符使用Unicode字符集。||\W|匹配任何非单词字符。等价于“[^A-Za-z0-9]”。||\xn|匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“\x41”匹配“A”。“\x041”则等价于“\x04&amp;1”。正则表达式中可以使用ASCII编码。||\num|匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，“(.)\1”匹配两个连续的相同字符。||\n|标识一个八进制转义值或一个向后引用。如果\n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值。||\nm|标识一个八进制转义值或一个向后引用。如果\nm之前至少有nm个获得子表达式，则nm为向后引用。如果\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\nm将匹配八进制转义值nm。||\nml|如果n为八进制数字（0-7），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。||\un|匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，\u00A9匹配版权符号（&copy;）。||\p{P}|小写 p 是 property 的意思，表示 Unicode 属性，用于 Unicode 正表达式的前缀。中括号内的“P”表示Unicode 字符集七个字符属性之一：标点字符。| 其他六个属性：L：字母；M：标记符号（一般不会单独出现）；Z：分隔符（比如空格、换行等）；S：符号（比如数学符号、货币符号等）；N：数字（比如阿拉伯数字、罗马数字等）；C：其他字符。*注：此语法部分语言不支持，例：javascript。&lt; &gt; 匹配词（word）的开始（&lt;）和结束（&gt;）。例如正则表达式能够匹配字符串”for the wise”中的”the”，但是不能匹配字符串”otherwise”中的”the”。注意：这个元字符不是所有的软件都支持的。( ) 将( 和 ) 之间的表达式定义为“组”（group），并且将匹配这个表达式的字符保存到一个临时区域（一个正则表达式中最多可以保存9个），它们可以用 \1 到\9 的符号来引用。| 将两个匹配条件进行逻辑“或”（Or）运算。例如正则表达式(him|her) 匹配”it belongs to him”和”it belongs to her”，但是不能匹配”it belongs to them.”。注意：这个元字符不是所有的软件都支持的。 匹配1或多个正好在它之前的那个字符。例如正则表达式9+匹配9、99、999等。注意：这个元字符不是所有的软件都支持的。? 匹配0或1个正好在它之前的那个字符。注意：这个元字符不是所有的软件都支持的。{i} {i,j} 匹配指定数目的字符，这些字符是在它之前的表达式定义的。例如正则表达式A[0-9]{3} 能够匹配字符”A”后面跟着正好3个数字字符的串，例如A123、A348等，但是不匹配A1234。而正则表达式[0-9]{4,6} 匹配连续的任意4个、5个或者6个数字]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端疑难杂症]]></title>
      <url>%2F2017%2F04%2F17%2F%E5%89%8D%E7%AB%AF%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87%2F</url>
      <content type="text"><![CDATA[苹果手机自动播放或者控制播放苹果手机audio标签单单控制play()没声音，需要通过再次加载音效12345678910111213141516171819202122 if ($(&apos;#auidoSuccess&apos;).length) &#123; $(&apos;#auidoSuccess&apos;).attr(&apos;src&apos;, &apos;themes/audio/weixinyaoyy.mp3&apos;) function audioAutoPlay(id) &#123; var audio = document.getElementById(id); audio.load(); document.addEventListener(&quot;WeixinJSBridgeReady&quot;, function () &#123; WeixinJSBridge.invoke(&apos;getNetworkType&apos;, &#123;&#125;, function (e) &#123; audio.load(); &#125;); &#125;, false); document.addEventListener(&apos;YixinJSBridgeReady&apos;, function () &#123; audio.load(); &#125;, false); &#125; audioAutoPlay(&apos;auidoSuccess&apos;) &#125;&#125;playMusic()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端mvc框架backbone.js]]></title>
      <url>%2F2017%2F04%2F17%2F%E5%89%8D%E7%AB%AFmvc%E6%A1%86%E6%9E%B6backbone-js%2F</url>
      <content type="text"><![CDATA[简介Web 应用程序越来越关注于前端，使用客户端脚本与 Ajax 进行交互。由于 JavaScript 应用程序越来越复杂，如果没有合适的工具和模式，那么 JavaScript 代码的高效编写、非重复性和可维护性方面会面临挑战。模型-视图-控制器 (MVC) 是一个常见模式，可用于服务器端开发以生成有组织以及易维护的代码。MVC 支持将数据（比如通常用于 Ajax 交互的 JavaScript Object Notation (JSON) 对象）从表示层或从页面的文档对象模型 (document object model, DOM) 中分离出来，也可适用于客户端开发。Backbone（也称为 Backbone.js）是由 Jeremy Ashkenas 创建的一个轻量级库，可用于创建 MVC 类应用程序。Backbone：强制依赖于 Underscore.js，Underscore.js 是一个实用型库非强制依赖于 jQuery/Zepto根据模型的变更自动更新应用程序的 HTML，有助于代码维护促进客户端模板使用，避免了在 JavaScript 中嵌入 HTML 代码模型、视图、集合和路由器是 Backbone 框架中的主要组件。在 Backbone 中，模型会存储通过 RESTful JSON 接口从服务器检索到的数据。模型与视图密切关联，负责为特定 UI 组件渲染 HTML 并处理元素上触发的事件，这也是视图本身的一部分。常用缩略词DOM：文档对象模型 MVC：模型-视图-控制器 SPI：单页界面 SPI 应用程序：Backbone.Router 和 Backbone.history含有大量 Ajax 交互的应用程序越来越像那些无页面刷新的应用程序。这些应用程序常常试图限制与单个页面的交互。该 SPI 方法提高了效率和速度，并使整个应用程序变得更灵敏。状态概念代替了页面概念。散列 (Hash) 片段被用于识别一个特定状态。散列片段 是 URL 中散列标签 (#) 后的那部分，是该类应用程序的关键元素。清单 1 显示了一个 SPI 应用程序使用两个不同的散列片段产生的两个不同状态。 清单 1. SPI 或 Ajax 应用程序中的两个不同状态http://www.example.com/#/state1http://www.example.com/#/state2Backbone 提供一个称为路由器（版本 0.5 前称之为控制器）的组件来路由客户端状态。路由器可以扩展 Backbone.Router 函数，且包含一个散列映射（routes 属性）将状态与活动关联起来。当应用程序达到相关状态时，会触发一个特定活动。清单 2 展示了一个 Backbone 路由器示例。 清单 2. Backbone.Router 示例：routers.js12345678910111213141516171819202122232425262728App.Routers.Main = Backbone.Router.extend(&#123; // Hash maps for routes routes : &#123; &quot;&quot; : &quot;index&quot;, &quot;/teams&quot; : &quot;getTeams&quot;, &quot;/teams/:country&quot; : &quot;getTeamsCountry&quot;, &quot;/teams/:country/:name : &quot;getTeam&quot; &quot;*error&quot; : &quot;fourOfour&quot; &#125;, index: function()&#123; // Homepage &#125;, getTeams: function() &#123; // List all teams &#125;, getTeamsCountry: function(country) &#123; // Get list of teams for specific country &#125;, getTeam: function(country, name) &#123; // Get the teams for a specific country and with a specific name &#125;, fourOfour: function(error) &#123; // 404 page &#125;&#125;); 创建的每个状态可以为书签。当 URL 碰到类似下面情况时，会调用这 5 个活动（index、getTeams、getTeamsCountry、getTeamCountry 和 fourOfour）。http://www.example.com 触发 index()http://www.example.com/#/teams 触发 getTeams()http://www.example.com/#/teams/country1 触发 getTeamsCountry() 传递 country1 作为参数http://www.example.com/#/teams/country1/team1 触发 getTeamCountry() 传递 country1 和 team1 作为参数http://www.example.com/#/something 触发 fourOfour() 以作 * （星号）使用。要启动 Backbone，先实例化页面加载的路由器，并通过指令 Backbone.history.start() 方法监视散列片段中的任何变更，如 清单 3 所示。 清单 3. 应用程序实例化（使用 jQuery）1234$(function()&#123; var router = new App.Routers.Main(); Backbone.history.start(&#123;pushState : true&#125;);&#125;) 当实例化路由器时，会生成 Backbone.history 对象；它将自动引用 Backbone.History 函数。Backbone.History 负责匹配路由和 router 对象中定义的活动。start() 方法触发后，将创建 Backbone.history 的 fragment 属性。它包含散列片段的值。该序列在根据状态次序管理浏览器历史方面十分有用。用户如果想要返回前一状态，单击浏览器的返回按钮。在 清单 3 的示例中，通过一个启用 HTML5 特性 pushState 的配置调用 start() 方法。对于那些支持 pushState 的浏览器，Backbone 将监视 popstate 事件以触发一个新状态。如果浏览器不能支持 HTML5 特性，那么 onhashchange 活动会被监视。如果浏览器不支持该事件，轮询技术将监视 URL 散列片段的任何更改。 模型和集合模型和集合是 Backbone.js 的重要组件，模型将数据（通常是来自服务器的数据）存储在键值对中。要创建一个模型，需要扩展 Backbone.Model，如 清单 4 所示。 清单 4. Backbone.Model 创建123456App.Models.Team = Backbone.Model.extend(&#123; defaults : &#123; // default attributes &#125; // Domain-specific methods go here&#125;); App.Models.Team 函数是一个新模型函数，但是必须创建一个实例才能在应用程序中使用特定模型，如 清单 5 所示。 清单 5. 模型实例化1var team1 = new App.Models.Team(); 现在，变量 team1 有一个名为 cid 的字段名，这是一个客户端标识符，形式为 “c” 再加上一个数字（例如，c0、c1、c2）。模型是通过存储在散列映射中的属性来定义的。属性可以在实例化时进行设置，或者使用 set() 方法设置。属性值可通过 get() 方法检索。清单 6 显示了如何通过实例化或 get()/set() 方法设置和获取属性。 清单 6. 模型实例化和 get/set 方法1234567891011// &quot;name&quot; attribute is set into the modelvar team1 = new App.Models.Team(&#123; name : &quot;name1&quot;&#125;);console.log(team1.get(&quot;name&quot;)); // prints &quot;name1&quot;// &quot;name&quot; attribute is set with a new valueteam1.set(&#123; name : &quot;name2&quot;&#125;);console.log(team1.get(&quot;name&quot;)); //prints &quot;name2&quot; 当使用 JavaScript 对象时，使用 set() 方法创建或者设置属性值的原因并不是显而易见的。其中一个原因是为了更新此值，如 清单 7 所示。 清单 7. 以错误的方法更新属性1team1.attributes.name = &quot;name2&quot;; 为了避免 使用 清单 7 中的代码，使用 set() 是改变模型状态并触发其变更事件的唯一方法。使用 set() 提升封装原则。清单 8 展示了如何将一个事件处理程序绑到发生变更的事件中。该事件处理程序包含一个 alert，在调用 set() 方法时会被触发，如 清单 6 所示。但是，在使用 清单 7 中的代码时不触发 alert。 清单 8. 更改 App.Models.Team 模型中的事件处理程序12345678App.Models.Team = Backbone.Model.extend(&#123; initialize : function()&#123; this.bind(&quot;change&quot;, this.changed); &#125;, changed : function()&#123; alert(&quot;changed&quot;); &#125;&#125;); Backbone 的另一个优势是易于通过 Ajax 交互与服务器进行通信。在模型上调用一个 save() 方法会通过 REST JSON API 异步将当前状态保存到服务器。清单 9 展示了此示例。 清单 9. 在模型对象上调用 save 方法1barca.save(); save() 函数将在后台委托给 Backbone.sync，这是负责发出 RESTful 请求的组件，默认使用 jQuery 函数 $.ajax()。由于调用了 REST 风格架构，每个 Create、Read、Update 或 Delete (CRUD) 活动均会与各种不同类型的 HTTP 请求（POST、GET、PUT 和 DELETE）相关联。首先保存模型对象，使用一个 POST 请求，创建一个标识符 ID，其后，尝试发送对象到服务器，使用一个 PUT 请求。当需要从服务器检索一个模型时，请求一个 Read 活动并使用一个 Ajax GET 请求。这类请求使用 fetch() 方法。要确定导入模型数据或者从中取出模型数据的服务器的位置：如果模型属于一个 collection，那么集合对象的 url 属性将是该位置的基础，并且该模型 ID（不是 cid）会被附加以构成完整的 URL。如果模型不是在一个集合中，那么该模型的 urlroot 属性被用作该位置的基础清单 10 显示了如何获取一个模型。 清单 10. 模型对象的 Fetch() 方法12345var teamNew = new App.Models.Team(&#123; urlRoot : &apos;/specialTeams&apos;&#125;);teamNew.save(); // returns model&apos;s ID equal to &apos;222&apos;teamNew.fetch(); // Ajax request to &apos;/specialTeams/222&apos; validate() 方法被用于验证模型，如 清单 11 所示。需要重写 validate() 方法（在调用 set() 方法时触发）来包含模型的有效逻辑。传递给该函数的惟一参数是一个 JavaScript 对象，该对象包含了 set() 方法更新的属性，以便验证那些属性的条件。如果从 validate() 方法中没有返回任何内容，那么验证成功。如果返回一个错误消息，那么验证失败，将无法执行 set() 方法。 清单 11. 模型的验证方法123456789App.Models.Team = Backbone.Model.extend(&#123; validate : function(attributes)&#123; if (!!attributes &amp;&amp; attributes.name === &quot;teamX&quot;) &#123; // Error message returned if the value of the &quot;name&quot; // attribute is equal to &quot;teamX&quot; return &quot;Error!&quot;; &#125; &#125;&#125; 一组模型被分组到到集合中，这个集合是 Backbone.Collection 的扩展函数。集合具有一个模型属性的特性，定义了组成该集合的模型类型。使用 add()/remove() 方法可以将一个模型添加和移动到集合中。清单 12 显示了如何创建和填充一个集合。 清单 12. Backbone 集合1234567891011121314App.Collections.Teams = Backbone.Collection.extend(&#123; model : App.Models.Team&#125;);var teams = new App.Collections.Teams();// Add e model to the collection object &quot;teams&quot;teams.add(team1);teams.add(new App.Models.Team(&#123; name : &quot;Team B&quot;&#125;));teams.add(new App.Models.Team());teams.remove(team1);console.log(teams.length) // prints 2 创建的 teams 集合中包含一个含有两个模型的阵列，存储在模型属性中。尽管，在典型 Ajax 应用程序中，会从服务器动态（不是人工）填充该集合。fetch() 方法可以帮助完成此项任务，如 清单 13 所示，并将数据存储到模型阵列中。 清单 13. Fetch() 方法1teams.fetch(); Backbone 中的集合拥有一个 url 属性，定义了使用 Ajax GET 请求从服务器取出 JSON 数据的位置，如 清单 14 所示。 清单 14. 集合的 url 属性和 fetch() 方法12teams.url = &apos;/getTeams&apos;;teams.fetch(); //Ajax GET Request to &apos;/getTeams&apos; Fetch() 方法属于异步调用，因此，在等待服务器响应时，应用程序不会中止。在一些情况下，要操作来自服务器的原始数据，可以使用集合的 parse() 方法。正如 清单 15 所示。 清单 15. parse() 方法1234567App.Collections.Teams = Backbone.Collection.extend(&#123; model : App.Models.Team, parse : function(data) &#123; // &apos;data&apos; contains the raw JSON object console.log(data); &#125;&#125;); 集合提供的另一个有趣的方法是 reset()，它允许将多个模型设置到一个集合中。reset() 方法可以非常方便地将数据引导到集合中，比如页面加载，来避免用户等待异步调用返回。 视图和客户端模板Backbone 中的视图与典型 MVC 方法的视图不一样。Backbone 视图可以扩展 Backbone.View 函数并显示模型中存储的数据。一个视图提供一个由 el 属性定义的 HTML 元素。该属性可以是由 tagName、className 和 id 属性相组合而构成的，或者是通过其本身的 el 值形成的。清单 16 显示了使用这不同方法组合 el 属性的两个不同视图。 清单 16. Backbone 视图样例123456789// In the following view, el value is &apos;UL.team-element&apos;App.Views.Teams = Backbone.View.extend(&#123; el : &apos;UL.team-list&apos;&#125;);// In the following view, el value is &apos;div.team-element&apos;App.Views.Team = Backbone.View.extend(&#123; className : &apos;.team-element&apos;, tagName : &apos;div&apos;&#125;); 如果 el、tagName、className 和 id 属性为空，那么会默认将一个空的 DIV 分配给 el。如上所述，一个视图必须与一个模型相关联。该模型属性也很有用，如 清单 17 所示。App.View.Team 视图被绑定到一个 App.Models.Team 模型实例。 清单 17. Backbone 视图中的模型属性12345// In the following view, el value is &apos;UL.team-element&apos;App.Views.Team = Backbone.View.extend(&#123; ... model : new App.Models.Team&#125;); 要渲染数据（这是视图的主要目的），重写 render() 方法和逻辑来显示 DOM 元素（由 el 属性引用的）中的模型属性。清单 18 展示了一个 render 方法如何更新用户界面的样例。 清单 18. Render() 方法12345678910App.Views.Team = Backbone.View.extend(&#123; className : &apos;.team-element&apos;, tagName : &apos;div&apos;, model : new App.Models.Team render : function() &#123; // Render the &apos;name&apos; attribute of the model associated // inside the DOM element referred by &apos;el&apos; $(this.el).html(&quot;&lt;span&gt;&quot; + this.model.get(&quot;name&quot;) + &quot;&lt;/span&gt;&quot;); &#125;&#125;); Backbone 也可以促进客户端模板的使用，这就使得我们没有必要在 JavaScript 中嵌入 HTML 代码，如 清单 18 所示。（使用模板，模板会封装视图中常见函数；只指定此函数一次即可。）Backbone 在 underscore.js（一个必须的库）中提供一个模板引擎，尽管没有必要使用该模板引擎。清单 19 中的实例使用 underscore.js HTML 模板。 清单 19. HTML 含有模板123&lt;script id=&quot;teamTemplate&quot; type=&quot;text/template&quot;&gt; &lt;%= name %&gt;&lt;/script&gt; 清单 20 显示了另一个使用 underscore.js HTML 模板的样例。 清单 20. 使用 _.template() 函数的视图123456789101112App.Views.Team = Backbone.View.extend(&#123; className : &apos;.team-element&apos;, tagName : &apos;div&apos;, model : new App.Models.Team render : function() &#123; // Compile the template var compiledTemplate = _.template($(&apos;#teamTemplate&apos;).html()); // Model attributes loaded into the template. Template is // appended to the DOM element referred by the el attribute $(this.el).html(compiledTemplate(this.model.toJSON())); &#125;&#125;); Backbone 中最有用且最有趣的一个功能是将 render() 方法绑定到模型的变更事件中，如 清单 21 所示。 清单 21. Render() 方法绑定到模型变更事件1234567// In the following view, el value is &apos;div.team-element&apos;App.Views.Team = Backbone.View.extend(&#123; model : new App.Models.Team, initialize : function() &#123; this.model.bind(&quot;change&quot;, this.render, this); &#125;&#125;) 上述代码将 render() 方法绑定到一个模型的变更事件中。当模型发生更改时，会自动触发 render() 方法，从而节省数行代码。从 Backbone 0.5.2 开始，bind() 方法就开始接受使用第三个参数来定义回调函数的对象。（在上述示例中，当前视图是回调函数 render() 中的对象）。在 Backbone 0.5.2 之前的版本中，必须使用 underscore.js 中的 bindAll 函数，如 清单 22 所示。 清单 22. _.bindAll() usage1234567// In the following view, el value is &apos;div.team-element&apos;App.Views.Team = Backbone.View.extend(&#123; initialize : function() &#123; _.bindAll(this, &quot;render&quot;); this.model.bind(&quot;change&quot;, this.render); &#125;&#125;) Backbone 视图中，通过视图中的 DOM 对象监听事件是比较容易的。对于实现这一点，events 属性很是方便的，如 清单 23 所示。 清单 23. 事件属性12345678910App.Views.Team = Backbone.View.extend(&#123; className : &apos;.team-element&apos;, tagName : &apos;div&apos;, events : &#123; &quot;click a.more&quot; : &quot;moreInfo&quot; &#125;, moreInfo : function(e)&#123; // Logic here &#125;&#125;) events 属性的每个项均由两部分构成：左边部分指定事件类型和触发事件的选择器。右边部分定义了事件处理函数。在 清单 23 中，当用户通过 DIV 中的类 more 以及类 team-element 点击链接时，会调用函数 moreInfo。 结束语MVC 模式可以为大型 JavaScript 应用程序提供所需的组织化代码。Backbone 是一个 JavaScript MVC 框架，它属于轻量级框架，且易于学习掌握。模型、视图、集合和路由器从不同的层面划分了应用程序，并负责处理几种特定事件。处理 Ajax 应用程序或者 SPI 应用程序时，Backbone 可能是最好的解决方案。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[用webpack做vue热加载]]></title>
      <url>%2F2017%2F04%2F15%2Fwebpack%E7%83%AD%E5%8A%A0%E8%BD%BD%2F</url>
      <content type="text"><![CDATA[介绍使用 webpack 有一段时间了，其中的模块热加载加快了开发的速度。它无需刷新，只要修改了文件，客户端就立刻做热加载webpack.config.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244const webpack = require(&apos;webpack&apos;)const glob = require(&apos;glob&apos;)const fs = require(&apos;fs&apos;)const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)const colors = require(&apos;colors&apos;)const path = require(&apos;path&apos;)const TransferWebpackPlugin = require(&apos;transfer-webpack-plugin&apos;)const express = require(&apos;express&apos;)const WebpackDevMiddleware = require(&apos;webpack-dev-middleware&apos;)const WebpackHotMiddleware = require(&apos;webpack-hot-middleware&apos;)const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;)const argv = require(&apos;minimist&apos;)(process.argv.slice(2))const bs = require(&apos;browser-sync&apos;).create();let bsFlag = falseconst gulp = require(&apos;gulp&apos;)/** * 编译配置 * @type &#123;Object&#125; */const setting = &#123; src:&apos;./src&apos;, // 源文件目录 release:&apos;./dist&apos; // 编译后文件&#125;/** * 获取配置 * @return &#123;[type]&#125; [description] */const getConf = function()&#123; let config = &#123; entry:&#123; &#125;, output: &#123; path:path.resolve(__dirname, &apos;dist&apos;), publicPath: &apos;/&apos;, filename: &apos;[name]-[hash].js&apos;, chunkFilename:&quot;[id].chunk.js&quot; &#125;, module: &#123; loaders: [ &#123; test: /\.vue$/, exclude: /node_modules/, loader: &apos;vue&apos; &#125;, &#123; test: /\.html$/, loader: &apos;html&apos; &#125;, &#123; test: /\.(js|jsx)$/, loader: &apos;babel&apos;, query: &#123; presets: [ require.resolve(&apos;babel-preset-react&apos;), require.resolve(&apos;babel-preset-es2015&apos;) ] &#125;, include: path.resolve(process.cwd(), &apos;./&apos;), exclude: /node_modules/ &#125;, &#123; test: /\.(png|jpg|gif|svg|mp3|wav|ogg|json)$/, loaders: [ &apos;url?limit=1024&amp;hash=sha512&amp;digest=hex&amp;name=[name]-[hash].[ext]&apos; ] &#125; ] &#125;, resolve: &#123; extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.json&apos;, &apos;.scss&apos;,&apos;.hbs&apos;,&apos;.html&apos;], alias: &#123; &apos;vue&apos;: &apos;vue/dist/vue.js&apos; &#125; &#125;, plugins:[ // new MyPlugin(&#123;options: &apos;&apos;&#125;), new webpack.HotModuleReplacementPlugin(), new webpack.optimize.OccurenceOrderPlugin(), new webpack.NoErrorsPlugin() ], &#125; config.entry = entries() // 处理html config.plugins = config.plugins.concat(htmlPlugins()) // 处理版本控制 if(checkEnvPro())&#123; config.plugins.push( new webpack.DefinePlugin(&#123; &apos;process.env&apos;: &#123; NODE_ENV: &apos;&quot;production&quot;&apos; &#125; &#125;), new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; warnings: false &#125; &#125;) ) &#125;else&#123; // config.devtool = &apos;#source-map&apos; &#125; return config&#125;/** * 获取入口文件 * @return &#123;[type]&#125; [description] */const entries = function()&#123; let targetJs = path.resolve(setting.src, &apos;entries&apos;) console.log(colors.red(targetJs)) let entryFiles = glob.sync(targetJs + &apos;/*.&#123;js,jsx&#125;&apos;) let map = &#123;&#125; let targetFiles = glob.sync(setting.release + &apos;/*.&#123;js,css,html&#125;&apos;) entryFiles.forEach(function (entry) &#123; let fileName = entry.substring(entry.lastIndexOf(&apos;\/&apos;) + 1, entry.lastIndexOf(&apos;.&apos;)) map[fileName] = path.resolve(__dirname,entry) /** * 清理上个版本文件 * @type &#123;[type]&#125; */ targetFiles.forEach(function(file)&#123; let sourceName = file.substring(file.lastIndexOf(&apos;\/&apos;) + 1, file.lastIndexOf(&apos;-&apos;)) let htmlName = file.substring(file.lastIndexOf(&apos;\/&apos;) + 1, file.lastIndexOf(&apos;.&apos;)) if(sourceName == fileName || htmlName == fileName)&#123; !argv.hot &amp;&amp; fs.existsSync(file) &amp;&amp; fs.unlinkSync(file) &#125; &#125;) &#125;) return map&#125;/** * 处理html-views * @return &#123;[type]&#125; [description] */const htmlPlugins = function () &#123; let entryHtml = glob.sync(setting.src + &apos;/views/*.html&apos;) let plugins = [] entryHtml.forEach(function(entry)&#123; let filePath = path.join(__dirname, entry) let fileName = filePath.substring(filePath.lastIndexOf(&apos;\/&apos;) + 1, filePath.lastIndexOf(&apos;.&apos;)); plugins.push(new HtmlWebpackPlugin(&#123; chunks: [fileName], cache:false, filename: fileName + &apos;.html&apos;, inject:true, hash:true, template:filePath, minify:checkEnvPro() ? &#123; removeAttributeQuotes: true &#125; : false, // templateContent: function(templateParams, compilation)&#123; // let contentStr = fs.readFileSync(filePath).toString() // return contentStr // &#125; &#125;)) &#125;) return plugins&#125;/** * 检查版本，增加版本功能控制 * @return &#123;[type]&#125; [description] */const checkEnvPro = function()&#123; if (process.env.NODE_ENV === &apos;production&apos;) &#123; return true &#125; else &#123; return false &#125;&#125;/** * 监听html * @return &#123;[type]&#125; [description] */const browserSync = function()&#123; if(bsFlag)&#123; return &#125; bsFlag = true bs.init(&#123; server: &#123; baseDir: setting.release &#125;, files: [&apos;./src/**&apos;], port: 8090, files: [ &#123; match: [&apos;./src/**&apos;], fn: function (event, file) &#123; if (event === &apos;change&apos;) &#123; webpack(getConf(),function()&#123; bs.reload(); &#125;) &#125; &#125; &#125; ] &#125;);&#125;function MyPlugin(options) &#123;&#125;MyPlugin.prototype.apply = function(compiler) &#123; compiler.plugin(&apos;compilation&apos;, function(compilation) &#123; // console.log(colors.red(&apos;compilation&apos;)) // browserSync() &#125;);&#125;;module.exports = getConf() webpack.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465const webpack = require(&apos;webpack&apos;)const webpackDevServer = require(&apos;webpack-dev-server&apos;)const webpackDevMiddleware = require(&apos;webpack-dev-middleware&apos;)const webpackHotMiddleware = require(&apos;webpack-hot-middleware&apos;)const colors = require(&apos;colors&apos;)const bs = require(&apos;browser-sync&apos;).create();const express = require(&apos;express&apos;)const app = express()const opn = require(&apos;opn&apos;)const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;)const connectHistoryApiFallBack = require(&apos;connect-history-api-fallback&apos;)const path = require(&apos;path&apos;)const config = require(path.join(__dirname, &apos;webpack.config&apos;))const port = process.env.PORT || 8090/** * 设置confg，hot参数 */const setConfig = function()&#123; var extras = [&apos;./dev-client&apos;];// var extras = [&apos;webpack-hot-middleware/client?path=/__webpack_hmr&amp;reload=true&apos;] Object.keys(config.entry).forEach(function(name) &#123; config.entry[name] = extras.concat(config.entry[name]) &#125;) config.plugins.push( new webpack.HotModuleReplacementPlugin(), new webpack.optimize.OccurenceOrderPlugin(), new webpack.NoErrorsPlugin() ) return config&#125;var compiler = webpack(setConfig())var proxyMiddleware = require(&apos;http-proxy-middleware&apos;)var devMiddleware = require(&apos;webpack-dev-middleware&apos;)(compiler, &#123; publicPath: config.output.publicPath, stats: &#123; colors: true, chunks: false &#125;,&#125;)var hotMiddleware = require(&apos;webpack-hot-middleware&apos;)(compiler)compiler.plugin(&apos;compilation&apos;, function(compilation) &#123; compilation.plugin(&apos;html-webpack-plugin-after-emit&apos;, function(data, cb) &#123; hotMiddleware.publish(&#123; action: &apos;reload&apos; &#125;) cb() &#125;)&#125;)app.use(devMiddleware)app.use(hotMiddleware)app.use(express.static(config.output.path))app.use(require(&apos;connect-history-api-fallback&apos;)())app.listen(port, function(err) &#123; if (err) &#123; console.log(err) return &#125; console.log(colors.green(&apos;服务已开启，端口:&apos;+port))// opn(&apos;http://localhost:&apos;+port)&#125;) package.json 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&#123; &quot;name&quot;: &quot;back&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack-dev-server --inline --hot&quot;, &quot;build&quot;: &quot;export NODE_ENV=production &amp;&amp; webpack --progress --hide-modules&quot;, &quot;hot&quot;: &quot;node webpack.js --hot&quot; &#125;, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: &#123; &quot;autoprefixer&quot;: &quot;^6.7.7&quot;, &quot;babel-core&quot;: &quot;^6.2.1&quot;, &quot;babel-loader&quot;: &quot;^6.2.0&quot;, &quot;babel-plugin-transform-runtime&quot;: &quot;^6.1.18&quot;, &quot;babel-preset-es2015&quot;: &quot;^6.1.18&quot;, &quot;babel-preset-react&quot;: &quot;^6.23.0&quot;, &quot;babel-preset-stage-0&quot;: &quot;^6.1.18&quot;, &quot;babel-runtime&quot;: &quot;^6.2.0&quot;, &quot;browser-sync&quot;: &quot;^2.18.8&quot;, &quot;connect-history-api-fallback&quot;: &quot;^1.3.0&quot;, &quot;css-loader&quot;: &quot;^0.23.1&quot;, &quot;express&quot;: &quot;^4.15.2&quot;, &quot;extract-text-webpack-plugin&quot;: &quot;^2.1.0&quot;, &quot;file-loader&quot;: &quot;^0.8.5&quot;, &quot;fs&quot;: &quot;0.0.1-security&quot;, &quot;glob&quot;: &quot;^7.1.1&quot;, &quot;gulp&quot;: &quot;^3.9.1&quot;, &quot;html-loader&quot;: &quot;^0.4.5&quot;, &quot;html-webpack-plugin&quot;: &quot;^2.28.0&quot;, &quot;http-proxy-middleware&quot;: &quot;^0.17.4&quot;, &quot;jade&quot;: &quot;^1.11.0&quot;, &quot;minimist&quot;: &quot;^1.2.0&quot;, &quot;node-sass&quot;: &quot;^3.4.2&quot;, &quot;opn&quot;: &quot;^4.0.2&quot;, &quot;postcss-loader&quot;: &quot;^1.3.3&quot;, &quot;sass-loader&quot;: &quot;^3.2.3&quot;, &quot;style-loader&quot;: &quot;^0.13.0&quot;, &quot;stylus-loader&quot;: &quot;^1.4.2&quot;, &quot;template-html-loader&quot;: &quot;0.0.3&quot;, &quot;transfer-webpack-plugin&quot;: &quot;^0.1.4&quot;, &quot;vue&quot;: &quot;^2.1.0&quot;, &quot;vue-loader&quot;: &quot;^10.0.0&quot;, &quot;vue-resource&quot;: &quot;^1.0.3&quot;, &quot;vue-router&quot;: &quot;^2.1.1&quot;, &quot;vue-scroll&quot;: &quot;^2.0.1&quot;, &quot;vue-style-loader&quot;: &quot;^1.0.0&quot;, &quot;vue-template-compiler&quot;: &quot;^2.1.0&quot;, &quot;vuex&quot;: &quot;^2.1.1&quot;, &quot;webpack&quot;: &quot;^1.13.1&quot;, &quot;webpack-dev-middleware&quot;: &quot;^1.8.3&quot;, &quot;webpack-hot-middleware&quot;: &quot;^2.12.2&quot; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[koa2搭建接口服务器实践]]></title>
      <url>%2F2017%2F04%2F15%2Fkoa2%E6%90%AD%E5%BB%BA%E6%8E%A5%E5%8F%A3%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E8%B7%B5%2F</url>
      <content type="text"><![CDATA[准备工作 安装新版node，es7需要高版本node支持， 并且需要babel转换es7语法 async/await是异步流程控制更好的解决方案 .babelrc1234567 &#123; &quot;presets&quot;: [&quot;es2015-node5&quot;], &quot;plugins&quot;: [ &quot;transform-async-to-generator&quot;, &quot;syntax-async-functions&quot; ]&#125; 入口index12require(&apos;babel-register&apos;);require(&apos;./server/index.js&apos;) 目录结构 doc 数据库文件，项目文档 .doc .sql backEnd 后台文件 Semantic UI （样式框架） vue／angular （mvc框架） frontEnd 前端文件 vue/ng/react app 原文件 release 编译文件 bower.json 引用 server 服务端文件 config 配置模块（数据库配置，环境配置） config.js routers 路由文件 (user) 接口处理模块 index.js 入口文件 codes code编码模块 index.js models 数据库模型模块Sequelize services 业务模块，处理封装数据库models upload 文件上传 utils 工具类 views node模版引擎 logs 日志模块 todo中间件 session redis 缓存处理 server模块入口12345678910111213141516171819202122232425262728293031/*============================================================================ * server入口 ============================================================================*/const Koa = require(&apos;koa&apos;);const router = require(&apos;./routers/index&apos;)const app = new Koa();const http = require(&apos;http&apos;)const views = require(&apos;koa-views&apos;)const colors = require(&apos;colors&apos;)// const cors = require(&apos;koa-cors&apos;)const config = require(&apos;./config&apos;)const logger = require(&apos;koa-logger&apos;)// 引入模版views// app.use(views(__dirname + &apos;/views&apos;, &#123; extension: &apos;jade&apos; &#125;))app.use(views( __dirname + &apos;/views&apos;, &#123; extension: &apos;hbs&apos;, map: &#123; hbs: &apos;handlebars&apos; &#125;&#125;));// 引入路由app.use(router.routes()) .use(router.allowedMethods());// 跨域// app.use(cors())// 日志app.use(logger())// 开启服务let server = http.createServer(app.callback());server.listen(config.base.port);console.log(colors.red(&apos;服务已开启：端口&apos;+ config.base.port)) 路由入口文件12345678910111213141516171819202122232425262728/*============================================================================ * 接口路由入口 ============================================================================*/const colors = require(&apos;colors&apos;)const fs = require(&apos;fs&apos;)const path = require(&apos;path&apos;)const Router = require(&apos;koa-router&apos;)const router = new Router()const utils = require(&apos;../utils&apos;)/** * 遍历路由文件夹，注册路由 * @type &#123;String&#125; */let routesArray = utils.getFiles(__dirname)routesArray.map(function(item)&#123; let fileName = &apos;./&apos; + item if(fs.existsSync(path.resolve(__dirname, fileName)))&#123; let routesInstance = require(fileName) router.use(routesInstance.routes()) .use(routesInstance.allowedMethods()); &#125;else&#123; console.log(&apos;路由 ----&apos; + path.resolve(__dirname, fileName) + &apos; not found&apos;) &#125;&#125;)module.exports = router 某路由文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869const Router = require(&apos;koa-router&apos;)const router = new Router()const body = require(&apos;koa-body&apos;)()const colors = require(&apos;colors&apos;)const modules = require(process.cwd() + &apos;/services/index&apos;)const codes = require(process.cwd() + &apos;/codes/index&apos;)const utils = require(process.cwd() + &apos;/utils/index&apos;)/** * 检查用户存在 * @param &#123;[type]&#125; userName [description] * @return &#123;[type]&#125; [description] */const checkUserExit = async (username) =&gt; &#123; if(!username)&#123; return &#125; return new Promise((resolve, reject) =&gt; &#123; modules.users.findAll(&#123; where: &#123; username: username, &#125; &#125;).then((result)=&gt;&#123; if(result &amp;&amp; result.length &gt; 0)&#123; resolve(true) &#125;else&#123; resolve(false) &#125; &#125;) &#125;)&#125;router.post(&apos;/login&apos;,body, async (ctx) =&gt; &#123; ctx.set(&apos;Access-Control-Allow-Method&apos;, &apos;POST&apos;); ctx.set(&apos;Access-Control-Allow-Origin&apos;, &apos;*&apos;) let username = ctx.request.body.username let password = ctx.request.body.password if(!username || !password)&#123; ctx.body = codes.set(&apos;2&apos;) return &#125; // 是否存在用户 let isExit = await checkUserExit(username) let data = &#123;isExit:isExit&#125; ctx.body = utils.extend(codes.set(&apos;0&apos;),data)&#125;)router.get(&apos;/getUser/:id&apos;, async (ctx,next) =&gt; &#123; let id = ctx.params.id; await modules.users.findAll(&#123; where: &#123; id: id, &#125; &#125;).then((result)=&gt;&#123; let params = JSON.stringify(result) ctx.body = JSON.stringify(result) &#125;)&#125;);module.exports = router 以上是部分文件显示，如果需要详细框架搭建，留言或QQ联系博主我]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[react知识点]]></title>
      <url>%2F2017%2F04%2F15%2Freact%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
      <content type="text"><![CDATA[调用 setState 之后发生了什么？在代码中调用setState函数之后，React 会将传入的参数对象与组件当前的状态合并，然后触发所谓的调和过程（Reconciliation）。经过调和过程，React 会以相对高效的方式根据新的状态构建 React 元素树并且着手重新渲染整个UI界面。在 React 得到元素树之后，React 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染。在差异计算算法中，React 能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。 React 中 Element 与 Component 的区别是？简单而言，React Element 是描述屏幕上所见内容的数据结构，是对于 UI 的对象表述。典型的 React Element 就是利用 JSX 构建的声明式代码片然后被转化为createElement的调用组合。而 React Component 则是可以接收参数输入并且返回某个 React Element 的函数或者类。更多介绍可以参考React Elements vs React Components。 在什么情况下你会优先选择使用 Class Component 而不是 Functional Component？在组件需要包含内部状态或者使用到生命周期函数的时候使用 Class Component ，否则使用函数式组件。 React 中 refs 的作用是什么？Refs 是 React 提供给我们的安全访问 DOM 元素或者某个组件实例的句柄。我们可以为元素添加ref属性然后在回调函数中接受该元素在 DOM 树中的句柄，该值会作为回调函数的第一个参数返回： 1234567891011121314151617181920212223242526272829class CustomForm extends Component &#123; handleSubmit = () =&gt; &#123; console.log(&quot;Input Value: &quot;, this.input.value) &#125; render () &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;input type=&apos;text&apos; ref=&#123;(input) =&gt; this.input = input&#125; /&gt; &lt;button type=&apos;submit&apos;&gt;Submit&lt;/button&gt; &lt;/form&gt; ) &#125;&#125; 上述代码中的input域包含了一个ref属性，该属性声明的回调函数会接收input对应的 DOM 元素，我们将其绑定到this指针以便在其他的类函数中使用。另外值得一提的是，refs 并不是类组件的专属，函数式组件同样能够利用闭包暂存其值： 123456789101112131415161718192021function CustomForm (&#123;handleSubmit&#125;) &#123; let inputElement return ( &lt;form onSubmit=&#123;() =&gt; handleSubmit(inputElement.value)&#125;&gt; &lt;input type=&apos;text&apos; ref=&#123;(input) =&gt; inputElement = input&#125; /&gt; &lt;button type=&apos;submit&apos;&gt;Submit&lt;/button&gt; &lt;/form&gt; )&#125; React 中 keys 的作用是什么？Keys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。 1234567891011121314151617render () &#123; return ( &lt;ul&gt; &#123;this.state.todoItems.map((&#123;task, uid&#125;) =&gt; &#123; return &lt;li key=&#123;uid&#125;&gt;&#123;task&#125;&lt;/li&gt; &#125;)&#125; &lt;/ul&gt; )&#125; 在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有唯一性。在 React Diff 算法中 React 会借助元素的 Key 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染。此外，React 还需要借助 Key 值来判断元素与本地状态的关联关系，因此我们绝不可忽视转换函数中 Key 的重要性。 如果你创建了类似于下面的Twitter元素，那么它相关的类定义是啥样子的？12345678910111213141516171819202122232425&lt;Twitter username=&apos;tylermcginnis33&apos;&gt; &#123;(user) =&gt; user === null ? &lt;Loading /&gt; : &lt;Badge info=&#123;user&#125; /&gt;&#125;&lt;/Twitter&gt;import React, &#123; Component, PropTypes &#125; from &apos;react&apos;import fetchUser from &apos;twitter&apos;// fetchUser take in a username returns a promise// which will resolve with that username&apos;s data.class Twitter extends Component &#123; // finish this&#125; 如果你还不熟悉回调渲染模式（Render Callback Pattern），这个代码可能看起来有点怪。这种模式中，组件会接收某个函数作为其子组件，然后在渲染函数中以props.children进行调用： 123456789101112131415161718192021222324252627282930313233import React, &#123; Component, PropTypes &#125; from &apos;react&apos;import fetchUser from &apos;twitter&apos;class Twitter extends Component &#123; state = &#123; user: null, &#125; static propTypes = &#123; username: PropTypes.string.isRequired, &#125; componentDidMount () &#123; fetchUser(this.props.username) .then((user) =&gt; this.setState(&#123;user&#125;)) &#125; render () &#123; return this.props.children(this.state.user) &#125;&#125; 这种模式的优势在于将父组件与子组件解耦和，父组件可以直接访问子组件的内部状态而不需要再通过Props传递，这样父组件能够更为方便地控制子组件展示的UI界面。譬如产品经理让我们将原本展示的Badge替换为Profile，我们可以轻易地修改下回调函数即可： 12345678910&lt;Twitter username=&apos;tylermcginnis33&apos;&gt; &#123;(user) =&gt; user === null ? &lt;Loading /&gt; : &lt;Profile info=&#123;user&#125; /&gt;&#125;&lt;/Twitter&gt; Controlled Component 与 Uncontrolled Component 之间的区别是什么？React 的核心组成之一就是能够维持内部状态的自治组件，不过当我们引入原生的HTML表单元素时（input,select,textarea 等），我们是否应该将所有的数据托管到 React 组件中还是将其仍然保留在 DOM 元素中呢？这个问题的答案就是受控组件与非受控组件的定义分割。受控组件（Controlled Component）代指那些交由 React 控制并且所有的表单数据统一存放的组件。譬如下面这段代码中username变量值并没有存放到DOM元素中，而是存放在组件状态数据中。任何时候我们需要改变username变量值时，我们应当调用setState函数进行修改。 12345678910111213141516171819202122232425262728293031323334353637383940414243class ControlledForm extends Component &#123; state = &#123; username: &apos;&apos; &#125; updateUsername = (e) =&gt; &#123; this.setState(&#123; username: e.target.value, &#125;) &#125; handleSubmit = () =&gt; &#123;&#125; render () &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;input type=&apos;text&apos; value=&#123;this.state.username&#125; onChange=&#123;this.updateUsername&#125; /&gt; &lt;button type=&apos;submit&apos;&gt;Submit&lt;/button&gt; &lt;/form&gt; ) &#125;&#125; 而非受控组件（Uncontrolled Component）则是由DOM存放表单数据，并非存放在 React 组件中。我们可以使用 refs 来操控DOM元素： 1234567891011121314151617181920212223242526272829class UnControlledForm extends Component &#123; handleSubmit = () =&gt; &#123; console.log(&quot;Input Value: &quot;, this.input.value) &#125; render () &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;input type=&apos;text&apos; ref=&#123;(input) =&gt; this.input = input&#125; /&gt; &lt;button type=&apos;submit&apos;&gt;Submit&lt;/button&gt; &lt;/form&gt; ) &#125;&#125; 竟然非受控组件看上去更好实现，我们可以直接从 DOM 中抓取数据，而不需要添加额外的代码。不过实际开发中我们并不提倡使用非受控组件，因为实际情况下我们需要更多的考虑表单验证、选择性的开启或者关闭按钮点击、强制输入格式等功能支持，而此时我们将数据托管到 React 中有助于我们更好地以声明式的方式完成这些功能。引入 React 或者其他 MVVM 框架最初的原因就是为了将我们从繁重的直接操作 DOM 中解放出来。 在生命周期中的哪一步你应该发起 AJAX 请求？我们应当将AJAX 请求放到 componentDidMount 函数中执行，主要原因有下： React 下一代调和算法 Fiber 会通过开始或停止渲染的方式优化应用性能，其会影响到 componentWillMount 的触发次数。对于 componentWillMount 这个生命周期函数的调用次数会变得不确定，React 可能会多次频繁调用 componentWillMount。如果我们将 AJAX 请求放到 componentWillMount 函数中，那么显而易见其会被触发多次，自然也就不是好的选择。如果我们将 AJAX 请求放置在生命周期的其他函数中，我们并不能保证请求仅在组件挂载完毕后才会要求响应。如果我们的数据请求在组件挂载之前就完成，并且调用了setState函数将数据添加到组件状态中，对于未挂载的组件则会报错。而在 componentDidMount 函数中进行 AJAX 请求则能有效避免这个问题。 shouldComponentUpdate 的作用是啥以及为何它这么重要？shouldComponentUpdate 允许我们手动地判断是否要进行组件更新，根据组件的应用场景设置函数的合理返回值能够帮我们避免不必要的更新。 如何告诉 React 它应该编译生产环境版本？通常情况下我们会使用 Webpack 的 DefinePlugin 方法来将 NODE_ENV 变量值设置为 production。编译版本中 React 会忽略 propType 验证以及其他的告警信息，同时还会降低代码库的大小，React 使用了 Uglify 插件来移除生产环境下不必要的注释等信息。 为什么我们需要使用 React 提供的 Children API 而不是 JavaScript 的 map？props.children并不一定是数组类型，譬如下面这个元素： 12345&lt;Parent&gt; &lt;h1&gt;Welcome.&lt;/h1&gt;&lt;/Parent&gt; 如果我们使用props.children.map函数来遍历时会受到异常提示，因为在这种情况下props.children是对象（object）而不是数组（array）。React 当且仅当超过一个子元素的情况下会将props.children设置为数组，就像下面这个代码片： 1234567&lt;Parent&gt; &lt;h1&gt;Welcome.&lt;/h1&gt; &lt;h2&gt;props.children will now be an array&lt;/h2&gt;&lt;/Parent&gt; 这也就是我们优先选择使用React.Children.map函数的原因，其已经将props.children不同类型的情况考虑在内了。 概述下 React 中的事件处理逻辑为了解决跨浏览器兼容性问题，React 会将浏览器原生事件（Browser Native Event）封装为合成事件（SyntheticEvent）传入设置的事件处理器中。这里的合成事件提供了与原生事件相同的接口，不过它们屏蔽了底层浏览器的细节差异，保证了行为的一致性。另外有意思的是，React 并没有直接将事件附着到子元素上，而是以单一事件监听器的方式将所有的事件发送到顶层进行处理。这样 React 在更新 DOM 的时候就不需要考虑如何去处理附着在 DOM 上的事件监听器，最终达到优化性能的目的。 createElement 与 cloneElement 的区别是什么？createElement 函数是 JSX 编译之后使用的创建 React Element 的函数，而 cloneElement 则是用于复制某个元素并传入新的 Props。 传入 setState 函数的第二个参数的作用是什么？该函数会在setState函数调用完成并且组件开始重渲染的时候被调用，我们可以用该函数来监听渲染是否完成： 12345678this.setState( &#123; username: &apos;tylermcginnis33&apos; &#125;, () =&gt; console.log(&apos;setState has finished and the component has re-rendered.&apos;)) 下述代码有错吗？ 123456789this.setState((prevState, props) =&gt; &#123; return &#123; streak: prevState.streak + props.count &#125;&#125;) 这段代码没啥问题，不过只是不太常用罢了，详细可以参考React中setState同步更新策略]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端文件断点续传]]></title>
      <url>%2F2017%2F04%2F11%2F%E5%89%8D%E7%AB%AF%E6%96%87%E4%BB%B6%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0%2F</url>
      <content type="text"><![CDATA[本文通过断点续传的简单例子（前端文件提交+后端PHP文件接收），理解其大致的实现过程 还是先以图片为例，看看最后的样子 一、一些知识准备断点续传，既然有断，那就应该有文件分割的过程，一段一段的传。 以前文件无法分割，但随着HTML5新特性的引入，类似普通字符串、数组的分割，我们可以可以使用slice方法来分割文件。 所以断点续传的最基本实现也就是：前端通过FileList对象获取到相应的文件，按照指定的分割方式将大文件分段，然后一段一段地传给后端，后端再按顺序一段段将文件进行拼接。 而我们需要对FileList对象进行修改再提交，在之前的文章中知晓了这种提交的一些注意点，因为FileList对象不能直接更改，所以不能直接通过表单的.submit()方法上传提交，需要结合FormData对象生成一个新的数据，通过Ajax进行上传操作。 二、实现过程 这个例子实现了文件断点续传的基本功能，不过手动的“暂停上传”操作还未实现成功，可以在上传过程中刷新页面来模拟上传的中断，体验“断点续传”、 有可能还有其他一些小bug，但基本逻辑大致如此。 前端实现 首先选择文件，列出选中的文件列表信息，然后可以自定义的做上传操作 （1）所以先设置好页面DOM结构 这里一并将CSS样式扔出来 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849body &#123; font-family: Arial;&#125;form &#123; margin: 50px auto; width: 600px;&#125;input[type=&quot;button&quot;] &#123; cursor: pointer;&#125;table &#123; display: none; margin-top: 15px; border: 1px solid #ddd; border-collapse: collapse;&#125;table th &#123; color: #666;&#125;table td, table th &#123; padding: 5px; border: 1px solid #ddd; text-align: center; font-size: 14px;&#125; （2）接下来是JS的实现解析 通过FileList对象我们能获取到文件的一些信息 其中的size就是文件的大小，文件的分分割分片需要依赖这个 这里的size是字节数，所以在界面显示文件大小时，可以这样转化 12345678910111213141516// 计算文件大小size = file.size &gt; 1024 ? file.size / 1024 &gt; 1024 ? file.size / (1024 * 1024) &gt; 1024 ? (file.size / (1024 * 1024 * 1024)).toFixed(2) + &apos;GB&apos; : (file.size / (1024 * 1024)).toFixed(2) + &apos;MB&apos; : (file.size / 1024).toFixed(2) + &apos;KB&apos; : (file.size).toFixed(2) + &apos;B&apos;; 选择文件后显示文件的信息，在模版中替换一下数据 // 更新文件信息列表123456789101112131415uploadItem.push(uploadItemTpl .replace(/&#123;&#123;fileName&#125;&#125;/g, file.name) .replace(&apos;&#123;&#123;fileType&#125;&#125;&apos;, file.type || file.name.match(/\.\w+$/) + &apos;文件&apos;) .replace(&apos;&#123;&#123;fileSize&#125;&#125;&apos;, size) .replace(&apos;&#123;&#123;progress&#125;&#125;&apos;, progress) .replace(&apos;&#123;&#123;totalSize&#125;&#125;&apos;, file.size) .replace(&apos;&#123;&#123;uploadVal&#125;&#125;&apos;, uploadVal)); 不过，在显示文件信息的时候，可能这个文件之前之前已经上传过了，为了断点续传，需要判断并在界面上做出提示 通过查询本地看是否有相应的数据（这里的做法是当本地记录的是已经上传100%时，就直接是重新上传而不是继续上传了） // 初始通过本地记录，判断该文件是否曾经上传过1234567891011percent = window.localStorage.getItem(file.name + &apos;_p&apos;);if (percent &amp;&amp; percent !== &apos;100.0&apos;) &#123; progress = &apos;已上传 &apos; + percent + &apos;%&apos;; uploadVal = &apos;继续上传&apos;;&#125; 显示了文件信息列表 点击开始上传，可以上传相应的文件 上传文件的时候需要就将文件进行分片分段 比如这里配置的每段1024B，总共chunks段（用来判断是否为末段），第chunk段，当前已上传的百分比percent等 需要提一下的是这个暂停上传的操作，其实我还没实现出来，暂停不了无奈ing… 接下来是分段过程 // 上传之前查询是否以及上传过分片123chunk = window.localStorage.getItem(fileName + &apos;_chunk&apos;) || 0;chunk = parseInt(chunk, 10); 文件应该支持覆盖上传，所以如果文件以及上传完了，现在再上传，应该重置数据以支持覆盖（不然后端就直接追加blob数据了） 1234567891011// 如果第一次上传就为末分片，即文件已经上传完成，则重新覆盖上传if (times === &apos;first&apos; &amp;&amp; isLastChunk === 1) &#123; window.localStorage.setItem(fileName + &apos;_chunk&apos;, 0); chunk = 0; isLastChunk = 0;&#125; 这个times其实就是个参数，因为要在上一分段传完之后再传下一分段，所以这里的做法是在回调中继续调用这个上传操作 接下来就是真正的文件上传操作了，用Ajax上传，因为用到了FormData对象，所以不要忘了在$.ajax({}加上这个配置processData: false 上传了一个分段，通过返回的结果判断是否上传完毕，是否继续上传 继续下一分段的上传时，就进行了递归操作，按顺序地上传下一分段 截个图.. 这是完整的JS逻辑，代码有点儿注释了应该不难看懂吧哈哈 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387// 全部上传操作$(document).on(&apos;click&apos;, &apos;#upload-all-btn&apos;, function () &#123; // 未选择文件 if (!$(&apos;#myFile&apos;).val()) &#123; $(&apos;#myFile&apos;).focus(); &#125; // 模拟点击其他可上传的文件 else &#123; $(&apos;#upload-list .upload-item-btn&apos;).each(function () &#123; $(this).click(); &#125;); &#125;&#125;);// 选择文件-显示文件信息$(&apos;#myFile&apos;).change(function (e) &#123; var file, uploadItem = [], uploadItemTpl = $(&apos;#file-upload-tpl&apos;).html(), size, percent, progress = &apos;未上传&apos;, uploadVal = &apos;开始上传&apos;; for (var i = 0, j = this.files.length; i &lt; j; ++i) &#123; file = this.files[i]; percent = undefined; progress = &apos;未上传&apos;; uploadVal = &apos;开始上传&apos;; // 计算文件大小 size = file.size &gt; 1024 ? file.size / 1024 &gt; 1024 ? file.size / (1024 * 1024) &gt; 1024 ? (file.size / (1024 * 1024 * 1024)).toFixed(2) + &apos;GB&apos; : (file.size / (1024 * 1024)).toFixed(2) + &apos;MB&apos; : (file .size / 1024).toFixed(2) + &apos;KB&apos; : (file.size).toFixed(2) + &apos;B&apos;; // 初始通过本地记录，判断该文件是否曾经上传过 percent = window.localStorage.getItem(file.name + &apos;_p&apos;); if (percent &amp;&amp; percent !== &apos;100.0&apos;) &#123; progress = &apos;已上传 &apos; + percent + &apos;%&apos;; uploadVal = &apos;继续上传&apos;; &#125; // 更新文件信息列表 uploadItem.push(uploadItemTpl .replace(/&#123;&#123;fileName&#125;&#125;/g, file.name) .replace(&apos;&#123;&#123;fileType&#125;&#125;&apos;, file.type || file.name.match(/\.\w+$/) + &apos;文件&apos;) .replace(&apos;&#123;&#123;fileSize&#125;&#125;&apos;, size) .replace(&apos;&#123;&#123;progress&#125;&#125;&apos;, progress) .replace(&apos;&#123;&#123;totalSize&#125;&#125;&apos;, file.size) .replace(&apos;&#123;&#123;uploadVal&#125;&#125;&apos;, uploadVal)); &#125; $(&apos;#upload-list&apos;).children(&apos;tbody&apos;).html(uploadItem.join(&apos;&apos;)) .end().show();&#125;);/*** 上传文件时，提取相应匹配的文件项* @param &#123;String&#125; fileName 需要匹配的文件名* @return &#123;FileList&#125; 匹配的文件项目*/function findTheFile(fileName) &#123; var files = $(&apos;#myFile&apos;)[0].files, theFile; for (var i = 0, j = files.length; i &lt; j; ++i) &#123; if (files[i].name === fileName) &#123; theFile = files[i]; break; &#125; &#125; return theFile ? theFile : [];&#125;// 上传文件$(document).on(&apos;click&apos;, &apos;.upload-item-btn&apos;, function () &#123; var $this = $(this), state = $this.attr(&apos;data-state&apos;), msg = &#123; done: &apos;上传成功&apos;, failed: &apos;上传失败&apos;, in : &apos;上传中...&apos;, paused: &apos;暂停中...&apos; &#125;, fileName = $this.attr(&apos;data-name&apos;), $progress = $this.closest(&apos;tr&apos;).find(&apos;.upload-progress&apos;), eachSize = 1024, totalSize = $this.attr(&apos;data-size&apos;), chunks = Math.ceil(totalSize / eachSize), percent, chunk, // 暂停上传操作 isPaused = 0; // 进行暂停上传操作 // 未实现，这里通过动态的设置isPaused值并不能阻止下方ajax请求的调用 if (state === &apos;uploading&apos;) &#123; $this.val(&apos;继续上传&apos;).attr(&apos;data-state&apos;, &apos;paused&apos;); $progress.text(msg[&apos;paused&apos;] + percent + &apos;%&apos;); isPaused = 1; console.log(&apos;暂停：&apos;, isPaused); &#125; // 进行开始/继续上传操作 else if (state === &apos;paused&apos; || state === &apos;default&apos;) &#123; $this.val(&apos;暂停上传&apos;).attr(&apos;data-state&apos;, &apos;uploading&apos;); isPaused = 0; &#125; // 第一次点击上传 startUpload(&apos;first&apos;); // 上传操作 times: 第几次 function startUpload(times) &#123; // 上传之前查询是否以及上传过分片 chunk = window.localStorage.getItem(fileName + &apos;_chunk&apos;) || 0; chunk = parseInt(chunk, 10); // 判断是否为末分片 var isLastChunk = (chunk == (chunks - 1) ? 1 : 0); // 如果第一次上传就为末分片，即文件已经上传完成，则重新覆盖上传 if (times === &apos;first&apos; &amp;&amp; isLastChunk === 1) &#123; window.localStorage.setItem(fileName + &apos;_chunk&apos;, 0); chunk = 0; isLastChunk = 0; &#125; // 设置分片的开始结尾 var blobFrom = chunk * eachSize, // 分段开始 blobTo = (chunk + 1) * eachSize &gt; totalSize ? totalSize : (chunk + 1) * eachSize, // 分段结尾 percent = (100 * blobTo / totalSize).toFixed(1), // 已上传的百分比 timeout = 5000, // 超时时间 fd = new FormData($(&apos;#myForm&apos;)[0]); fd.append(&apos;theFile&apos;, findTheFile(fileName).slice(blobFrom, blobTo)); // 分好段的文件 fd.append(&apos;fileName&apos;, fileName); // 文件名 fd.append(&apos;totalSize&apos;, totalSize); // 文件总大小 fd.append(&apos;isLastChunk&apos;, isLastChunk); // 是否为末段 fd.append(&apos;isFirstUpload&apos;, times === &apos;first&apos; ? 1 : 0); // 是否是第一段（第一次上传） // 上传 $.ajax(&#123; type: &apos;post&apos;, url: &apos;/fileTest.php&apos;, data: fd, processData: false, contentType: false, timeout: timeout, success: function (rs) &#123; rs = JSON.parse(rs); // 上传成功 if (rs.status === 200) &#123; // 记录已经上传的百分比 window.localStorage.setItem(fileName + &apos;_p&apos;, percent); // 已经上传完毕 if (chunk === (chunks - 1)) &#123; $progress.text(msg[&apos;done&apos;]); $this.val(&apos;已经上传&apos;).prop(&apos;disabled&apos;, true).css(&apos;cursor&apos;, &apos;not-allowed&apos;); if (!$(&apos;#upload-list&apos;).find(&apos;.upload-item-btn:not(:disabled)&apos;).length) &#123; $(&apos;#upload-all-btn&apos;).val(&apos;已经上传&apos;).prop(&apos;disabled&apos;, true).css(&apos;cursor&apos;, &apos;not-allowed&apos;); &#125; &#125; else &#123; // 记录已经上传的分片 window.localStorage.setItem(fileName + &apos;_chunk&apos;, ++chunk); $progress.text(msg[&apos;in&apos;] + percent + &apos;%&apos;); // 这样设置可以暂停，但点击后动态的设置就暂停不了.. // if (chunk == 10) &#123; // isPaused = 1; // &#125; console.log(isPaused); if (!isPaused) &#123; startUpload(); &#125; &#125; &#125; // 上传失败，上传失败分很多种情况，具体按实际来设置 else if (rs.status === 500) &#123; $progress.text(msg[&apos;failed&apos;]); &#125; &#125;, error: function () &#123; $progress.text(msg[&apos;failed&apos;]); &#125; &#125;); &#125;&#125;); 后端实现 这里的后端实现还是比较简单的，主要用依赖了 file_put_contents、file_get_contents 这两个方法 要注意一下，通过FormData对象上传的文件对象，在PHP中也是通过$_FILES全局对象获取的，还有为了避免上传后文件中文的乱码，用一下iconv 断点续传支持文件的覆盖，所以如果已经存在完整的文件，就将其删除 1234567// 如果第一次上传的时候，该文件已经存在，则删除文件重新上传if ($isFirstUpload == &apos;1&apos; &amp;&amp; file_exists(&apos;upload/&apos;.$fileName) &amp;&amp; filesize(&apos;upload/&apos;.$fileName) == $totalSize) &#123; unlink(&apos;upload/&apos;.$fileName);&#125; 使用上述的两个方法，进行文件信息的追加，别忘了加上 FILE_APPEND 这个参数~ 一般在传完后都需要进行文件的校验吧，所以这里简单校验了文件大小是否一致 根据实际需求的不同有不同的错误处理方法，这里就先不多处理了 完整的PHP部分]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浅析前端渲染机制]]></title>
      <url>%2F2017%2F04%2F10%2F%E6%B5%85%E6%9E%90%E5%89%8D%E7%AB%AF%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%2F</url>
      <content type="text"><![CDATA[作为一个前端开发，最常见的运行环境应该是浏览器吧，为了更好的通过浏览器把优秀的产品带给用户，也为了更好的发展自己的前端职业之路，有必要了解从我们在浏览器地址栏输入网址到看到页面这期间浏览器是如何进行工作的,进而了解如何更好的优化实践，本篇主要围绕这两点展开阐述。前端页面渲染机制可谓是老生常谈，但又很有必要再谈的话题，于是还是决定写一篇，即是对知识的回顾总结，又能与大家分享，何乐而不为。网上相关类型的文章也很多，有兴趣的可以多学习一下。 浏览器在介绍浏览器工作流程之前，先了解一下主流浏览器的基础结构，本文所介绍的浏览器主要为开源的Chrome，FireFox及部分开源的Safari，这也是目前市场占比最高的几大浏览器，以本人博客网站为例，可以大致看出各浏览器使用比例： 浏览器占比浏览器基础结构 浏览器基础结构主要包括如下7部分： 1.用户界面（User Interface）:用户所看到及与之交互的功能组件，如地址栏，返回，前进按钮等； 2.浏览器引擎（Browser engine）:负责控制和管理下一级的渲染引擎； 3.渲染引擎（Rendering engine）:负责解析用户请求的内容（如HTML或XML，渲染引擎会解析HTML或XML，以及相关CSS，然后返回解析后的内容）； 4.网络（Networking）:负责处理网络相关的事务，如HTTP请求等； 5.UI后端（UI backend）:负责绘制提示框等浏览器组件，其底层使用的是操作系统的用户接口； 6.JavaScript解释器（JavaScript interpreter）:负责解析和执行JavaScript代码； 7.数据存储（Data storage）:负责持久存储诸如cookie和缓存等应用数据。浏览器基础结构浏览器内核 各大主要浏览器使用内核也是有差别的，大致可以分为以下几类： Trident内核： IEWebkit内核：Chrome,SafariGecko内核：FireFox 网络当用户访问页面时，浏览器需要获取用户请求内容，这个过程主要涉及浏览器网络模块： 1.用户在地址栏输入域名，如baidu.com，DNS（Domain Name System，域名解析系统）服务器根据输入的域名查找对应IP，然后向该IP地址发起请求；DNS 2.浏览器获得并解析服务器的返回内容(HTTP response)；3.浏览器加载HTML文件及文件内包含的外部引用文件及图片，多媒体等资源。DNS预解析（DNS PREFETCH） 浏览器DNS解析大多时候较快，且会缓存常用域名的解析值，但是如果网站涉及多域名，在对每一个域名访问时都需要先解析出IP地址，而我们希望在跳转或者请求其他域名资源时尽量快，则可以开启域名预解析，浏览器会在空闲时提前解析声明需要预解析的域名，如： 域名预解析多进程 我们通常说JavaScript执行是单进程的，但是浏览器网络部分通常是有几个平行进程同时开启，但是也会有限制，一般为2-6个。 渲染引擎及关键渲染路径（Critical Rendering Path）渲染引擎所做的事是将请求内容展现给我们，默认支持HTML,XML和图片类型，对于其他诸如PDF等类型的内容则需要安装相应插件，但浏览器的展示工作流程基本是一样的。 通过网络模块加载到HTML文件后渲染引擎渲染流程如下，这也通常被称作关键渲染路径（Critical Rendering Path）： 1.构建DOM树(DOM tree)：从上到下解析HTML文档生成DOM节点树（DOM tree），也叫内容树（content tree）； 2.构建CSSOM(CSS Object Model)树：加载解析样式生成CSSOM树； 3.执行JavaScript：加载并执行JavaScript代码（包括内联代码或外联JavaScript文件）； 4.构建渲染树(render tree)：根据DOM树和CSSOM树,生成渲染树(render tree)；渲染树：按顺序展示在屏幕上的一系列矩形，这些矩形带有字体，颜色和尺寸等视觉属性。 5.布局（layout）：根据渲染树将节点树的每一个节点布局在屏幕上的正确位置； 6.绘制（painting）：遍历渲染树绘制所有节点，为每一个节点适用对应的样式，这一过程是通过UI后端模块完成；关键渲染路径为了更友好的用户体验，浏览器会尽可能快的展现内容，而不会等到文档所有内容到达才开始解析和构建/布局渲染树，而是每次处理一部分，并展现在屏幕上，这也是为什么我们经常可以看到页面加载的时候内容是从上到下一点一点展现的。 流程图Webkit渲染引擎流程如下图： Gecko渲染引擎流程如下图： 如上图，Webkit浏览器和Gecko浏览器渲染流程大致相同,不同的是：1231.Webkit浏览器中的渲染树(render tree)，在Gecko浏览器中对应的则是框架树（frame tree）,渲染对象(render object)对应的是框架（frame）;2.Webkit中的布局（Layout）过程，在Gecko中称为回流（Reflow）,本质是一样的，后文会解释回流的另一层含义–重新布局；3.Gecko中HTML和DOM树中间多了一层内容池（Content sink）,可以理解成生成DOM元素的工厂。 单进程不同于网络部分的多进程渲染引擎是单线程工作的，意味着渲染流程是一步一步渐进完成的。 解析文档(PARSER HTML)在详细介绍浏览器渲染文档之前，先应该理解浏览器如何解析文档：解析文档的顺序，对于CSS和JavaScript如何处理等。 解析顺序浏览器按从上到下的顺序扫描解析文档； 解析样式和脚本脚本 或许是由于通常会在JavaScript脚本中改变文档DOM结构，于是浏览器以同步方式解析，加载和执行脚本，浏览器在解析文档时，当解析到标签时，会解析其中的脚本（对于外链的JavaScript文件，需要先加载该文件内容，再进行解析），然后立即执行，这整个过程都会阻塞文档解析，直到脚本执行完才会继续解析文档。就是说由于脚本是同步加载和执行的，它会阻塞文档解析，这也解释了为什么现在通常建议将标签放在标签前面，而不是放在标签里。现在HTML5提供defer和async两个属性支持延迟和异步加载JavaScript文件，如：1&lt;script defer src=&quot;script.js&quot;&gt; 改进 针对上文说的脚本阻塞文档解析，主流浏览器如Chrome和FireFox等都有一些优化，比如在执行脚本时，开启另一个进程解析剩余的文档以找出并加载其他的待下载外部资源（不改变主进程的DOM树，仅优化加载外部资源）。 样式 不同于脚本，浏览器对样式的处理并不会阻塞文档解析，大概是因为样式表并不会改变DOM结构。 样式表与脚本 你可能想问样式是否会阻塞脚本文件的加载执行呢？正常情况是不会的，但是存在一个问题是通常我们会在脚本中请求样式信息，但是在文档解析时，如果样式尚未加载或解析，将会得到错误信息，对于这一问题，FireFox浏览器和Webkit浏览器处理策略不同： 当存在有样式文件未被加载和解析时，FireFox浏览器会阻塞所有脚本；而Webkit浏览器只会阻塞操作了改文件内声明的样式属性的脚本。构建DOM树 DOM，即文档对象模型（Document Object Model）,DOM树，即文档内所有节点构成的一个树形结构。 假设浏览器获取返回的如下HTML文档： 12345678910111213&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./theme.css&quot;&gt;&lt;/link&gt; &lt;script src=&quot;./config.js&quot;&gt;&lt;/script&gt; &lt;title&gt;关键渲染路径&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 class=&quot;title&quot;&gt;关键渲染路径&lt;/h1&gt; &lt;p&gt;关键渲染路径介绍&lt;/p&gt; &lt;footer&gt;@copyright2017&lt;/footer&gt;&lt;/body&gt;&lt;/html&gt; 首先浏览器从上到下依次解析文档构建DOM树，如下： 构建CSSOM树 CSSOM，即CSS对象模型（CSS Object Model），CSSOM树，与DOM树结构相似，只是另外为每一个节点关联了样式信息。 theme.css样式内容如下： 123456789101112html, body &#123;width: 100%;height: 100%;background-color: #fcfcfc;&#125;.title &#123;font-size: 20px;&#125;.footer &#123;font-size: 12px;color: #aaa;&#125; 构建CSSOM树如图： 执行JAVASCRIPT 上文已经阐述了文档解析时对脚本的处理，我们得知脚本加载，解析和执行会阻塞文档解析，而在特殊情况下样式的加载和解析也会阻塞脚本，所以现在推荐的实践是标签放在标签前面。 构建渲染树(RENDER TREE) DOM树和CSSOM树都构建完了，接着浏览器会构建渲染树： 渲染树，代表一个文档的视觉展示，浏览器通过它将文档内容绘制在浏览器窗口，展示给用户，它由按顺序展示在屏幕上的一系列矩形对象组成，这些矩形对象都带有字体，颜色和尺寸，位置等视觉样式属性。对于这些矩对象，FireFox称之为框架（frame）,Webkit浏览器称之为渲染对象（render object, renderer），后文统称为渲染对象。这里把渲染树节点称为矩形对象，是因为，每一个渲染对象都代表着其对应DOM节点的CSS盒子,该盒子包含了尺寸，位置等几何信息，同时它指向一个样式对象包含其他视觉样式信息。 渲染树与DOM树每一个渲染对象都对应着DOM节点，但是非视觉（隐藏，不占位）DOM元素不会插入渲染树，如元素或声明display: none;的元素，渲染对象与DOM节点不是简单的一对一的关系，一个DOM可以对应一个渲染对象，但一个DOM元素也可能对应多个渲染对象，因为有很多元素不止包含一个CSS盒子，如当文本被折行时，会产生多个行盒，这些行会生成多个渲染对象；又如行内元素同时包含块元素和行内元素，则会创建一个匿名块级盒包含内部行内元素，此时一个DOM对应多个矩形对象（渲染对象）。 渲染树及其对应DOM树如图： 图中渲染树viewport即视口，是文档的初始包含块，scroll代表滚动区域，详见CSS之视觉格式化模型(Visual Formatting Model)渲染树并不会包含显式或隐式地display：none;的标签元素。布局（LAYOUT）或回流（REFLOW，RELAYOUT） 创建渲染树后，下一步就是布局（Layout）,或者叫回流（reflow,relayout），这个过程就是通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸，将其安置在浏览器窗口的正确位置，而有些时候我们会在文档布局完成后对DOM进行修改，这时候可能需要重新进行布局，也可称其为回流，本质上还是一个布局的过程，每一个渲染对象都有一个布局或者回流方法，实现其布局或回流。 流（flow）HTML采用的是基于流的方式定位布局，其按照从左到右，从上到下的顺序进行排列，详见CSS定位机制。 全局布局与局部布局对渲染树的布局可以分为全局和局部的，全局即对整个渲染树进行重新布局，如当我们改变了窗口尺寸或方向或者是修改了根元素的尺寸或者字体大小等；而局部布局可以是对渲染树的某部分或某一个渲染对象进行重新布局。 脏位系统（dirty bit system）大多数web应用对DOM的操作都是比较频繁，这意味着经常需要对DOM进行布局和回流，而如果仅仅是一些小改变，就触发整个渲染树的回流，这显然是不好的，为了避免这种情况，浏览器使用了脏位系统，只有一个渲染对象改变了或者某渲染对象及其子渲染对象脏位值为”dirty”时，说明需要回流。 表示需要布局的脏位值有两种： “dirty”–自身改变，需要回流“children are dirty”–子节点改变，需要回流布局过程布局是一个从上到下，从外到内进行的递归过程，从根渲染对象，即对应着HTML文档根元素，然后下一级渲染对象，如对应着元素，如此层层递归，依次计算每一个渲染对象的几何信息（位置和尺寸）。 几何信息-位置和尺寸，即相对于窗口的坐标和尺寸，如根渲染对象，其坐标为（0， 0），尺寸即是视口尺寸（浏览器窗口的可视区域）。 每一个渲染对象的布局流程基本如： 1.计算此渲染对象的宽度（width）；2.遍历此渲染对象的所有子级，依次：2.1设置子级渲染对象的坐标2.2判断是否需要触发子渲染对象的布局或回流方法，计算子渲染对象的高度（height）3.设置此渲染对象的高度：根据子渲染对象的累积高，margin和padding的高度设置其高度；4.设置此渲染对象脏位值为false。强制回流在渲染树布局完成后，再次操作文档，改变文档的内容或结构，或者元素定位时，会触发回流，即需要重新布局，如请求某DOM的”offsetHeight”样式信息等诸多情况： DOM操作，如增加，删除，修改或移动；变更内容；激活伪类；访问或改变某些CSS属性（包括修改样式表或元素类名或使用JavaScript操作等方式）；浏览器窗口变化（滚动或尺寸变化） $(&apos;body&apos;).css(&apos;padding&apos;); // reflow 有过CSS3动画开发经验的同学可能会有经历，如下入场动画： .slide-left { -webkit-transition: margin-left 1s ease-out; -moz-transition: margin-left 1s ease-out; -o-transition: margin-left 1s ease-out; transition: margin-left 1s ease-out; } 然后执行如下脚本： var $slide = $(&apos;.slide-left&apos;); $slide.css({ &quot;margin-left&quot;: &quot;100px&quot; }).addClass(&apos;slide-left&apos;); $slide.css({ &quot;margin-left&quot;: &quot;10px&quot; }); 我们会发现并没有效果，为什么呢？因为对margin-left的修改并没有触发回流，元素margin-left值的改变被缓存，如果我们在中间强制触发回流： var $slide = $(&apos;.slide-left&apos;); $slide.css({ &quot;margin-left&quot;: &quot;100px&quot; }); console.log($slide.css(&apos;padding&apos;); $slide.addClass(&apos;slide-left&apos;); $slide.css({ &quot;margin-left&quot;: &quot;10px&quot; }); 再看就达到了预期效果。 绘制（PAINTING） 最后是绘制(paint)阶段或重绘（repaint）阶段，浏览器UI组件将遍历渲染树并调用渲染对象的绘制（paint）方法，将内容展现在屏幕上，也有可能在之后对DOM进行修改，需要重新绘制渲染对象，也就是重绘，绘制和重绘的关系可以参考布局和回流的关系。 全局与局部绘制与布局相似，绘制也分为全局和局部绘制，即对整个渲染树或某些渲染对象进行绘制。 触发重绘我们已经知道很多操作可能会触发回流，那么什么时候可能触发重绘呢，通常，当改变元素的视觉样式，如background-color,visibility，margin，padding或字体颜色时会触发全局或局部重绘，如： $(&apos;body&apos;).css(&apos;color&apos;, &apos;red&apos;); // repaint $(&apos;body&apos;).css(&apos;margin&apos;, &apos;2px&apos;); // reflow, repaint 页面渲染优化浏览器对上文介绍的关键渲染路径进行了很多优化，针对每一次变化产生尽量少的操作，还有优化判断重新绘制或布局的方式等等。 在改变文档根元素的字体颜色等视觉性信息时，会触发整个文档的重绘，而改变某元素的字体颜色则只触发特定元素的重绘；改变元素的位置信息会同时触发此元素（可能还包括其兄弟元素或子级元素）的布局和重绘。某些重大改变，如更改文档根元素的字体尺寸，则会触发整个文档的重新布局和重绘，据此及上文所述，推荐以下优化和实践：` 1.HTML文档结构层次尽量少，最好不深于六层； 2.脚本尽量后放，放在前即可； 3.少量首屏样式内联放在标签内； 4.样式结构层次尽量简单； 5.在脚本中尽量减少DOM操作，尽量缓存访问DOM的样式信息，避免过度触发回流； 6.减少通过JavaScript代码修改元素样式，尽量使用修改class名方式操作样式或动画； 7.动画尽量使用在绝对定位或固定定位的元素上； 8.隐藏在屏幕外，或在页面滚动时，尽量停止动画； 9.尽量缓存DOM查找，查找器尽量简洁； 10.涉及多域名的网站，可以开启域名预解析` 实例当我们访问一个页面时，浏览器渲染事件详细日志图如下：浏览器渲染事件日志 1.发起请求；2.解析HTML；3.解析样式；4.执行JavaScript；5.布局；6.绘制]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[移动端知识点整理]]></title>
      <url>%2F2017%2F04%2F08%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%B5%84%E6%BA%90%E6%95%B4%E7%90%86%2F</url>
      <content type="text"><![CDATA[meta基础知识 H5页面窗口自动调整到设备宽度，并禁止用户缩放页面 &lt;meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no" /&gt; 忽略将页面中的数字识别为电话号码 &lt;meta name="format-detection" content="telephone=no" /&gt; 忽略Android平台中对邮箱地址的识别 &lt;meta name="format-detection" content="email=no" /&gt; 当网站添加到主屏幕快速启动方式，可隐藏地址栏，仅针对ios的safari &lt;meta name="apple-mobile-web-app-capable" content="yes" /&gt; &lt;!-- ios7.0版本以后，safari上已看不到效果 --&gt; 将网站添加到主屏幕快速启动方式，仅针对ios的safari顶端状态条的样式 &lt;meta name="apple-mobile-web-app-status-bar-style" content="black" /&gt; &lt;!-- 可选default、black、black-translucent --&gt; viewport模板 viewport模板&mdash;&mdash;通用 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" name="viewport"&gt; &lt;meta content="yes" name="apple-mobile-web-app-capable"&gt; &lt;meta content="black" name="apple-mobile-web-app-status-bar-style"&gt; &lt;meta content="telephone=no" name="format-detection"&gt; &lt;meta content="email=no" name="format-detection"&gt; &lt;title&gt;标题&lt;/title&gt; &lt;link rel="stylesheet" href="index.css"&gt; &lt;/head&gt; &lt;body&gt; 这里开始内容 &lt;/body&gt; &lt;/html&gt; &nbsp; viewport模板 -&nbsp;target-densitydpi=device-dpi，android 2.3.5以下版本不支持 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=750, user-scalable=no, target-densitydpi=device-dpi"&gt;&lt;!-- width取值与页面定义的宽度一致 --&gt; &lt;meta content="yes" name="apple-mobile-web-app-capable"&gt; &lt;meta content="black" name="apple-mobile-web-app-status-bar-style"&gt; &lt;meta content="telephone=no" name="format-detection"&gt; &lt;meta content="email=no" name="format-detection"&gt; &lt;title&gt;标题&lt;/title&gt; &lt;link rel="stylesheet" href="index.css"&gt; &lt;/head&gt; &lt;body&gt; 这里开始内容 &lt;/body&gt; &lt;/html&gt; &nbsp; 常见问题 移动端如何定义字体font-family 中文字体使用系统默认即可，英文用Helvetica /* 移动端定义字体的代码 */ body{font-family:Helvetica;} 参考《移动端使用字体的思考》 移动端字体单位font-size选择px还是rem 对于只需要适配少部分手机设备，且分辨率对页面影响不大的，使用px即可 对于需要适配各种移动设备，使用rem，例如只需要适配iPhone和iPad等分辨率差别比较挺大的设备 rem配置参考： html{font-size:10px} @media screen and (min-width:321px) and (max-width:375px){html{font-size:11px}} @media screen and (min-width:376px) and (max-width:414px){html{font-size:12px}} @media screen and (min-width:415px) and (max-width:639px){html{font-size:15px}} @media screen and (min-width:640px) and (max-width:719px){html{font-size:20px}} @media screen and (min-width:720px) and (max-width:749px){html{font-size:22.5px}} @media screen and (min-width:750px) and (max-width:799px){html{font-size:23.5px}} @media screen and (min-width:800px){html{font-size:25px}} 体验demo：http://1.peunzhang.sinaapp.com/demo/rem/index.html 移动端touch事件(区分webkit 和 winphone) 当用户手指放在移动设备在屏幕上滑动会触发的touch事件 以下支持webkit touchstart&mdash;&mdash;当手指触碰屏幕时候发生。不管当前有多少只手指 touchmove&mdash;&mdash;当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用event的preventDefault()可以阻止默认情况的发生：阻止页面滚动 touchend&mdash;&mdash;当手指离开屏幕时触发 touchcancel&mdash;&mdash;系统停止跟踪触摸时候会触发。例如在触摸过程中突然页面alert()一个提示框，此时会触发该事件，这个事件比较少用 TouchEvent touches：屏幕上所有手指的信息 targetTouches：手指在目标区域的手指信息 changedTouches：最近一次触发该事件的手指信息 touchend时，touches与targetTouches信息会被删除，changedTouches保存的最后一次的信息，最好用于计算手指信息 参数信息(changedTouches[0]) clientX、clientY在显示区的坐标 target：当前元素 参考：https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent 以下支持winphone 8 MSPointerDown&mdash;&mdash;当手指触碰屏幕时候发生。不管当前有多少只手指 MSPointerMove&mdash;&mdash;当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用css的html{-ms-touch-action: none;}可以阻止默认情况的发生：阻止页面滚动 MSPointerUp&mdash;&mdash;当手指离开屏幕时触发 移动端click屏幕产生200-300 ms的延迟响应 移动设备上的web网页是有300ms延迟的，玩玩会造成按钮点击延迟甚至是点击失效。 以下是历史原因，来源一个公司内一个同事的分享： 2007年苹果发布首款iphone上IOS系统搭载的safari为了将适用于PC端上大屏幕的网页能比较好的展示在手机端上，使用了双击缩放(double tap to zoom)的方案，比如你在手机上用浏览器打开一个PC上的网页，你可能在看到页面内容虽然可以撑满整个屏幕，但是字体、图片都很小看不清，此时可以快速双击屏幕上的某一部分，你就能看清该部分放大后的内容，再次双击后能回到原始状态。 双击缩放是指用手指在屏幕上快速点击两次，iOS 自带的 Safari 浏览器会将网页缩放至原始比例。 原因就出在浏览器需要如何判断快速点击上，当用户在屏幕上单击某一个元素时候，例如跳转链接&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;，此处浏览器会先捕获该次单击，但浏览器不能决定用户是单纯要点击链接还是要双击该部分区域进行缩放操作，所以，捕获第一次单击后，浏览器会先Hold一段时间t，如果在t时间区间里用户未进行下一次点击，则浏览器会做单击跳转链接的处理，如果t时间里用户进行了第二次单击操作，则浏览器会禁止跳转，转而进行对该部分区域页面的缩放操作。那么这个时间区间t有多少呢？在IOS safari下，大概为300毫秒。这就是延迟的由来。造成的后果用户纯粹单击页面，页面需要过一段时间才响应，给用户慢体验感觉，对于web开发者来说是，页面js捕获click事件的回调函数处理，需要300ms后才生效，也就间接导致影响其他业务逻辑的处理。 解决方案： fastclick可以解决在手机上点击事件的300ms延迟 zepto的touch模块，tap事件也是为了解决在click的延迟问题 触摸事件的响应顺序 1、ontouchstart 2、ontouchmove 3、ontouchend 4、onclick 解决300ms延迟的问题，也可以通过绑定ontouchstart事件，加快对事件的响应 什么是Retina 显示屏，带来了什么问题 retina：一种具备超高像素密度的液晶屏，同样大小的屏幕上显示的像素点由1个变为多个，如在同样带下的屏幕上，苹果设备的retina显示屏中，像素点1个变为4个 在高清显示屏中的位图被放大，图片会变得模糊，因此移动端的视觉稿通常会设计为传统PC的2倍 那么，前端的应对方案是： 设计稿切出来的图片长宽保证为偶数，并使用backgroud-size把图片缩小为原来的1/2 //例如图片宽高为：200px*200px，那么写法如下 .css{width:100px;height:100px;background-size:100px 100px;} 其它元素的取值为原来的1/2，例如视觉稿40px的字体，使用样式的写法为20px .css{font-size:20px} 参考《高清显示屏原理及设计方案》 ios系统中元素被触摸时产生的半透明灰色遮罩怎么去掉 ios用户点击一个链接，会出现一个半透明灰色遮罩,&nbsp;如果想要禁用，可设置-webkit-tap-highlight-color的alpha值为0，也就是属性值的最后一位设置为0就可以去除半透明灰色遮罩 a,button,input,textarea{-webkit-tap-highlight-color: rgba(0,0,0,0;)} 部分android系统中元素被点击时产生的边框怎么去掉 android用户点击一个链接，会出现一个边框或者半透明灰色遮罩,&nbsp;不同生产商定义出来额效果不一样，可设置-webkit-tap-highlight-color的alpha值为0去除部分机器自带的效果 a,button,input,textarea{ -webkit-tap-highlight-color: rgba(0,0,0,0;) -webkit-user-modify:read-write-plaintext-only; } -webkit-user-modify有个副作用，就是输入法不再能够输入多个字符 另外，有些机型去除不了，如小米2 对于按钮类还有个办法，不使用a或者input标签，直接用div标签 参考《如何去除android上a标签产生的边框》 winphone系统a、input标签被点击时产生的半透明灰色背景怎么去掉 &lt;meta name="msapplication-tap-highlight" content="no"&gt; webkit表单元素的默认外观怎么重置 .css{-webkit-appearance:none;} webkit表单输入框placeholder的颜色值能改变么 input::-webkit-input-placeholder{color:#AAAAAA;} input:focus::-webkit-input-placeholder{color:#EEEEEE;} webkit表单输入框placeholder的文字能换行么 ios可以，android不行~ 在textarea标签下都可以换行~ IE10（winphone8）表单元素默认外观如何重置 禁用&nbsp;select&nbsp;默认下拉箭头 ::-ms-expand&nbsp;适用于表单选择控件下拉箭头的修改，有多个属性值，设置它隐藏&nbsp;(display:none)&nbsp;并使用背景图片来修饰可得到我们想要的效果。 select::-ms-expand { display: none; } 禁用&nbsp;radio&nbsp;和&nbsp;checkbox&nbsp;默认样式 ::-ms-check&nbsp;适用于表单复选框或单选按钮默认图标的修改，同样有多个属性值，设置它隐藏&nbsp;(display:none)&nbsp;并使用背景图片来修饰可得到我们想要的效果。 input[type=radio]::-ms-check,input[type=checkbox]::-ms-check{ display: none; } 禁用PC端表单输入框默认清除按钮 当表单文本输入框输入内容后会显示文本清除按钮，::-ms-clear&nbsp;适用于该清除按钮的修改，同样设置使它隐藏&nbsp;(display:none)&nbsp;并使用背景图片来修饰可得到我们想要的效果。 input[type=text]::-ms-clear,input[type=tel]::-ms-clear,input[type=number]::-ms-clear{ display: none; } 禁止ios 长按时不触发系统的菜单，禁止ios&amp;android长按时下载图片 .css{-webkit-touch-callout: none} 禁止ios和android用户选中文字 .css{-webkit-user-select:none} 参考《如何改变表单元素的外观(for Webkit and IE10)》 打电话发短信写邮件怎么实现 打电话 &lt;a href="tel:0755-10086"&gt;打电话给:0755-10086&lt;/a&gt; 发短信，winphone系统无效 &lt;a href="sms:10086"&gt;发短信给: 10086&lt;/a&gt; 写邮件，可参考《移动web页面给用户发送邮件的方法》 &lt;a href="mailto:peun@foxmail.com"&gt;peun@foxmail.com&lt;/a&gt; 模拟按钮hover效果 移动端触摸按钮的效果，可明示用户有些事情正要发生，是一个比较好体验，但是移动设备中并没有鼠标指针，使用css的hover并不能满足我们的需求，还好国外有个激活css的active效果，代码如下， &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" name="viewport"&gt; &lt;meta content="yes" name="apple-mobile-web-app-capable"&gt; &lt;meta content="black" name="apple-mobile-web-app-status-bar-style"&gt; &lt;meta content="telephone=no" name="format-detection"&gt; &lt;meta content="email=no" name="format-detection"&gt; &lt;style type="text/css"&gt; a{-webkit-tap-highlight-color: rgba(0,0,0,0);} .btn-blue{display:block;height:42px;line-height:42px;text-align:center;border-radius:4px;font-size:18px;color:#FFFFFF;background-color: #4185F3;} .btn-blue:active{background-color: #357AE8;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="btn-blue"&gt;按钮&lt;/div&gt; &lt;script type="text/javascript"&gt; document.addEventListener("touchstart", function(){}, true) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 兼容性ios5+、部分android 4+、winphone 8 要做到全兼容的办法，可通过绑定ontouchstart和ontouchend来控制按钮的类名 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" name="viewport"&gt; &lt;meta content="yes" name="apple-mobile-web-app-capable"&gt; &lt;meta content="black" name="apple-mobile-web-app-status-bar-style"&gt; &lt;meta content="telephone=no" name="format-detection"&gt; &lt;meta content="email=no" name="format-detection"&gt; &lt;style type="text/css"&gt; a{-webkit-tap-highlight-color: rgba(0,0,0,0);} .btn-blue{display:block;height:42px;line-height:42px;text-align:center;border-radius:4px;font-size:18px;color:#FFFFFF;background-color: #4185F3;} .btn-blue-on{background-color: #357AE8;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="btn-blue"&gt;按钮&lt;/div&gt; &lt;script type="text/javascript"&gt; var btnBlue = document.querySelector(".btn-blue"); btnBlue.ontouchstart = function(){this.className = "btn-blue btn-blue-on" } btnBlue.ontouchend = function(){this.className = "btn-blue" } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 屏幕旋转的事件和样式 事件 window.orientation，取值：正负90表示横屏模式、0和180表现为竖屏模式； window.onorientationchange = function(){ switch(window.orientation){ case -90: case 90: alert("横屏:" + window.orientation); case 0: case 180: alert("竖屏:" + window.orientation); break; } } 样式 //竖屏时使用的样式 @media all and (orientation:portrait) { .css{} } //横屏时使用的样式 @media all and (orientation:landscape) { .css{} } audio元素和video元素在ios和andriod中无法自动播放 应对方案：触屏即播 $('html').one('touchstart',function(){audio.play() }) 可参考《无法自动播放的audio元素》 摇一摇功能 HTML5 deviceMotion：封装了运动传感器数据的事件，可以获取手机运动状态下的运动加速度等数据。 var SHAKE_THRESHOLD = 2000; var last_update = 0; var x = y = z = last_x = last_y = last_z = 0; function init() { if (window.DeviceMotionEvent) { window.addEventListener('devicemotion', deviceMotionHandler, false); } else { alert('not support mobile event'); } } function deviceMotionHandler(eventData) { var acceleration = eventData.accelerationIncludingGravity; var curTime = new Date().getTime(); if ((curTime - last_update) &gt; 100) { var diffTime = curTime - last_update; last_update = curTime; x = acceleration.x; y = acceleration.y; z = acceleration.z; var speed = Math.abs(x + y + z - last_x - last_y - last_z) / diffTime * 10000; if (speed &gt; SHAKE_THRESHOLD) { //alert("摇动了"+SHAKE_THRESHOLD); } last_x = x; last_y = y; last_z = z; } } &nbsp; 手机拍照和上传图片 &lt;input type=&quot;file&quot;&gt;的accept 属性 &lt;!-- 选择照片 --&gt; &lt;input type=file accept="image/*"&gt; &lt;!-- 选择视频 --&gt; &lt;input type=file accept="video/*"&gt; 使用总结： ios 有拍照、录像、选取本地图片功能 部分android只有选取本地图片功能 winphone不支持 input控件默认外观丑陋 微信浏览器用户调整字体大小后页面矬了，怎么阻止用户调整 原因 android侧是复写了layoutinflater 对textview做了统一处理 ios侧是修改了body.style.webkitTextSizeAdjust值 解决方案： android使用以下代码，该接口只在微信浏览器下有效(感谢jationhuang同学提供) /** * 页面加入这段代码可使Android机器页面不再受到用户字体缩放强制改变大小 * 但是会有一个1秒左右的延迟，期间可以考虑通过loading展示 * 仅供参考 */ (function(){ if (typeof(WeixinJSBridge) == "undefined") { document.addEventListener("WeixinJSBridgeReady", function (e) { setTimeout(function(){ WeixinJSBridge.invoke('setFontSizeCallback',{"fontSize":0}, function(res) { alert(JSON.stringify(res)); }); },0); }); } else { setTimeout(function(){ WeixinJSBridge.invoke('setFontSizeCallback',{"fontSize":0}, function(res) { alert(JSON.stringify(res)); }); },0); } })(); &nbsp; ios使用-webkit-text-size-adjust禁止调整字体大小 body{-webkit-text-size-adjust: 100%!important;} 最好的解决方案： 整个页面用rem或者百分比布局 消除transition闪屏 网络都是这么写的，但我并没有测试出来 .css{ /*设置内嵌的元素在 3D 空间如何呈现：保留 3D*/ -webkit-transform-style: preserve-3d; /*（设置进行转换的元素的背面在面对用户时是否可见：隐藏）*/ -webkit-backface-visibility: hidden; } 开启硬件加速 解决页面闪白 保证动画流畅 .css { -webkit-transform: translate3d(0, 0, 0); -moz-transform: translate3d(0, 0, 0); -ms-transform: translate3d(0, 0, 0); transform: translate3d(0, 0, 0); } 参考《用CSS开启硬件加速来提高网站性能》 取消input在ios下，输入的时候英文首字母的默认大写 &lt;input autocapitalize="off" autocorrect="off" /&gt; android 上去掉语音输入按钮 input::-webkit-input-speech-button {display: none} android 2.3 bug @-webkit-keyframes 需要以0%开始100%结束，0%的百分号不能去掉 after和before伪类无法使用动画animation border-radius不支持%单位 translate百分比的写法和scale在一起会导致失效，例如-webkit-transform: translate(-50%,-50%) scale(-0.5, 1) android 4.x bug 三星 Galaxy S4中自带浏览器不支持border-radius缩写 同时设置border-radius和背景色的时候，背景色会溢出到圆角以外部分 部分手机(如三星)，a链接支持鼠标:visited事件，也就是说链接访问后文字变为紫色 android无法同时播放多音频audio 参考《border-radius 移动之伤》 设计高性能CSS3动画的几个要素 尽可能地使用合成属性transform和opacity来设计CSS3动画，不使用position的left和top来定位 利用translate3D开启GPU加速 参考《High Performance Animations》 fixed bug ios下fixed元素容易定位出错，软键盘弹出时，影响fixed元素定位 android下fixed表现要比iOS更好，软键盘弹出时，不会影响fixed元素定位 ios4下不支持position:fixed 解决方案 可用isroll.js，暂无完美方案 参考 《移动端web页面使用position:fixed问题总结》 《使用iScroll.js解决ios4下不支持position:fixed的问题》 &nbsp;如何阻止windows Phone的默认触摸事件 winphone下默认触摸事件事件使用e.preventDefault是无效的 目前解决方法是使用样式来禁用 html{-ms-touch-action: none;}/* 禁止winphone默认触摸事件 */ 参考 《Windows phone 8 touch support》 播放视频不全屏 &lt;!-- 1.目前只有ios7+、winphone8+支持自动播放 2.支持Airplay的设备（如：音箱、Apple TV)播放 x-webkit-airplay="true" 3.播放视频不全屏，ios7+、winphone8+支持，部分android4+支持（含华为、小米、魅族） webkit-playsinline="true" --&gt; &lt;video x-webkit-airplay="true" webkit-playsinline="true" preload="auto" autoplay src="http://"&gt;&lt;/video&gt; 体验demo：http://1.peunzhang.sinaapp.com/demo/video/index.html 常用的移动端框架 zepto.js 语法与jquery几乎一样，会jquery基本会zepto~ 最新版本已经更新到1.16 官网：http://zeptojs.com/ 中文(非官网)：http://www.css88.com/doc/zeptojs_api/ 常使用的扩展模块： 浏览器检测：https://github.com/madrobby/zepto/blob/master/src/detect.js tap事件：https://github.com/madrobby/zepto/blob/master/src/touch.js iscroll.js 解决页面不支持弹性滚动，不支持fixed引起的问题~ 实现下拉刷新，滑屏，缩放等功能~ 最新版本已经更新到5.0 官网：http://cubiq.org/iscroll-5 underscore.js 笔者没用过，不过听说好用，推荐给大家~ 该库提供了一整套函数式编程的实用功能，但是没有扩展任何JavaScript内置对象。 最新版本已经更新到1.8.2 官网：http://underscorejs.org/ 滑屏框架 适合上下滑屏、左右滑屏等滑屏切换页面的效果 slip.js iSlider.js fullpage.js swiper.js flex布局 使用注意： flex下的子元素必须为块级元素，非块级元素在android2.3机器下flex失效 flex下的子元素宽度和高度不能超过父元素，否则会导致子元素定位错误，例如水平垂直居中 FastClick 消除在移动浏览器上触发click事件与一个物理Tap(敲击)之间的300延迟 参考《FastClick》 Sea.js&nbsp; 提供简单、极致的模块化开发体验 简单友好的模块定义规范：Sea.js 遵循&nbsp;CMD&nbsp;规范，可以像&nbsp;Node.js&nbsp;一般书写模块代码。 自然直观的代码组织方式：依赖的自动加载、配置的简洁清晰，可以让我们更多地享受编码的乐趣。 地址：http://seajs.org/docs/ &nbsp;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[排序算法整理]]></title>
      <url>%2F2017%2F04%2F08%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%2F</url>
      <content type="text"><![CDATA[插入排序插入排序的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增1的有序表排序过程大概如下：从第一个元素开始，该元素可以认为已经被排序；取出下一个元素，在已经排序的元素序列中从后向前扫描；如果该元素（已排序）大于新元素，将该元素移到下一位置；重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；将新元素插入到该位置后；重复步骤2~5。 /** * 插入排序算法 * @param {Array} arr 需要排序的数组 * @return {Array} 从小到大排序好的数组 */ function insertSort(arr){ var len = arr.length; for (var i = 1; i &lt; len; i++) { var key = arr[i]; var j = i - 1; while (j &gt;= 0 &amp;&amp; arr[j] &gt; key) { arr[j + 1] = arr[j]; j--; } arr[j + 1] = key; } return arr; } 算法分析 最佳情况：输入数组按升序排列。T(n) = O(n)最坏情况：输入数组按降序排列。T(n) = O(n2)平均情况：T(n) = O(n2) 二分插入排序从第一个元素开始，该元素可以认为已经被排序；取出下一个元素，在已经排序的元素序列中二分查找到第一个比它大的数的位置；将新元素插入到该位置后；重复上述两步 /** * 二分法插入排序 * @param {array} arr 需要排序的数组 * @return {array} 排序后悔的数组 */ function binaryInsertSort(arr){ for (var i = 1; i &lt; arr.length; i++) { var key = arr[i], left = 0, right = i - 1; while (left &lt;= right) { var middle = parseInt((left + right) / 2); if (key &lt; arr[middle]) { right = middle - 1; } else { left = middle + 1; } } for (var j = i - 1; j &gt;= left; j--) { arr[j + 1] = arr[j]; } arr[left] = key; } return arr; } 算法分析 最佳情况：T(n) = O(nlogn)最差情况：T(n) = O(n2)平均情况：T(n) = O(n2) 选择排序选择排序就是通过n-i次关键字间的比较，从n-i-1个记录中选出关键字最小的记录，并和第i个记录进行交换。选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。1234567891011121314function selectSort(arr)&#123; for(var i = 0; i &lt; arr.length - 1; i++)&#123; var min = arr[i]; for(var j = i + 1; j &lt; arr.length - 1; j++)&#123; if(min &gt; arr[j])&#123; var temp = min; min = arr[j]; arr[j] = temp; &#125; &#125; arr[i] = min; &#125; return arr; &#125; 算法分析 最佳情况：T(n) = O(n2)最差情况：T(n) = O(n2)平均情况：T(n) = O(n2) 冒泡排序冒泡排序是一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 function bubbleSort(arr) { var len = arr.length; for (var i = 0; i &lt; len - 1; i++) { var n = 0; for (var j = 0; j &lt; len - i ; j++) { if(arr[j] &lt; arr[j-1]){ n++; console.log(n); var temp = arr[j]; arr[j] = arr[j-1]; arr[j-1] = temp; } } if( n &lt; 1){ break; } } return arr; } 最佳情况：T(n) = O(n)最差情况：T(n) = O(n2)平均情况：T(n) = O(n2) 快速排序（1）在数据集之中，选择一个元素作为”基准”（pivot）。（2）所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。（3）对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。 function quickSort(arr){ if (arr.length &lt;= 1){return arr}; var pivotIndex = Math.floor(arr.length / 2); var pivot = arr.splice(pivotIndex,1)[0]; var left = []; var right = []; for (var i = 0; i &lt; arr.length; i++){ if(arr[i] &lt; pivot) { left.push(arr[i]); }else{ right.push(arr[i]); } } return quickSort(left).concat([pivot],quickSort(right)); } 算法分析 最佳情况：T(n) = O(nlogn)最差情况：T(n) = O(n2)平均情况：T(n) = O(nlogn) 希尔排序希尔排序的实质是分组插入排序，该方法又称缩小增量排序。该方法的基本思想是：先将整个待排元素序列分割为若干个子序列（由相隔某个‘增量’的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，带这个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。因为直接插入排序在元素基本有序的情况下（接近最好情况）效率是很高的，因此希尔排序在时间效率上有较大的提高。希尔排序算法实现 function shallSort(array) { var increment = array.length; var i var temp; //暂存 var count = 0; do { //设置增量 increment = Math.floor(increment / 3) + 1; for (i = increment ; i &lt; array.length; i++) { console.log(increment); if (array[i] &lt; array[i - increment]) { temp = array[i]; for (var j = i - increment; j &gt;= 0 &amp;&amp; temp &lt; array[j]; j -= increment) { array[j + increment] = array[j]; } array[j + increment] = temp; } } } while (increment &gt; 1) return array; }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[借助nodejs探究websocket]]></title>
      <url>%2F2017%2F04%2F08%2F%E5%80%9F%E5%8A%A9nodejs%E6%8E%A2%E7%A9%B6websocket%2F</url>
      <content type="text"><![CDATA[文章导读： 一、概述-what’s WebSocket? 二、运行在浏览器中的WebSocket客户端+使用ws模块搭建的简单服务器 三、Node中的WebSocket 四、socket.io 五、扩展阅读一、概述-what’s WebSocket? 1.1 为什么我们需要WebSocket这样的实时的通信协议？WebSocket是web通信方式的一种，像我们熟知的HTTP协议也是web通信方式的一种。但是我们知道HTTP协议是一种无状态的协议，其服务端本身不具备识别客户端的能力，必须借助外部的一些信息比如说session和cookie，才能与特定的客户端保持通信。也就是说我们所发送的每一个HTTP的请求都会带上请求头中一些相应的信息还有cookie，这明显会增加我们传输的信息的体量从而带来一定的网络延迟，对于一些对通信的实时性要求比较高的应用来说就是不可忍受的了，比如说聊天程序或者是运行在浏览器中的实时小游戏。最郁闷的却还是这些头信息和cookie往往对于服务器响应客户端的请求来说是多余的，也就是说虽然我每个请求都带了这些信息，但是服务器与客户端的交互过程中可能根本用不上这些信息。 为了改善HTTP请求的这种网络延迟的情况，也出现了一些适应不同需求的其他的[web通信]方式，比如说：轮询，长轮询( long-polling )，数据流，EventSouce等等，WebSocket便是其中一种。 实际上大多数基于因特网（或者局域网）的网络链接通常都包含长连接和基于TCP套接字的双向消息交换。但是TCP协议是属于最底层的网络通信协议了，让一些不能信任的客户端脚本去访问底层的TCP套接字显然是不太安全的，因此WebSocket实现了一种较为安全的方案，它允许客户端脚本在客户端和支持WebSocket协议的服务器之间创建双向的套接字连接。从而使实时通信的某些网络操作变得简单。 1.2 WebSocket是如何工作的？我们知道了WebSocket的主要作用是，允许服务器端与客户端进行全双工（full-duplex）的实时通信。这里有个例子特别好：HTTP协议像发电子邮件，发出后必须等待对方回信；WebSocket则是像打电话，服务器端和客户端可以同时向对方发送数据，它们之间存着一条持续打开的数据通道。 我们先看一下一个基于WebSocket协议通信的请求头和响应头(下面简单实例中的一个消息头)： 其中与WebSocket协议相关的信息： 1 Upgrade:websocket——-HTTP1.1协议规定，Upgrade头信息表示将通信协议从HTTP/1.1转向该项所指定的协议； 2 Connection:Upgrade——表示浏览器通知服务器，如果允许，就将通信协议升级到websocket协议； 3 Origin——————用于验证浏览器域名是否在服务器许可的范围内; 4 Sec-WebSocket-Key——-则是用于握手协议的密钥，是base64编码的16字节随机字符串; 5 Sec-WebSocket-Accept—-是服务器在浏览器提供的Sec-WebSocket-Key字符串后面，添加“258EAFA5-E914-47DA-95CA-C5AB0DC85B11” 字符串，然后再取sha-1的hash值。浏览器将对这个值进行验证，以证明确实是目标服务器回应了webSocket请求； 6.Sec-WebSocket-Location–一般情况下还有这个响应消息头用来表示进行通信的WebSocket网址，这里面可能是因为我例子中设置了127.0.0.1，所以这个信息省略掉了。客户端通过一个WebSocket握手的过程建立一个WebSocket连接。整个过程看起来是这个样子的： 完成握手以后，WebSocket协议就在TCP协议之上，客户端和服务器端就可以开始传送数据了。 websocket协议用ws表示，加密的websocket协议用wss协议，就像普通的HTTP协议用http表示，加密的HTTP协议用https表示一样。 下面我们就通过一些实例看一下websocket的不同实现是如何应用的。 二、 运行在浏览器中的WebSocket客户端+使用ws模块搭建的简单服务器我们可以通过跑起来这个简单的实例看一下如何编写运行在浏览器中的WebSocket客户端，并且看它是怎样与服务器端交互的。 2.1 运行实例我们把客户端代码和服务端代码准备好，然后启动服务器监听端口，比如说8080，再然后运行我们的客户端代码即可看到效果。 我们的客户端代码写在html文件中： 12345678910111213141516171819202122232425261 var onOpen = function() &#123;2 console.log(&quot;Socket opened.&quot;);3 socket.send(&quot;Hi, Server!&quot;);4 &#125;,5 onClose = function() &#123;6 console.log(&quot;Socket closed.&quot;);7 &#125;,8910 onMessage = function(data) &#123;11 console.log(&quot;We get signal:&quot;);12 console.log(data);13 &#125;,141516 onError = function() &#123;17 console.log(&quot;We got an error.&quot;);18 &#125;,1920 21 socket = new WebSocket(&quot;ws://127.0.0.1:8080/&quot;);2223 socket.onopen = onOpen;24 socket.onclose = onClose;25 socket.onerror = onError;26 socket.onmessage = onMessage; 我们通过它建立连接并且监听open和messege等事件，与此同时，我们想要得到服务器的响应。服务器端的js代码： 123456789101 var WebSocketServer = require(&apos;ws&apos;).Server; 2 var wss = new WebSocketServer(&#123; port: 8080 &#125;); 3 4 wss.on(&apos;connection&apos;, function connection(ws) &#123; 5 ws.on(&apos;message&apos;, function incoming(message) &#123; 6 console.log(&apos;received: %s&apos;, message); 7 &#125;); 8 9 ws.send(&apos;something&apos;);10 &#125;); 这个简单的websocket服务器使用了[ ws模块 ]，如果没有安装过，要先安装一下： 1 sudo npm install ws然后在我们的命令行执行： 1 node simpleWSserver.js我们的服务器启动之后，我们运行客户端代码可以看到： 浏览器： 命令行： 整个过程看起来是这个样子的： 2.2 运行在浏览器中的websocket客户端 我们在浏览器中的websocket主要做的事情无非是以下几个： 1 建立连接和关闭连接2 发送数据和接收数据3 处理错误对应的会触发以下的事件： 1onopen2onmessage3onclose4onerror2.2.1 建立连接和关闭连接 通常我们新建了一个WebSocket的实例就可以建立一个连接：1231 if(window.WebSocket != undefined) &#123;2 var socket = new WebSocket(&quot;ws://127.0.0.1:8080/&quot;);3 &#125; 建立连接之后的WebSocket实例有一个readyState属性，用来标识当前的状态： 0-正在连接1-连接成功2-正在关闭3-关闭成功连接成功后会触发onopen事件，这时我们就可以向服务器发送数据了：123451 var onOpen = function() &#123;2 console.log(&quot;Socket opened.&quot;);3 socket.send(&quot;Hi, Server!&quot;);4 &#125;5 socket.onopen = onOpen; 要是关闭连接的话就会出发onclose事件：12341 var onClose = function() &#123;2 console.log(&quot;Socket closed.&quot;);3 &#125;4 socket.onclose = onClose; 2.2.2 发送数据和接收数据 在连接建立成功后触发的onopen事件中我们通过send()方法发送数据给服务器： 1 socket.send(&quot;Hi, Server!&quot;);除了发送字符串类型的数据，也可以使用 Blob 或 ArrayBuffer 对象发送二进制数据。不仅如此，我们还可以发送JSON数据：1234567891011121 var onOpen = function() &#123; 2 var msg = &#123; 3 type: &quot;message&quot;, 4 text: &quot;something&quot;, 5 id: &quot;number&quot;, 6 date: Date.now() 7 &#125;; 8 9 // Send the msg object as a JSON-formatted string.10 socket.send(JSON.stringify(msg));11 &#125;12 socket.onopen = onOpen; 这时会触发服务器端的message事件：1231 ws.on(&apos;message&apos;, function incoming(message) &#123;2 console.log(&apos;received: %s&apos;, message);3 &#125;); 同时，服务器端发来信息的时候： 1 ws.send(&#39;something&#39;);也会触发客户端的onmessage事件：123451 var onMessage = function(data) &#123;2 console.log(&quot;We get signal:&quot;);3 console.log(data);4 &#125;5 socket.onmessage = onMessage; 2.2.3 处理错误 发生的错误会触发onerror事件：12341 var onError = function() &#123;2 console.log(&quot;We got an error.&quot;);3 &#125;4 socket.onerror = onError; 三、Node中的WebSocket WebSocket在Node中的实现[ WebSocket-Node ]使我们可以在Nodejs中使用websokcet开发客户端和服务器端实时交互的应用程序。我们可以运行客户端和服务器实时交换随机数的例子看看它是怎么工作的：node socketserver.js node socketclient.js 四、socket.io现在很流行的websocket的实现socket.io同样包括客户端和服务器端两部分。它不仅简化了接口，使得操作更容易，而且对于那些不支持WebSocket的浏览器，会自动降为Ajax连接，最大限度地保证了兼容性。它的目标是统一通信机制，使得所有浏览器和移动设备都可以进行实时通信。 4.1 socket.io与WebSocket的区别在哪里呢？websocket是浏览器对象，websocket api是浏览器提供给我们的用于浏览器和服务器实时通信的接口。 websocket在node中的实现使我们可以开发服务端程序时使用websocket的特性。 在我们使用websocket的时候，因为他是浏览器提供的接口，所以会涉及到一些兼容性和支持性的问题。如果我们对程序所运行的环境或局限不是那么了解的化，那么可能会出现问题： [ Differences between socket.io and websocket ] 。而socket.io则是进化了的websocket api。socket.io建立在websocket之上，它在合适的时候使用websocket。 4.2 socket.io实现聊天室 使用websocket或socket.io可以从一个简单的聊天室程序开始。对于socket.io来说，这非常容易。 基于 node ，这里使用express和socket.io： 1 npm install --save express@4.10.22 npm install --save socket.io那么我们就可以开始写聊天程序了。它需要的就是一个客户端的聊天窗口和一个用来接收消息和分发消息的服务器。 我们需要三个文件，分别新建：package.json,index.js,index.html. package.json: 1234567891 &#123;2 &quot;name&quot;: &quot;chat-application&quot;,3 &quot;version&quot;: &quot;0.0.1&quot;,4 &quot;description&quot;: &quot;my first socket.io app&quot;,5 &quot;dependencies&quot;: &#123;6 &quot;socket.io&quot;: &quot;^1.3.5&quot;7 &#125;8 &#125; index.js: 12345678910111213141516171819202122231 var app = require(&apos;express&apos;)(); 2 var http = require(&apos;http&apos;).Server(app); 3 var io = require(&apos;socket.io&apos;)(http); 4 5 app.get(&apos;/&apos;, function(req, res)&#123; 6 res.sendfile(&apos;index.html&apos;); 7 &#125;); 8 9 io.on(&apos;connection&apos;, function(socket)&#123;10 console.log(&apos;a user connected&apos;);11 //监听客户端的消息12 socket.on(&apos;chat message&apos;, function(msg)&#123;13 //用于将消息发送给每个人，包括发送者14 io.emit(&apos;chat message&apos;, msg);15 &#125;);16 socket.on(&apos;disconnect&apos;, function()&#123;17 console.log(&apos;user disconnected&apos;);18 &#125;);19 &#125;);2021 http.listen(3000, function()&#123;22 console.log(&apos;listening on *:3000&apos;);23 &#125;); index.html: 1234567891011121314151617181920212223242526272829303132333435361 &lt;!doctype html&gt; 2 &lt;html&gt; 3 &lt;head&gt; 4 &lt;title&gt;Socket.IO chat&lt;/title&gt; 5 &lt;style&gt; 6 * &#123; margin: 0; padding: 0; box-sizing: border-box; &#125; 7 body &#123; font: 13px Helvetica, Arial; &#125; 8 form &#123; background: #000; padding: 3px; position: fixed; bottom: 0; width: 100%; &#125; 9 form input &#123; border: 0; padding: 10px; width: 90%; margin-right: .5%; &#125;10 form button &#123; width: 9%; background: rgb(130, 224, 255); border: none; padding: 10px; &#125;11 #messages &#123; list-style-type: none; margin: 0; padding: 0; &#125;12 #messages li &#123; padding: 5px 10px; &#125;13 #messages li:nth-child(odd) &#123; background: #eee; &#125;14 &lt;/style&gt;15 &lt;/head&gt;16 &lt;body&gt;17 &lt;ul id=&quot;messages&quot;&gt;&lt;/ul&gt;18 &lt;form action=&quot;&quot;&gt;19 &lt;input id=&quot;m&quot; autocomplete=&quot;off&quot; /&gt;&lt;button&gt;Send&lt;/button&gt;20 &lt;/form&gt;21 &lt;script src=&quot;https://cdn.socket.io/socket.io-1.2.0.js&quot;&gt;&lt;/script&gt;22 &lt;script src=&quot;http://code.jquery.com/jquery-1.11.1.js&quot;&gt;&lt;/script&gt;23 &lt;script&gt;24 var socket = io();25 $(&apos;form&apos;).submit(function()&#123;26 //io.emit提供给我们可以发送给所有人的事件io.emit(&apos;some event&apos;, &#123; for: &apos;everyone&apos; &#125;);27 socket.emit(&apos;chat message&apos;, $(&apos;#m&apos;).val());28 $(&apos;#m&apos;).val(&apos;&apos;);29 return false;30 &#125;);31 socket.on(&apos;chat message&apos;, function(msg)&#123;32 $(&apos;#messages&apos;).append($(&apos;&lt;li&gt;&apos;).text(msg));33 &#125;);34 &lt;/script&gt;35 &lt;/body&gt;36 &lt;/html&gt; 先运行： node index.js在打开两个http://localhost:3000的窗口就可以开始聊天了： socket.io官网上有很详细的使用方法和教程：[ socket.io doc ] 五、扩展阅读 [ 浏览器对象-WebSocket ] [web通信] [细说WebSocket] [ WebSocket MDN ] [ WebSocket-Node implementation ] [ A Guide For WebSocket ] [ socket.IO ] [ writing websocket client ] [ deferences between socket.io and websocket ] [ websocket and socketio ] [ socket.io application ]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[nodejs模版引擎]]></title>
      <url>%2F2017%2F04%2F08%2Fnodejs%E6%A8%A1%E7%89%88%E5%BC%95%E6%93%8E%2F</url>
      <content type="text"><![CDATA[1.ejs （写法有点类jsp／php)Node 开源模板的选择很多，但推荐像我这样的老人去用 EJS，有 Classic ASP/PHP/JSP 的经验用起 EJS 来的确可以很自然，也就是说，你能够在 &lt;%…%&gt; 块中安排 JavaScript 代码，利用最传统的方式 &lt;%=输出变量%&gt;（另外 &lt;%-输出变量是不会对 &amp; 等符号进行转义的）1234567&lt;% if (names.length) &#123; %&gt; &lt;ul&gt; &lt;% names.forEach(function(name)&#123; %&gt; &lt;li foo=&apos;&lt;%= name + &quot;&apos;&quot; %&gt;&apos;&gt;&lt;%= name %&gt;&lt;/li&gt; &lt;% &#125;) %&gt; &lt;/ul&gt; &lt;% &#125; %&gt; 2. jadejade全新的Jade有两点是超出传统模板技术的。 第一、简洁。注意，简洁并非单指更少的符号，而是看是否能match你的需要。Jade强制的缩进格式能凸显html的结构，而对于前端来说，最重要的任务恰恰是处理结构，而不像一般的html author那样是处理内容。反过来说，假如你的主要任务是处理内容，比如写作blog之类的，那你应该用wiki或者markdown之类的，而不应该用Jade。 第二、html-aware传统模板技术其实是通用模板，即模板引擎并不care你输出的是html还是其他格式的文本。而Jade专为HTML设计，因此可以做许多传统模板做不到的专门针对html的优化。举个几个简单的例子： 决定如何输出属性（当属性赋值为null/false时不输出属性，为true时只需属性不需要值，这在传统模板里写起来很麻烦、代码难看易出错） 自动产生well-formed结构（甚至可决定是否要输出结束标签，而传统模板理论上也做不到这点，除非引入额外的html parse或tidy） 换行处理，避免产生额外的空白节点 对输出的变量自动进行特殊字符的encode123456789101112!!!html head title #&#123;title&#125; meta(charset=&quot;UTF-8&quot;) body div.description #&#123;description&#125; ul - each data in datas li.item(id=&apos;item_&apos;+data.index) span= data.time a.art(href=data.url)= data.title 3.handlebars123456789101112131415&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&#123;&#123;title&#125;&#125; - Page Test&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;description&quot;&gt;&#123;&#123;description&#125;&#125;&lt;/div&gt; &lt;ul&gt;&#123;&#123;#datas&#125;&#125; &lt;li class=&quot;item&quot; id=&quot;item_&#123;&#123;index&#125;&#125;&quot;&gt;&lt;span&gt;&#123;&#123;time&#125;&#125;&lt;/span&gt;&lt;a href=&quot;&#123;&#123;url&#125;&#125;&quot; class=&quot;art&quot;&gt;&#123;&#123;title&#125;&#125;&lt;/a&gt;&lt;/li&gt;&#123;&#123;/datas&#125;&#125; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 总结：Jade 很简洁，表达能力也很强，但不够直观，学习和适应成本不低。Jade 处理模板时计算量大，在没有缓存的情况下性能低是肯定的。Jade 对于一个不擅长前端、喜欢Bootstrap和Ctrl c + v 实在不能提高开发效， 性能瓶颈 Ejs 适用于写JSP/PHP后台的人使用，上手快 Handlebars 更接近前端的模版引擎，使用方便顺手]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac命令大全]]></title>
      <url>%2F2017%2F04%2F07%2FMac%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8%2F</url>
      <content type="text"><![CDATA[1.目录操作 命令名 功能描述 使用举例 mkdir 创建一个目录 mkdir dirname rmdir 删除一个目录 rmdir dirname mvdir 移动或重命名一个目录 mvdir dir1 dir2 cd 改变当前目录 cd dirname pwd 显示当前目录的路径名 pwd ls 显示当前目录的内容 ls -la dircmp 比较两个目录的内容 dircmp dir1 dir2 2.文件操作 命令名 功能描述 使用举例 cat 显示或连接文件 cat filename pg 分页格式化显示文件内容 pg filename more 分屏显示文件内容 more filename od 显示非文本文件的内容 od -c filename cp 复制文件或目录 cp file1 file2 rm 删除文件或目录 rm filename mv 改变文件名或所在目录 mv file1 file2 ln 联接文件 ln -s file1 file2 find 使用匹配表达式查找文件 find . -name “*.c” -print file 显示文件类型 file filename open 使用默认的程序打开文件 open filename 3.选择操作 命令名 功能描述 使用举例 tail 显示文件的最后几行 tail -15 filename cut 显示文件每行中的某些域 cut -f1,7 -d: /etc/passwd colrm 从标准输入中删除若干列 colrm 8 20 file2 paste 横向连接文件 paste file1 file2 diff 比较并显示两个文件的差异 diff file1 file2 sed 非交互方式流编辑器 sed “s/red/green/g” filename grep 在文件中按模式查找 grep “^[a-zA-Z]” filename awk 在文件中查找并处理模式 awk ‘{print $1 $1}’ filename sort 排序或归并文件 sort -d -f -u file1 uniq 去掉文件中的重复行 uniq file1 file2 comm 显示两有序文件的公共和非公共行 comm file1 file2 wc 统计文件的字符数、词数和行数 wc filename nl 给文件加上行号 nl file1 &gt;file2 4.安全操作 命令名 功能描述 使用举例 passwd 修改用户密码 passwd chmod 改变文件或目录的权限 chmod ug+x filename umask 定义创建文件的权限掩码 umask 027 chown 改变文件或目录的属主 chown newowner filename chgrp 改变文件或目录的所属组 chgrp staff filename xlock 给终端上锁 xlock -remote 5.编程操作 命令名 功能描述 使用举例 make 维护可执行程序的最新版本 make touch 更新文件的访问和修改时间 touch -m 05202400 filename dbx 命令行界面调试工具 dbx a.out xde 图形用户界面调试工具 xde a.out 6.进程操作 命令名 功能描述 使用举例 ps 显示进程当前状态 ps u kill 终止进程 kill -9 30142 nice 改变待执行命令的优先级 nice cc -c *.c renice 改变已运行进程的优先级 renice +20 32768 7.时间操作 命令名 功能描述 使用举例 date 显示系统的当前日期和时间 date cal 显示日历 cal 8 1996 time 统计程序的执行时间 time a.out 8.网络与通信操作 命令名 功能描述 使用举例 telnet 远程登录 telnet hpc.sp.net.edu.cn rlogin 远程登录 rlogin hostname -l username rsh 在远程主机执行指定命令 rsh f01n03 date ftp 在本地主机与远程主机之间传输文件 ftp ftp.sp.net.edu.cn rcp 在本地主机与远程主机 之间复制文件 rcp file1 host1:file2 ping 给一个网络主机发送 回应请求 ping hpc.sp.net.edu.cn mail 阅读和发送电子邮件 mail write 给另一用户发送报文 write username pts/1 mesg 允许或拒绝接收报文 mesg n 9.Korn Shell 命令 命令名 功能描述 使用举例 history 列出最近执行过的 几条命令及编号 history r 重复执行最近执行过的 某条命令 r -2 alias 给某个命令定义别名 alias del=rm -i unalias 取消对某个别名的定义 unalias del 10.其它命令 命令名 功能描述 使用举例 uname 显示操作系统的有关信息 uname -a clear 清除屏幕或窗口内容 clear env 显示当前所有设置过的环境变量 env who 列出当前登录的所有用户 who whoami 显示当前正进行操作的用户名 whoami tty 显示终端或伪终端的名称 tty stty 显示或重置控制键定义 stty -a du 查询磁盘使用情况 du -k subdir df 显示文件系统的总空间和可用空间 df /tmp w 显示当前系统活动的总信息 w]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[gogs 自动化部署]]></title>
      <url>%2F2017%2F04%2F07%2Fgogs-%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%2F</url>
      <content type="text"><![CDATA[1.创建仓库 服务器上需要配置两个 git 仓库，一个用于代码版本管理的远程仓库，一个用于用户访问的本地仓库。这里的「远程仓库」并不等同于托管代码的「中央仓库」，这两个仓库都是为了自动同步代码并部署网站而存在。在存放远程仓库的目录中（假设是 /home/ourai/repos）执行 git init –bare bridge.git 会创建一个包含 git 各种配置文件的「裸仓库」。 切换到存放用户所访问文件的目录（假设为 /home/ourai/www，如果不存在则在 /home/ourai 中执行mkdir www）：1234git initgit remote add origin /root/gogs-repositories/seateam/wxoauth.gitgit fetchgit checkout master 2.配置 Git Hook将目录切换至 xx.git/hooks，用cp post-receive.sample post-receive 拷贝并 cd /root/gogs-repositories/seateam/xx.git/hooks 用vim post-receive 修改。其内容大致如下：123456789101112#!/bin/shunset GIT_DIRNowPath=`pwd`DeployPath=&quot;/alidata/www/wxoauth&quot;cd $DeployPathgit pull origin mastercd $NowPathexit 0 使用 chmod +x post-receive 改变一下权限后，服务器端的配置就基本完成了。 3.上线与测试分开1234567891011121314151617181920212223while read oldrev newrev refnamedo if [[ $refname =~ .*/deploy$ ]]; then #!/bin/sh unset GIT_DIR NowPath=&apos;pwd&apos; DeployPath=&quot;/alidata/deploy/wxci&quot; cd $DeployPath git pull origin deploy cd $NowPath exit 0 else #!/bin/sh unset GIT_DIR NowPath=&apos;pwd&apos; DeployPath=&quot;/alidata/www/wxci&quot; cd $DeployPath git pull origin master cd $NowPath exit 0 fidone 4.挂起进程cd /alidata/gogsnohup ./gogs web &amp; 守护进程git hook 钩子，监听操作自动下载资源＝自动部署]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[shell 命令大全]]></title>
      <url>%2F2017%2F04%2F07%2Fshell-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8%2F</url>
      <content type="text"><![CDATA[1.系统信息arch 显示机器的处理器架构(1)uname -m 显示机器的处理器架构(2)uname -r 显示正在使用的内核版本dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI)hdparm -i /dev/hda 罗列一个磁盘的架构特性hdparm -tT /dev/sda 在磁盘上执行测试性读取操作cat /proc/cpuinfo 显示CPU info的信息cat /proc/interrupts 显示中断cat /proc/meminfo 校验内存使用cat /proc/swaps 显示哪些swap被使用cat /proc/version 显示内核的版本cat /proc/net/dev 显示网络适配器及统计cat /proc/mounts 显示已加载的文件系统lspci -tv 罗列 PCI 设备lsusb -tv 显示 USB 设备date 显示系统日期cal 2007 显示2007年的日历表date 041217002007.00 设置日期和时间 - 月日时分年.秒clock -w 将时间修改保存到 BIOS 2.关机 (系统的关机、重启以及登出 )shutdown -h now 关闭系统(1)init 0 关闭系统(2)telinit 0 关闭系统(3)shutdown -h hours:minutes &amp; 按预定时间关闭系统shutdown -c 取消按预定时间关闭系统shutdown -r now 重启(1)reboot 重启(2)logout 注销 3.文件和目录cd /home 进入 ‘/ home’ 目录’cd .. 返回上一级目录cd ../.. 返回上两级目录cd 进入个人的主目录cd ~user1 进入个人的主目录cd - 返回上次所在的目录pwd 显示工作路径ls 查看目录中的文件ls -F 查看目录中的文件ls -l 显示文件和目录的详细资料ls -a 显示隐藏文件ls [0-9] 显示包含数字的文件名和目录名tree 显示文件和目录由根目录开始的树形结构(1)lstree 显示文件和目录由根目录开始的树形结构(2)mkdir dir1 创建一个叫做 ‘dir1’ 的目录’mkdir dir1 dir2 同时创建两个目录mkdir -p /tmp/dir1/dir2 创建一个目录树rm -f file1 删除一个叫做 ‘file1’ 的文件’rmdir dir1 删除一个叫做 ‘dir1’ 的目录’rm -rf dir1 删除一个叫做 ‘dir1’ 的目录并同时删除其内容rm -rf dir1 dir2 同时删除两个目录及它们的内容mv dir1 new_dir 重命名/移动 一个目录cp file1 file2 复制一个文件cp dir/ . 复制一个目录下的所有文件到当前工作目录cp -a /tmp/dir1 . 复制一个目录到当前工作目录cp -a dir1 dir2 复制一个目录ln -s file1 lnk1 创建一个指向文件或目录的软链接ln file1 lnk1 创建一个指向文件或目录的物理链接touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm)file file1 outputs the mime type of the file as texticonv -l 列出已知的编码iconv -f fromEncoding -t toEncoding inputFile &gt; outputFile creates a new from the given input file by assuming it is encoded in fromEncoding and converting it to toEncoding.find . -maxdepth 1 -name .jpg -print -exec convert “{}” -resize 80x60 “thumbs/{}” \; batch resize files in the current directory and send them to a thumbnails directory (requires convert from Imagemagick) 4.文件搜索find / -name file1 从 ‘/‘ 开始进入根文件系统搜索文件和目录find / -user user1 搜索属于用户 ‘user1’ 的文件和目录find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件find / -name *.rpm -exec chmod 755 ‘{}’ \; 搜索以 ‘.rpm’ 结尾的文件并定义其权限find / -xdev -name *.rpm 搜索以 ‘.rpm’ 结尾的文件，忽略光驱、捷盘等可移动设备locate *.ps 寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令whereis halt 显示一个二进制文件、源码或man的位置which halt 显示一个二进制文件或可执行文件的完整路径 5.挂载一个文件系统mount /dev/hda2 /mnt/hda2 挂载一个叫做hda2的盘 - 确定目录 ‘/ mnt/hda2’ 已经存在umount /dev/hda2 卸载一个叫做hda2的盘 - 先从挂载点 ‘/ mnt/hda2’ 退出fuser -km /mnt/hda2 当设备繁忙时强制卸载umount -n /mnt/hda2 运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用mount /dev/fd0 /mnt/floppy 挂载一个软盘mount /dev/cdrom /mnt/cdrom 挂载一个cdrom或dvdrommount /dev/hdc /mnt/cdrecorder 挂载一个cdrw或dvdrommount /dev/hdb /mnt/cdrecorder 挂载一个cdrw或dvdrommount -o loop file.iso /mnt/cdrom 挂载一个文件或ISO镜像文件mount -t vfat /dev/hda5 /mnt/hda5 挂载一个Windows FAT32文件系统mount /dev/sda1 /mnt/usbdisk 挂载一个usb 捷盘或闪存设备mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 挂载一个windows网络共享 6.磁盘空间df -h 显示已经挂载的分区列表ls -lSr |more 以尺寸大小排列文件和目录du -sh dir1 估算目录 ‘dir1’ 已经使用的磁盘空间’du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小rpm -q -a –qf ‘%10{SIZE}t%{NAME}n’ | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统)dpkg-query -W -f=’${Installed-Size;10}t${Package}n’ | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统) 返回顶部索引 ^ 7.用户和群组groupadd group_name 创建一个新用户组groupdel group_name 删除一个用户组groupmod -n new_group_name old_group_name 重命名一个用户组useradd -c “Name Surname “ -g admin -d /home/user1 -s /bin/bash user1 创建一个属于 “admin” 用户组的用户useradd user1 创建一个新用户userdel -r user1 删除一个用户 ( ‘-r’ 排除主目录)usermod -c “User FTP” -g system -d /ftp/user1 -s /bin/nologin user1 修改用户属性passwd 修改口令passwd user1 修改一个用户的口令 (只允许root执行)chage -E 2005-12-31 user1 设置用户口令的失效期限pwck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的用户grpck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的群组newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组 8.文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消ls -lh 显示权限ls /tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限chown user1 file1 改变一个文件的所有人属性chown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性chgrp group1 file1 改变文件的群组chown user1:group1 file1 改变一个文件的所有人和群组属性find / -perm -u+s 罗列一个系统中所有使用了SUID控制的文件chmod u+s /bin/file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限chmod u-s /bin/file1 禁用一个二进制文件的 SUID位chmod g+s /home/public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的chmod g-s /home/public 禁用一个目录的 SGID 位chmod o+t /home/public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件chmod o-t /home/public 禁用一个目录的 STIKY 位 9.文件的特殊属性 - 使用 “+” 设置权限，使用 “-“ 用于取消chattr +a file1 只允许以追加方式读写文件chattr +c file1 允许这个文件能被内核自动压缩/解压chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接chattr +s file1 允许一个文件被安全地删除chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件lsattr 显示特殊的属性 10.打包和压缩文件bunzip2 file1.bz2 解压一个叫做 ‘file1.bz2’的文件bzip2 file1 压缩一个叫做 ‘file1’ 的文件gunzip file1.gz 解压一个叫做 ‘file1.gz’的文件gzip file1 压缩一个叫做 ‘file1’的文件gzip -9 file1 最大程度压缩rar a file1.rar test_file 创建一个叫做 ‘file1.rar’ 的包rar a file1.rar file1 file2 dir1 同时压缩 ‘file1’, ‘file2’ 以及目录 ‘dir1’rar x file1.rar 解压rar包unrar x file1.rar 解压rar包tar -cvf archive.tar file1 创建一个非压缩的 tarballtar -cvf archive.tar file1 file2 dir1 创建一个包含了 ‘file1’, ‘file2’ 以及 ‘dir1’的档案文件tar -tf archive.tar 显示一个包中的内容tar -xvf archive.tar 释放一个包tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包tar -xvfj archive.tar.bz2 解压一个bzip2格式的压缩包tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包tar -xvfz archive.tar.gz 解压一个gzip格式的压缩包zip file1.zip file1 创建一个zip格式的压缩包zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包unzip file1.zip 解压一个zip格式压缩包 11.RPM 包 - （Fedora, Redhat及类似系统）rpm -ivh package.rpm 安装一个rpm包rpm -ivh –nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告rpm -U package.rpm 更新一个rpm包但不改变其配置文件rpm -F package.rpm 更新一个确定已经安装的rpm包rpm -e package_name.rpm 删除一个rpm包rpm -qa 显示系统中所有已经安装的rpm包rpm -qa | grep httpd 显示所有名称中包含 “httpd” 字样的rpm包rpm -qi package_name 获取一个已安装包的特殊信息rpm -qg “System Environment/Daemons” 显示一个组件的rpm包rpm -ql package_name 显示一个已经安装的rpm包提供的文件列表rpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表rpm -q package_name –whatrequires 显示与一个rpm包存在依赖关系的列表rpm -q package_name –whatprovides 显示一个rpm包所占的体积rpm -q package_name –scripts 显示在安装/删除期间所执行的脚本lrpm -q package_name –changelog 显示一个rpm包的修改历史rpm -qf /etc/httpd/conf/httpd.conf 确认所给的文件由哪个rpm包所提供rpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表rpm –import /media/cdrom/RPM-GPG-KEY 导入公钥数字证书rpm –checksig package.rpm 确认一个rpm包的完整性rpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性rpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间rpm -Va 检查系统中所有已安装的rpm包- 小心使用rpm -Vp package.rpm 确认一个rpm包还未安装rpm2cpio package.rpm | cpio –extract –make-directories bin 从一个rpm包运行可执行文件rpm -ivh /usr/src/redhat/RPMS/arch/package.rpm 从一个rpm源码安装一个构建好的包rpmbuild –rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包 12.YUM 软件包升级器 - （Fedora, RedHat及类似系统）yum install package_name 下载并安装一个rpm包yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系yum update package_name.rpm 更新当前系统中所有安装的rpm包yum update package_name 更新一个rpm包yum remove package_name 删除一个rpm包yum list 列出当前系统中安装的所有包yum search package_name 在rpm仓库中搜寻软件包yum clean packages 清理rpm缓存删除下载的包yum clean headers 删除所有头文件yum clean all 删除所有缓存的包和头文件 13.DEB 包 (Debian, Ubuntu 以及类似系统)dpkg -i package.deb 安装/更新一个 deb 包dpkg -r package_name 从系统删除一个 deb 包dpkg -l 显示系统中所有已经安装的 deb 包dpkg -l | grep httpd 显示所有名称中包含 “httpd” 字样的deb包dpkg -s package_name 获得已经安装在系统中一个特殊包的信息dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表dpkg –contents package.deb 显示尚未安装的一个包所提供的文件列表dpkg -S /bin/ping 确认所给的文件由哪个deb包提供 14.APT 软件工具 (Debian, Ubuntu 以及类似系统)apt-get install package_name 安装/更新一个 deb 包apt-cdrom install package_name 从光盘安装/更新一个 deb 包apt-get update 升级列表中的软件包apt-get upgrade 升级所有已安装的软件apt-get remove package_name 从系统删除一个deb包apt-get check 确认依赖的软件仓库正确apt-get clean 从下载的软件包中清理缓存apt-cache search searched-package 返回包含所要搜索字符串的软件包名称 15.查看文件内容cat file1 从第一个字节开始正向查看文件的内容tac file1 从最后一行开始反向查看一个文件的内容more file1 查看一个长文件的内容less file1 类似于 ‘more’ 命令，但是它允许在文件中和正向操作一样的反向操作head -2 file1 查看一个文件的前两行tail -2 file1 查看一个文件的最后两行tail -f /var/log/messages 实时查看被添加到一个文件中的内容 16.文本处理cat file1 file2 … | command &lt;&gt; file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUTcat file1 | command( sed, grep, awk, grep, etc…) &gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中cat file1 | command( sed, grep, awk, grep, etc…) &gt;&gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中grep Aug /var/log/messages 在文件 ‘/var/log/messages’中查找关键词”Aug”grep ^Aug /var/log/messages 在文件 ‘/var/log/messages’中查找以”Aug”开始的词汇grep [0-9] /var/log/messages 选择 ‘/var/log/messages’ 文件中所有包含数字的行grep Aug -R /var/log/ 在目录 ‘/var/log’ 及随后的目录中搜索字符串”Aug”sed ‘s/stringa1/stringa2/g’ example.txt 将example.txt文件中的 “string1” 替换成 “string2”sed ‘/^$/d’ example.txt 从example.txt文件中删除所有空白行sed ‘/ #/d; /^$/d’ example.txt 从example.txt文件中删除所有注释和空白行echo ‘esempio’ | tr ‘[:lower:]’ ‘[:upper:]’ 合并上下单元格内容sed -e ‘1d’ result.txt 从文件example.txt 中排除第一行sed -n ‘/stringa1/p’ 查看只包含词汇 “string1”的行sed -e ‘s/ $//‘ example.txt 删除每一行最后的空白字符sed -e ‘s/stringa1//g’ example.txt 从文档中只删除词汇 “string1” 并保留剩余全部sed -n ‘1,5p;5q’ example.txt 查看从第一行到第5行内容sed -n ‘5p;5q’ example.txt 查看第5行sed -e ‘s/00/0/g’ example.txt 用单个零替换多个零cat -n file1 标示文件的行数cat example.txt | awk ‘NR%2==1’ 删除example.txt文件中的所有偶数行echo a b c | awk ‘{print $1}’ 查看一行第一栏echo a b c | awk ‘{print $1,$3}’ 查看一行的第一和第三栏paste file1 file2 合并两个文件或两栏的内容paste -d ‘+’ file1 file2 合并两个文件或两栏的内容，中间用”+”区分sort file1 file2 排序两个文件的内容sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份)sort file1 file2 | uniq -u 删除交集，留下其他的行sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件)comm -1 file1 file2 比较两个文件的内容只删除 ‘file1’ 所包含的内容comm -2 file1 file2 比较两个文件的内容只删除 ‘file2’ 所包含的内容comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分 17.字符设置和文件格式转换dos2unix filedos.txt fileunix.txt 将一个文本文件的格式从MSDOS转换成UNIXunix2dos fileunix.txt filedos.txt 将一个文本文件的格式从UNIX转换成MSDOSrecode ..HTML &lt; page.txt &gt; page.html 将一个文本文件转换成htmlrecode -l | more 显示所有允许的转换格式 18.文件系统分析badblocks -v /dev/hda1 检查磁盘hda1上的坏磁块fsck /dev/hda1 修复/检查hda1磁盘上linux文件系统的完整性fsck.ext2 /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性e2fsck /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性e2fsck -j /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性fsck.ext3 /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性fsck.vfat /dev/hda1 修复/检查hda1磁盘上fat文件系统的完整性fsck.msdos /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性dosfsck /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性 19.初始化一个文件系统mkfs /dev/hda1 在hda1分区创建一个文件系统mke2fs /dev/hda1 在hda1分区创建一个linux ext2的文件系统mke2fs -j /dev/hda1 在hda1分区创建一个linux ext3(日志型)的文件系统mkfs -t vfat 32 -F /dev/hda1 创建一个 FAT32 文件系统fdformat -n /dev/fd0 格式化一个软盘mkswap /dev/hda3 创建一个swap文件系统 20.SWAP文件系统mkswap /dev/hda3 创建一个swap文件系统swapon /dev/hda3 启用一个新的swap文件系统swapon /dev/hda2 /dev/hdb3 启用两个swap分区 21.备份dump -0aj -f /tmp/home0.bak /home 制作一个 ‘/home’ 目录的完整备份dump -1aj -f /tmp/home0.bak /home 制作一个 ‘/home’ 目录的交互式备份restore -if /tmp/home0.bak 还原一个交互式备份rsync -rogpav –delete /home /tmp 同步两边的目录rsync -rogpav -e ssh –delete /home ip_address:/tmp 通过SSH通道rsyncrsync -az -e ssh –delete ip_addr:/home/public /home/local 通过ssh和压缩将一个远程目录同步到本地目录rsync -az -e ssh –delete /home/local ip_addr:/home/public 通过ssh和压缩将本地目录同步到远程目录dd bs=1M if=/dev/hda | gzip | ssh user@ip_addr ‘dd of=hda.gz’ 通过ssh在远程主机上执行一次备份本地磁盘的操作dd if=/dev/sda of=/tmp/file1 备份磁盘内容到一个文件tar -Puf backup.tar /home/user 执行一次对 ‘/home/user’ 目录的交互式备份操作( cd /tmp/local/ &amp;&amp; tar c . ) | ssh -C user@ip_addr ‘cd /home/share/ &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个目录内容( tar c /home ) | ssh -C user@ip_addr ‘cd /home/backup-home &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个本地目录tar cf - . | (cd /tmp/backup ; tar xf - ) 本地将一个目录复制到另一个地方，保留原有权限及链接find /home/user1 -name ‘.txt’ | xargs cp -av –target-directory=/home/backup/ –parents 从一个目录查找并复制所有以 ‘.txt’ 结尾的文件到另一个目录find /var/log -name ‘.log’ | tar cv –files-from=- | bzip2 &gt; log.tar.bz2 查找所有以 ‘.log’ 结尾的文件并做成一个bzip包dd if=/dev/hda of=/dev/fd0 bs=512 count=1 做一个将 MBR (Master Boot Record)内容复制到软盘的动作dd if=/dev/fd0 of=/dev/hda bs=512 count=1 从已经保存到软盘的备份中恢复MBR内容 22.光盘cdrecord -v gracetime=2 dev=/dev/cdrom -eject blank=fast -force 清空一个可复写的光盘内容mkisofs /dev/cdrom &gt; cd.iso 在磁盘上创建一个光盘的iso镜像文件mkisofs /dev/cdrom | gzip &gt; cd_iso.gz 在磁盘上创建一个压缩了的光盘iso镜像文件mkisofs -J -allow-leading-dots -R -V “Label CD” -iso-level 4 -o ./cd.iso data_cd 创建一个目录的iso镜像文件cdrecord -v dev=/dev/cdrom cd.iso 刻录一个ISO镜像文件gzip -dc cd_iso.gz | cdrecord dev=/dev/cdrom - 刻录一个压缩了的ISO镜像文件mount -o loop cd.iso /mnt/iso 挂载一个ISO镜像文件cd-paranoia -B 从一个CD光盘转录音轨到 wav 文件中cd-paranoia – “-3” 从一个CD光盘转录音轨到 wav 文件中（参数-3）cdrecord –scanbus 扫描总线以识别scsi通道dd if=/dev/hdc | md5sum 校验一个设备的md5sum编码，例如一张 CD 23.网络 - （以太网和WIFI无线）ifconfig eth0 显示一个以太网卡的配置ifup eth0 启用一个 ‘eth0’ 网络设备ifdown eth0 禁用一个 ‘eth0’ 网络设备ifconfig eth0 192.168.1.1 netmask 255.255.255.0 控制IP地址ifconfig eth0 promisc 设置 ‘eth0’ 成混杂模式以嗅探数据包 (sniffing)dhclient eth0 以dhcp模式启用 ‘eth0’route -n show routing tableroute add -net 0/0 gw IP_Gateway configura default gatewayroute add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1 configure static route to reach network ‘192.168.0.0/16’route del 0/0 gw IP_gateway remove static routeecho “1” &gt; /proc/sys/net/ipv4/ip_forward activate ip routinghostname show hostname of systemhost www.example.com lookup hostname to resolve name to ip address and viceversa(1)nslookup www.example.com lookup hostname to resolve name to ip address and viceversa(2)ip link show show link status of all interfacesmii-tool eth0 show link status of ‘eth0’ethtool eth0 show statistics of network card ‘eth0’netstat -tup show all active network connections and their PIDnetstat -tupl show all network services listening on the system and their PIDtcpdump tcp port 80 show all HTTP trafficiwlist scan show wireless networksiwconfig eth1 show configuration of a wireless network cardhostname show hostnamehost www.example.com lookup hostname to resolve name to ip address and viceversanslookup www.example.com lookup hostname to resolve name to ip address and viceversawhois www.example.com lookup on Whois database Microsoft Windows networks (SAMBA)nbtscan ip_addr netbios name resolutionnmblookup -A ip_addr netbios name resolutionsmbclient -L ip_addr/hostname show remote shares of a windows hostsmbget -Rr smb://ip_addr/share like wget can download files from a host windows via smbmount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share mount a windows network share]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CI常用函数]]></title>
      <url>%2F2017%2F04%2F07%2FCI%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%2F</url>
      <content type="text"><![CDATA[选择数据$this-&gt;db-&gt;select();允许你在SQL查询中写 SELECT 部分。$this-&gt;db-&gt;where();$this-&gt;db-&gt;or_where();$this-&gt;db-&gt;where_in();允许你在SQL查询中写 WHERE部分，其余各种where语句请看手册。$this-&gt;db-&gt;get();运行选择查询语句并且返回结果集。可以获取一个表的全部数据。$this-&gt;db-&gt;like();$this-&gt;db-&gt;or_like();$this-&gt;db-&gt;not_like();本函数允许你生成 LIKE 子句，在做查询时非常有用，其余语法请看手册。$this-&gt;db-&gt;order_by();帮助你设置一个 ORDER BY 子句。$this-&gt;db-&gt;group_by();允许你编写查询语句中的 GROUP BY 部分:$this-&gt;db-&gt;distinct();为查询语句添加 “DISTINCT” 关键字:$this-&gt;db-&gt;having();允许你为你的查询语句编写 HAVING 部分。$this-&gt;db-&gt;limit();限制查询所返回的结果数量:$this-&gt;db-&gt;select_max();为你的查询编写一个 “SELECT MAX(field)”。$this-&gt;db-&gt;select_min();为你的查询编写一个 “SELECT MIN(field)” 。$this-&gt;db-&gt;select_avg();为你的查询编写一个 “SELECT AVG(field)” 。$this-&gt;db-&gt;select_sum();为你的查询编写一个 “SELECT SUM(field)” 。$this-&gt;db-&gt;join();允许你编写查询中的JOIN部分。$this-&gt;db-&gt;count_all_results();允许你获得某个特定的Active Record查询所返回的结果数量。可以使用Active Record限制函数，例如 where(), or_where(), like(), or_like() 等等。 插入数据$this-&gt;db-&gt;insert();生成一条基于你所提供的数据的SQL插入字符串并执行查询。你可以向函数传递 数组 或一个 对象。$this-&gt;db-&gt;insert_batch();一次插入多条数据，生成一条基于你所提供的数据的SQL插入字符串并执行查询。你可以向函数传递 数组 或一个 对象。$this-&gt;db-&gt;set();本函数使您能够设置inserts(插入)或updates(更新)值。它可以用来代替那种直接传递数组给插入和更新函数的方式。 更新数据$this-&gt;db-&gt;update();根据你提供的数据生成并执行一条update(更新)语句。你可以将一个数组或者对象传递给本函数。$this-&gt;db-&gt;update_batch();Generates an update string based on the data you supply, and runs the query. You can either pass an array or an object to the function. Here is an example using an array: 删除数据$this-&gt;db-&gt;delete();生成并执行一条DELETE(删除)语句。$this-&gt;db-&gt;empty_table();生成并执行一条DELETE(删除)语句。$this-&gt;db-&gt;truncate();生成并执行一条TRUNCATE(截断)语句。 链式方法 链式方法允许你以连接多个函数的方式简化你的语法。考虑一下这个范例:$this-&gt;db-&gt;select(‘title’)-&gt;from(‘mytable’)-&gt;where(‘id’, $id)-&gt;limit(10, 20);$query = $this-&gt;db-&gt;get();说明: 链式方法只能在PHP 5下面运行。 查询 $this-&gt;db-&gt;query();要提交一个查询，用以下函数：$this-&gt;db-&gt;query(‘YOUR QUERY HERE’);query() 函数以object(对象)的形式返回一个数据库结果集。 当使用 “read” 模式来运行查询时, 你可以使用“显示你的结果集”来显示查询结果; 当使用 “write” 模式来运行查询时, 将会仅根据执行的成功或失败来返回 TRUE 或 FALSE. 转义查询$this-&gt;db-&gt;escape()这个函数将会确定数据类型，以便仅对字符串类型数据进行转义。并且，它也会自动把数据用单引号括起来，所以你不必手动添加单引号，用法如下： $sql = “INSERT INTO table (title) VALUES(“.$this-&gt;db-&gt;escape($title).”)”; 查询辅助函数$this-&gt;db-&gt;insert_id()这个ID号是执行数据插入时的ID。$this-&gt;db-&gt;affected_rows()当执行写入操作（insert,update等）的查询后，显示被影响的行数。$this-&gt;db-&gt;count_all();计算出指定表的总行数并返回。在第一个参数中写入被提交的表名。 生成查询记录集result()该方法执行成功返回一个object 数组，失败则返回一个空数组。result_array()该方法执行成功时将记录集作为关联数组返回。失败时返回空数组。row()该函数将当前请求的第一行数据作为 object 返回。 你可以传递参数(参数是行的索引)以便获得某一行的数据。比如我们要获得第 5 行的数据： $row = $query-&gt;row(4); row_array()功能与 row() 一样, 区别在于该函数返回的是一个数组。除此以外, 我们还可以使用下面的方法通过游标的方式获取记录：$row = $query-&gt;first_row()$row = $query-&gt;last_row()$row = $query-&gt;next_row()$row = $query-&gt;previous_row()默认情况下他们将返回一个 object，同时你也可以传递参数 “array” 以便使用 array 的方式获取数据 $row = $query-&gt;first_row(‘array’)$row = $query-&gt;last_row(‘array’)$row = $query-&gt;next_row(‘array’)$row = $query-&gt;previous_row(‘array’) 结果集辅助函数$query-&gt;num_rows()该函数将会返回当前请求的行数。$query-&gt;num_fields()该函数返回当前请求的字段数（列数）：$query-&gt;free_result()该函数将会释放当前查询所占用的内存并删除其关联的资源标识。 自动连接 “自动连接” 功能将在每个一页面加载时被自动实例化数据库类。要启用“自动连接”，可在application/config/autoload.php中的 library 数组里添加 database：$autoload[‘libraries’] = array(‘database’); 手动连接 如果仅仅是一部分页面要求数据库连接，你可以在你有需要的函数里手工添加如下代码或者在你的类里手工添加以供该类使用。$this-&gt;load-&gt;database(); 连接多数据库 如果你需要同时连接多于一个的数据库，你可以用以下方式来实现：$DB1 = $this-&gt;load-&gt;database(‘group_one’, TRUE);$DB2 = $this-&gt;load-&gt;database(‘group_two’, TRUE); 表数据 $this-&gt;db-&gt;list_tables();返回一个包含当前连接数据库中所有表名称的数组。$this-&gt;db-&gt;table_exists();有时，在对某个表执行操作之前，使用该函数判断指定表是否存在很有用。返回一个布尔值。 数据库工具类 重要提示： 初始化数据库工具类之前，你的数据库驱动必须已经运行,因为工具类依赖于此。加载工具类： $this-&gt;load-&gt;dbutil()一旦初始化完毕，你可以通过 $this-&gt;dbutil 对象来访问成员函数：$this-&gt;dbutil-&gt;list_databases()$this-&gt;dbutil-&gt;database_exists();$this-&gt;dbutil-&gt;xml_from_result($db_result)$this-&gt;dbutil-&gt;backup() 数据库缓存类 激活缓存需要三步：1、在服务器上创建一个可写的目录以便保存缓存文件。2、在文件 application/config/database.php 中$db[‘xxxx’][‘cachedir’]设置其目录。3、激活缓存特性，可以在文件 application/config/database.php 中设置全局选项$db[‘xxxx’][‘cache_on’]=’TRUE’，也可以用以本页下面的方法手动设置。一旦被激活，每一次含有数据库查询的页面被加载时缓存就会自动发生。 当有数据库更新，我们需要删除缓存文件$this-&gt;db-&gt;cache_delete()删除缓存文件与特定网页。如果你需要清除缓存后，更新您的数据库$this-&gt;db-&gt;cache_delete(‘/blog’, ‘comments’);注意，手册上写的是 $this-&gt;db-&gt;cache_delete(‘blog’, ‘comments’);但根据实际测试应该在控制器名字前加斜杠’/‘才能正确执行。$this-&gt;db-&gt;cache_delete_all()清除所有所有的缓存文件。 数据库维护类 注意: 欲初始化数据库维护类，请确保你的数据库驱动已经运行，因为该类依赖于数据库驱动。使用如下方法载入数据库维护类:$this-&gt;load-&gt;dbforge()一旦初始化，就可以使用$this-&gt;dbforge 对象访问类中函数:$this-&gt;dbforge-&gt;create_database(‘db_name’)允许你创建由第一个参数指定的数据库。$this-&gt;dbforge-&gt;drop_database(‘db_name’)允许你删除由第一个参数指定的数据库。$this-&gt;dbforge-&gt;create_table(‘table_name’);声明了字段和键之后，你就可以创建一个表。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端知识点2]]></title>
      <url>%2F2017%2F04%2F07%2F%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B92%2F</url>
      <content type="text"><![CDATA[1,将url的查询参数解析成字典对象这个题目不约而同的出现在了多家公司的面试题中，当然也是因为太过于典型，解决方案无非就是拆字符或者用正则匹配来解决，我个人强烈建议用正则匹配，因为url允许用户随意输入，如果用拆字符的方式，有任何一处没有考虑到容错，就会导致整个js都报错。而正则就没有这个问题，他只匹配出正确的配对，非法的全部过滤掉，简单，方便。实现代码：123456789101112131415function getQueryObject(url) &#123; url = url == null ? window.location.href : url; var search = url.substring(url.lastIndexOf(&quot;?&quot;) + 1); var obj = &#123;&#125;; var reg = /([^?&amp;=]+)=([^?&amp;=]*)/g; search.replace(reg, function (rs, $1, $2) &#123; var name = decodeURIComponent($1); var val = decodeURIComponent($2); val = String(val); obj[name] = val; return rs; &#125;); return obj;&#125;getQueryObject(&quot;http://www.cnblogs.com/leee/p/4456840.html?name=1&amp;dd=ddd**&quot;) Object {name: &quot;1&quot;, dd: &quot;ddd**&quot;} 2.console.log(1+ +”2”);输出的是3等同于: 1+(+’2’)：+’2’ 的 + 是一元操作符，对 ‘2’ 进行Number()操作，转为数字的2，所以等于312console.log(&quot;A&quot;-&quot;B&quot;+&quot;2&quot;) NaN2console.log(&quot;A&quot;-&quot;B&quot;+2) NaN 3. 算法12345678910function test(a,b)&#123; console.log(b); return&#123; test:function(x)&#123; return test(x,a); &#125; &#125; &#125; var a=test(0);a.test(1);a.test(2);a.test(3); // underfined 0 0 0 4. 三次握手第一次第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。 第二次第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。完成三次握手，客户端与服务器开始传送数据，在上述过程中，还有一些重要的概念： 5. http 状态码一、HTTP状态码如果某项请求发送到您的服务器要求显示您网站上的某个网页（例如，用户通过浏览器访问您的网页或 Googlebot 抓取网页时），服务器将会返回 HTTP 状态代码以响应请求。 此状态代码提供关于请求状态的信息， 告诉 Googlebot 关于您的网站和请求的网页的信息。一些常见的状态代码包括：200 – 服务器成功返回网页404 – 请求的网页不存在503 – 服务器暂时不可用 下面提供 HTTP 状态代码的完整列表。 点击链接可了解详情。 您也可以访问有关 HTTP 状态代码的 W3C 网页以获得更多信息 。 1xx：请求收到，继续处理2xx：操作成功收到，分析、接受3xx：完成此请求必须进一步处理4xx：请求包含一个错误语法或不能完成5xx：服务器执行一个完全有效请求失败1xx （临时响应）表示临时响应并需要请求者继续执行操作的状态代码。 代码 说明100（继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。101（切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。 2xx （成功）表示服务器成功处理了请求的状态代码。 代码 说明200（成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。 如果针对您的 robots.txt 文件显示此状态，则表示 Googlebot 已成功检索到该文件。201（已创建） 请求成功并且服务器创建了新的资源。202（已接受） 服务器已接受请求，但尚未处理。203（非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。204（无内容） 服务器成功处理了请求，但没有返回任何内容。205（重置内容） 服务器成功处理了请求，但没有返回任何内容。 与 204 响应不同，此响应要求请求者重置文档视图（例如，清除表单内容以输入新内容）。206（部分内容） 服务器成功处理了部分 GET 请求。 3xx （重定向）要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。 Google 建议您在每次请求中使用重定向不要超过 5 次。 您可以使用网站管理员工具查看一下 Googlebot 在抓取重定向网页时是否遇到问题。 诊断 下的网 络抓取 页面列出了由于重定向错误而导致 Googlebot 无法抓取的网址。 代码 说明300（多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者（用户代理）选择一项操作，或提供操作列表供请求者选择。301（永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。 您应使用此代码告诉 Googlebot 某个网页或网站已永久移动到新位置。302（暂时移动） 服 务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 此代码与响应 GET 或 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个网页或网站已经移动，因为 Googlebot 会继续抓取原有位置并编入索引。303（查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。 对于除 HEAD 之外的所有请求，服务器会自动转到其他位置。304（未修改） 自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。如果网页自请求者上次请求后再也没有更改 过，您应当将服务器配置为返回此响应（称为 If-Modified-Since HTTP 标头）。 由于服务器可以告诉 Googlebot 自从上次抓取后网页没有更改过，因此可节省带宽和开销。305（使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。307（暂时重定向） 服 务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个页面或网站已经移动，因为 Googlebot 会继续抓取原有位置并编入索引。 4xx（请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。 代码 说明400（错误请求） 服务器不理解请求的语法。401（未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。403（禁止） 服务器拒绝请求。 如果您看到 Googlebot 在尝试抓取您网站上的有效网页时收到此状态代码（可以在 Google 网站管理员工具诊 断 下的网络抓取 页面上看到此信息），可能是您的服务器或主机拒绝 Googlebot 访问。404（未找到） 服务器找不到请求的网页。 例如，如果请求服务器上不存在的网页，服务器通常会返回此代码。如果您的网站上没有 robots.txt 文件，而您在 Google 网站管理员工具”诊断”标签的 robots.txt 页 上看到此状态，那么这是正确的状态。 但是，如果您有 robots.txt 文件而又看到此状态，则说明您的 robots.txt 文件可能命名错误或位于错误的位置 （该文件应当位于顶级域名，名为 robots.txt）。如果您看到有关 Googlebot 尝试抓取的网址的此状态（在”诊断”标签的 HTTP 错误页上），则表示 Googlebot 追踪的可能是另一个页面的无效链接（是旧链接或输入有误的链接）。405（禁用的方法） 禁用请求中指定的方法。406（不可接受） 无法使用请求的内容特性响应请求的网页。407（需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。 如果服务器返回此响应，还会指明请求者应当使用的代理。408（请求超时） 服务器等候请求时发生超时。409（冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 服务器在响应与前一个请求相冲突的 PUT 请求时可能会返回此代码，同时会附上两个请求的差异列表。410（已删除） 如果请求的资源已永久删除，服务器就会返回此响应。 该代码与 404（未找到）代码相似，但在资源以前存在而现在不存在的情况下，有时会用来替代 404 代码。 如果资源已永久删除，您应当使用 301 指定资源的新位置。411（需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。412（未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。413（请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。414（请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。415（不支持的媒体类型） 请求的格式不受请求页面的支持。416（请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。417（未满足期望要求） 服务器未满足”期望”请求标头字段的要求。 5xx （服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。 代码 说明500（服务器内部错误） 服务器遇到错误，无法完成请求。501（尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。502（错误网关） 服务器充当网关或代理，从上游服务器收到无效响应。503（服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。504（网关超时） 服务器充当网关或代理，但没有及时从上游服务器收到请求。505（HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。 HTML+CSS1.对WEB标准以及W3C的理解与认识标签闭合、标签小写、不乱嵌套、提高搜索机器人搜索几率、使用外 链css和js脚本、结构行为表现的分离、文件下载与页面速度更快、内容能被更多的用户所访问、内容能被更广泛的设备所访问、更少的代码和组件，容易维 护、改版方便，不需要变动页面内容、提供打印版本而不需要复制内容、提高网站易用性； 2.xhtml和html有什么区别HTML是一种基本的WEB网页设计语言，XHTML是一个基于XML的置标语言最主要的不同：XHTML 元素必须被正确地嵌套。XHTML 元素必须被关闭。标签名必须用小写字母。XHTML 文档必须拥有根元素。 3.Doctype? 严格模式与混杂模式-如何触发这两种模式，区分它们有何意义?用于声明文档使用那种规范（html/Xhtml）一般为 严格 过度 基于框架的html文档加入XMl声明可触发，解析方式更改为IE5.5 拥有IE5.5的bug 4.行内元素有哪些?块级元素有哪些?CSS的盒模型?块级元素：div p h1 h2 h3 h4 form ul行内元素: a b br i span input selectCss盒模型:内容，border ,margin，padding 5.CSS引入的方式有哪些? link和@import的区别是?内联 内嵌 外链 导入区别 ：同时加载前者无兼容性，后者CSS2.1以下浏览器不支持Link 支持使用javascript改变样式，后者不可 6.CSS选择符有哪些?哪些属性可以继承?优先级算法如何计算?内联和important哪个优先级高?标签选择符 类选择符 id选择符继承不如指定 Id&gt;class&gt;标签选择后者优先级高 7.前端页面有哪三层构成，分别是什么?作用是什么?结构层 Html 表示层 CSS 行为层 js 8.css的基本语句构成是?选择器{属性1:值1;属性2:值2;……} 9.你做的页面在哪些流览器测试过?这些浏览器的内核分别是什么?Ie(Ie内核) 火狐（Gecko） 谷歌（webkit） opear(Presto) 10.写出几种IE6 BUG的解决方法1.双边距BUG float引起的 使用display2.3像素问题 使用float引起的 使用dislpay:inline -3px3.超链接hover 点击后失效 使用正确的书写顺序 link visited hover active4.Ie z-index问题 给父级添加position:relative5.Png 透明 使用js代码 改6.Min-height 最小高度 ！Important 解决’7.select 在ie6下遮盖 使用iframe嵌套8.为什么没有办法定义1px左右的宽度容器（IE6默认的行高造成的，使用over:hidden,zoom:0.08 line-height:1px） 11.标签上title与alt属性的区别是什么?Alt 当图片不显示是 用文字代表。Title 为该属性提供信息 12.描述css reset的作用和用途。Reset重置浏览器的css默认属性 浏览器的品种不同，样式不同，然后重置，让他们统一 13.解释css sprites，如何使用。Css 精灵 把一堆小的图片整合到一张大的图片上，减轻服务器对图片的请求数量 14.浏览器标准模式和怪异模式之间的区别是什么?盒子模型 渲染模式的不同使用 window.top.document.compatMode 可显示为什么模式 15.你如何对网站的文件和资源进行优化?期待的解决方案包括：文件合并文件最小化/文件压缩使用CDN托管缓存的使用 16.什么是语义化的HTML?直观的认识标签 对于搜索引擎的抓取有好处 17.清除浮动的几种方式，各自的优缺点1.使用空标签清除浮动 clear:both（理论上能清楚任何标签，，，增加无意义的标签）2.使用overflow:auto（空标签元素清除浮动而不得不增加无意代码的弊端,,使用zoom:1用于兼容IE）3.是用afert伪元素清除浮动(用于非IE浏览器) Javascript1.javascript的typeof返回哪些数据类型Object number function boolean underfind 2.例举3种强制类型转换和2种隐式类型转换?强制（parseInt,parseFloat,number）隐式（== – ===） 3.split() join() 的区别前者是切割成数组的形式，后者是将数组转换成字符串 4.数组方法pop() push() unshift() shift()Push()尾部添加 pop()尾部删除Unshift()头部添加 shift()头部删除 5.事件绑定和普通事件有什么区别6.IE和DOM事件流的区别1.执行顺序不一样、2.参数不一样3.事件加不加on4.this指向问题 7.IE和标准下有哪些兼容性的写法Var ev = ev || window.eventdocument.documentElement.clientWidth || document.body.clientWidthVar target = ev.srcElement||ev.target 8.ajax请求的时候get 和post方式的区别一个在url后面 一个放在虚拟载体里面有大小限制安全问题应用不同 一个是论坛等只需要请求的，一个是类似修改密码的 9.call和apply的区别Object.call(this,obj1,obj2,obj3)Object.apply(this,arguments)obj.call(thisObj, arg1, arg2, …);obj.apply(thisObj, [arg1, arg2, …]);两者作用一致，都是把obj(即this)绑定到thisObj，这时候thisObj具备了obj的属性和方法。或者说thisObj『继承』了obj的属性和方法。唯一区别是apply接受的是数组参数，call接受的是连续参数。1234567function add(j, k)&#123; return j+k;&#125;function sub(j, k)&#123; return j-k;&#125; 我们在控制台运行：1234567add(5,3); //8add.call(sub, 5, 3); //8add.apply(sub, [5, 3]); //8sub(5, 3); //2sub.call(add, 5, 3); //2sub.apply(add, [5, 3]); //2 10.ajax请求时，如何解释json数据使用eval parse 鉴于安全性考虑 使用parse更靠谱11.b继承a的方法 12.写一个获取非行间样式的函数123456789101112131415161718function getStyle(obj,attr,value)&#123;if(!value)&#123;if(obj.currentStyle)&#123;return obj.currentStyle(attr)&#125;else&#123;obj.getComputedStyle(attr,false)&#125;&#125;else&#123;obj.style[attr]=value&#125;&#125; 13.事件委托是什么让利用事件冒泡的原理，让自己的所触发的事件，让他的父元素代替执行！http://www.webasily.com/?p=78 例子可见此链接 14.闭包是什么，有什么特性，对页面有什么影响闭包就是能够读取其他函数内部变量的函数。http://blog.csdn.net/gaoshanwudi/article/details/7355794 此链接可查看（问这个问题的不是一个公司） 15.如何阻止事件冒泡和默认事件canceBubble return false 16.添加 删除 替换 插入到某个接点的方法obj.appendChidl()obj.innersetBeforeobj.replaceChildobj.removeChild 17.解释jsonp的原理，以及为什么不是真正的ajax动态创建script标签，回调函数Ajax是页面无刷新请求数据操作 18.javascript的本地对象，内置对象和宿主对象本地对象为array obj regexp等可以new实例化内置对象为gload Math 等不可以实例化的宿主为浏览器自带的document,window 等 19.document load 和document ready的区别Document.onload 是在结构和样式加载完才执行jsDocument.ready原生种没有这个方法，jquery中有 $().ready(function) 20.”==”和“===”的不同前者会自动转换类型后者不会 21.javascript的同源策略一段脚本只能读取来自于同一来源的窗口和文档的属性，这里的同一来源指的是主机名、协议和端口号的组合 22.编写一个数组去重的方法function oSort(arr){ var result ={}; var newArr=[];for(var i=0;i&lt;arr.length;i++){ if(!result[arr]) { newArr.push(arr) result[arr]=1 }}return newArr} 23.cookie sessionstorage localstoragecookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。Web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者。Web Storage 的 api 接口使用更方便。24.split var str=”How are you doing today?” document.write(str.split(“ “) + ““)document.write(str.split(“”) + ““)document.write(str.split(“ “,3)) 输出：How,are,you,doing,today?H,o,w, ,a,r,e, ,y,o,u, ,d,o,i,n,g, ,t,o,d,a,y,?How,are,you 25. 对象创建过程1.分配空间。要注意的是，分配空间不光是分配子类的空间，子类对象中包含的父类对象所需要的空间，一样在这一步统一分配。在分配的空间的时候，会把所有的属性设置为默认值。 2.递归的构造父类对象。 3.初始化本类属性。 4.调用本类的构造方法。 总结一下，创建B类对象的步骤一共有5步 1.分配空间 2.初始化A类属性。 3.调用A类的构造方法. 4.初始化B的属性。 5.调用B的构造方法。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[跨域]]></title>
      <url>%2F2017%2F04%2F06%2F%E8%B7%A8%E5%9F%9F%2F</url>
      <content type="text"><![CDATA[什么是跨域JavaScript出于安全方面的考虑，不允许跨域调用其他页面的对象。但在安全限制的同时也给注入iframe或是ajax应用上带来了不少麻烦。这里把涉及到跨域的一些问题简单地整理一下：首先什么是跨域，简单地理解就是因为JavaScript同源策略的限制，a.com 域名下的js无法操作b.com或是c.a.com域名下的对象。更详细的说明可以看下表： 特别注意两点： 第一，如果是协议和端口造成的跨域问题“前台”是无能为力的，第二：在跨域问题上，域仅仅是通过“URL的首部”来识别而不会去尝试判断相同的ip地址对应着两个域或两个域是否在同一个ip上。“URL的首部”指window.location.protocol +window.location.host，也可以理解为“Domains, protocols and ports must match”。接下来简单地总结一下在“前台”一般处理跨域的办法，后台proxy这种方案牵涉到后台配置，这里就不阐述了，有兴趣的可以看看yahoo的这篇文章：《JavaScript: Use a Web Proxy for Cross-Domain XMLHttpRequest Calls》 1、document.domain+iframe的设置对于主域相同而子域不同的例子，可以通过设置document.domain的办法来解决。 具体的做法是可以在http://www.a.com/a.html和http://script.a.com/b.html两个文件中分别加上 document.domain = ‘a.com’；然后通过a.html文件中创建一个iframe，去控制iframe的contentDocument，这样两个js文件之间就可以 “交互”了。当然这种办法只能解决主域相同而二级域名不同的情况，如果你异想天开的把script.a.com的domian设为alibaba.com 那显然是会报错地！代码如下： www.a.com上的a.html12345678910document.domain = &apos;a.com&apos;;var ifr = document.createElement(&apos;iframe&apos;);ifr.src = &apos;http://script.a.com/b.html&apos;;ifr.style.display = &apos;none&apos;;document.body.appendChild(ifr);ifr.onload = function()&#123; var doc = ifr.contentDocument || ifr.contentWindow.document; // 在这里操纵b.html alert(doc.getElementsByTagName(&quot;h1&quot;)[0].childNodes[0].nodeValue);&#125;; script.a.com上的b.htmldocument.domain = ‘a.com’; 这种方式适用于{www.kuqin.com, kuqin.com, script.kuqin.com, css.kuqin.com}中的任何页面相互通信。 备注：某一页面的domain默认等于window.location.hostname。主域名是不带www的域名，例如a.com，主域名前面带前缀的通常都为二级域名或多级域名，例如www.a.com其实是二级域名。 domain只能设置为主域名，不可以在b.a.com中将domain设置为c.a.com。 问题： 1、安全性，当一个站点（b.a.com）被攻击后，另一个站点（c.a.com）会引起安全漏洞。2、如果一个页面中引入多个iframe，要想能够操作所有iframe，必须都得设置相同domain。 2、动态创建script虽然浏览器默认禁止了跨域访问，但并不禁止在页面中引用其他域的JS文件，并可以自由执行引入的JS文件中的function（包括操作cookie、Dom等等）。根据这一点，可以方便地通过创建script节点的方法来实现完全跨域的通信。具体的做法可以参考YUI的Get Utility 这里判断script节点加载完毕还是蛮有意思的：ie只能通过script的readystatechange属性，其它浏览器是script的load事件。以下是部分判断script加载完毕的方法。123456js.onload = js.onreadystatechange = function() &#123; if (!this.readyState || this.readyState === &apos;loaded&apos; || this.readyState === &apos;complete&apos;) &#123; // callback在此处执行 js.onload = js.onreadystatechange = null; &#125;&#125;; 3、利用iframe和location.hash这个办法比较绕，但是可以解决完全跨域情况下的脚步置换问题。原理是利用location.hash来进行传值。在url： http://a.com#helloword中的‘#helloworld’就是location.hash，改变hash并不会导致页面刷新，所以可 以利用hash值来进行数据传递，当然数据容量是有限的。假设域名a.com下的文件cs1.html要和cnblogs.com域名下的 cs2.html传递信息，cs1.html首先创建自动创建一个隐藏的iframe，iframe的src指向cnblogs.com域名下的 cs2.html页面，这时的hash值可以做参数传递用。cs2.html响应请求后再将通过修改cs1.html的hash值来传递数据（由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于a.com域名下的一个代理iframe；Firefox可以修改）。同时在cs1.html上加一个定时器，隔一段时间来判断location.hash的值有没有变化，一点有变化则获取获取hash值。代码如下： 先是a.com下的文件cs1.html文件：12345678910111213141516function startRequest()&#123; var ifr = document.createElement(&apos;iframe&apos;); ifr.style.display = &apos;none&apos;; ifr.src = &apos;http://www.cnblogs.com/lab/cscript/cs2.html#paramdo&apos;; document.body.appendChild(ifr);&#125;function checkHash() &#123; try &#123; var data = location.hash ? location.hash.substring(1) : &apos;&apos;; if (console.log) &#123; console.log(&apos;Now the data is &apos;+data); &#125; &#125; catch(e) &#123;&#125;;&#125;setInterval(checkHash, 2000); cnblogs.com域名下的cs2.html:12345678910111213141516171819202122//模拟一个简单的参数处理操作switch(location.hash)&#123; case &apos;#paramdo&apos;: callBack(); break; case &apos;#paramset&apos;: //do something…… break;&#125;function callBack()&#123; try &#123; parent.location.hash = &apos;somedata&apos;; &#125; catch (e) &#123; // ie、chrome的安全机制无法修改parent.location.hash， // 所以要利用一个中间的cnblogs域下的代理iframe var ifrproxy = document.createElement(&apos;iframe&apos;); ifrproxy.style.display = &apos;none&apos;; ifrproxy.src = &apos;http://a.com/test/cscript/cs3.html#somedata&apos;; // 注意该文件在&quot;a.com&quot;域下 document.body.appendChild(ifrproxy); &#125;&#125; a.com下的域名cs3.html //因为parent.parent和自身属于同一个域，所以可以改变其location.hash的值parent.parent.location.hash = self.location.hash.substring(1); 当然这样做也存在很多缺点，诸如数据直接暴露在了url中，数据容量和类型都有限等…… 4、window.name实现的跨域数据传输文章较长列在此处不便于阅读，详细请看 window.name实现的跨域数据传输（http://www.cnblogs.com/rainman/archive/2011/02/21/1960044.html）。 5、使用HTML5 postMessageHTML5中最酷的新功能之一就是 跨文档消息传输Cross Document Messaging。 下一代浏览器都将支持这个功能：Chrome 2.0+、Internet Explorer 8.0+, Firefox 3.0+, Opera 9.6+, 和 Safari 4.0+ 。 Facebook已经使用了这个功能，用postMessage支持基于web的实时消息传递。 otherWindow.postMessage(message, targetOrigin);otherWindow: 对接收信息页面的window的引用。可以是页面中iframe的contentWindow属性；window.open的返回值；通过name或下标从window.frames取到的值。message: 所要发送的数据，string类型。targetOrigin: 用于限制otherWindow，“*”表示不作限制a.com/index.html中的代码：1234567891011&lt;iframe id=&quot;ifr&quot; src=&quot;b.com/index.html&quot;&gt;&lt;/iframe&gt;&lt;script type=&quot;text/javascript&quot;&gt;window.onload = function() &#123; var ifr = document.getElementById(&apos;ifr&apos;); var targetOrigin = &apos;http://b.com&apos;; // 若写成&apos;http://b.com/c/proxy.html&apos;效果一样 // 若写成&apos;http://c.com&apos;就不会执行postMessage了 ifr.contentWindow.postMessage(&apos;I was there!&apos;, targetOrigin);&#125;;&lt;/script&gt;b.co```m/index.html中的代码： 12345678910&lt;script type=&quot;text/javascript&quot;&gt; window.addEventListener(&apos;message&apos;, function(event)&#123; // 通过origin属性判断消息来源地址 if (event.origin == &apos;http://a.com&apos;) &#123; alert(event.data); // 弹出&quot;I was there!&quot; alert(event.source); // 对a.com、index.html中window对象的引用 // 但由于同源策略，这里event.source不可以访问window对象 &#125; &#125;, false);&lt;/script&gt; 参考文章：《精通HTML5编程》第五章——跨文档消息机制、https://developer.mozilla.org/en/dom/window.postmessage 6、利用flash这是从YUI3的IO组件中看到的办法，具体可见http://developer.yahoo.com/yui/3/io/。可以看在Adobe Developer Connection看到更多的跨域代理文件规范：ross-Domain Policy File Specifications、HTTP Headers Blacklist。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端知识点1]]></title>
      <url>%2F2017%2F04%2F06%2F%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B91%2F</url>
      <content type="text"><![CDATA[1. 常用那几种浏览器测试？有哪些内核(Layout Engine)?(Q1) 浏览器：IE，Chrome，FireFox，Safari，Opera。(Q2) 内核：Trident，Gecko，Presto，Webkit。 2. 说下行内元素和块级元素的区别？行内块元素的兼容性使用？（IE8 以下）(Q1) 行内元素：会在水平方向排列，不能包含块级元素，设置width无效，height无效(可以设置line-height)，margin上下无效，padding上下无效。 块级元素：各占据一行，垂直方向排列。从新行开始结束接着一个断行。 (Q2)兼容性：display:inline-block;display:inline;zoom:1; 3. 清除浮动有哪些方式？比较好的方式是哪一种？(Q1)（1）父级div定义height。（2）结尾处加空div标签clear:both。（3）父级div定义伪类:after和zoom。（4）父级div定义overflow:hidden。（5）父级div定义overflow:auto。（6）父级div也浮动，需要定义宽度。（7）父级div定义display:table。（8）结尾处加br标签clear:both。 (Q2) 比较好的是第3种方式，好多网站都这么用。 4. box-sizing常用的属性有哪些？分别有什么作用？(Q1)box-sizing: content-box|border-box|inherit; (Q2)content-box:宽度和高度分别应用到元素的内容框。在宽度和高度之外绘制元素的内边距和边框(元素默认效果)。border-box:元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。 5. Doctype作用？标准模式与兼容模式各有什么区别?(Q1) &lt;!DOCTYPE&gt;告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。 (Q2) 标准模式的排版和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。 6. HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;？HTML5不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）。 而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。 7. 页面导入样式时，使用link和@import有什么区别？（1）link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS;（2）页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;（3）import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题。 8. 介绍一下你对浏览器内核的理解？主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。 渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、我们组建一大牛裙前面是4七一，整理讯息（例如加入CSS等），中间是零2七，以及计算网页的显示方式，后面是壹武四，是学习的就加，不是学习的请勿打扰。然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。 JS引擎则：解析和执行javascript来实现网页的动态效果。 最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。 9. html5有哪些新特性？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？(Q1)HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。(1)绘画 canvas;(2)用于媒介回放的 video 和 audio 元素;(3)本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;(4)sessionStorage 的数据在浏览器关闭后自动删除;(5)语意化更好的内容元素，比如 article、footer、header、nav、section;(6)表单控件，calendar、date、time、email、url、search;(7)新的技术webworker, websocket, Geolocation; (Q2)IE8/IE7/IE6支持通过document.createElement方法产生的标签，可以利用这一特性让这些浏览器支持HTML5新标签，浏览器支持新标签后，还需要添加标签默认的样式。当然也可以直接使用成熟的框架、比如html5shim， &lt; !–[if lt IE 9]&gt;&lt; ![endif]–&gt; 10. 简述一下你对HTML语义化的理解？用正确的标签做正确的事情。 html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的;搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO;使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。 JavaScript1. 介绍js的基本数据类型Undefined、Null、Boolean、Number、String 2. js有哪些内置对象？数据封装类对象：Object、Array、Boolean、Number 和 String其他对象：Function、Arguments、Math、Date、RegExp、Error 3. this对象的理解this总是指向函数的直接调用者（而非间接调用者）；如果有new关键字，this指向new出来的那个对象；在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window。 4. eval是做什么的？它的功能是把对应的字符串解析成JS代码并运行；应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval(‘(‘+ str +’)’)。 5. DOM怎样添加、移除、移动、复制、创建和查找节点// 创建新节点123createDocumentFragment() //创建一个DOM片段createElement() //创建一个具体的元素createTextNode() //创建一个文本节点 // 添加、移除、替换、插入1234appendChild()removeChild()replaceChild()insertBefore() //在已有的子节点前插入一个新的子节点 // 查找123getElementsByTagName() //通过标签名称getElementsByName() //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)getElementById() //通过元素Id，唯一性 6. null和undefined的区别？null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。undefined：（1）变量被声明了，但没有赋值时，就等于undefined。（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。（3）对象没有赋值的属性，该属性的值为undefined。（4）函数没有返回值时，默认返回undefined。null：（1） 作为函数的参数，表示该函数的参数不是对象。（2） 作为对象原型链的终点。 7. new操作符具体干了什么呢?（1）创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。（2）属性和方法被加入到 this 引用的对象中。（3）新创建的对象由 this 所引用，并且最后隐式的返回 this 。 8. JSON 的了解？JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小。格式：采用键值对，例如：{‘age’:’12’, ‘name’:’back’} 9. call() 和 apply() 的区别和作用？apply()函数有两个参数：第一个参数是上下文，第二个参数是参数组成的数组。如果上下文是null，则使用全局对象代替。如：function.apply(this,[1,2,3]);call()的第一个参数是上下文，后续是实例传入的参数序列。如：function.call(this,1,2,3); 10. 如何获取UA？123456function whatBrowser() &#123; document.Browser.Name.value=navigator.appName; document.Browser.Version.value=navigator.appVersion; document.Browser.Code.value=navigator.appCodeName; document.Browser.Agent.value=navigator.userAgent; &#125; 其他1. HTTP状态码知道哪些？100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息200 OK 正常返回信息201 Created 请求成功并且服务器创建了新的资源202 Accepted 服务器已接受请求，但尚未处理301 Moved Permanently 请求的网页已永久移动到新位置。302 Found 临时性重定向。303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。304 Not Modified 自从上次请求后，请求的网页未修改过。400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。401 Unauthorized 请求未授权。403 Forbidden 禁止访问。404 Not Found 找不到如何与 URI 相匹配的资源。500 Internal Server Error 最常见的服务器端错误。503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。 2. 你有哪些性能优化的方法？（1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。（2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数（3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。（4） 当需要设置的样式很多时设置className而不是直接操作style。（5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。（6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。（7） 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。 3. 什么叫优雅降级和渐进增强？优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了,为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效。渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能,向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。 4. 哪些常见操作会造成内存泄漏？内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）。 5. 线程与进程的区别一个程序至少有一个进程,一个进程至少有一个线程。线程的划分尺度小于进程，使得多线程程序的并发性高。另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML5 标签列表]]></title>
      <url>%2F2017%2F04%2F05%2F%E6%A0%87%E7%AD%BE%E5%88%97%E8%A1%A8%2F</url>
      <content type="text"><![CDATA[HTML5 &lt;article&gt; 标签article 标签是 HTML 5 的新标签, article 标签的内容独立于文档的其余部分。HTML5 &lt;canvas&gt; 标签html5 canvas 标签定义图形，比如图表和其他图像。canvas 标签只是图形容器，您必须使用脚本来绘制图形。HTML5 &lt;!--...--&gt; 标签comment 注释标签用于在源文档中插入注释。注释内容不会被浏览器显示。为代码编写注释的好处是，有助于增强代码的可读性。HTML5 &lt;!DOCTYPE&gt; 标签!DOCTYPE 文档声明必须位于 HTML5 文档中的第一行，也就是位于 html 标签之前。该标签告知浏览器文档所使用的 HTML 规范。HTML5 &lt;a&gt; 标签html5 a 标签定义超链接，用于从一个页面链接到另一个页面。a 标签最重要的属性是 href 属性，它指定链接的目标 url 。HTML5 &lt;abbr&gt; 标签abbr 标签最初是在 HTML 4.0 中引入的，表示它所包含的文本是一个更长的单词或短语的缩写形式。HTML5 &lt;address&gt; 标签address 标签定义文档作者或拥有者的联系信息。通常的做法是将 address 元素添加到网页的头部或底部。HTML5 &lt;applet&gt; 标签定义和用法 applet 定义嵌入的 applet。 HTML 5 中不支持 applet 标签 请使用 object 标签代替它。HTML5 &lt;acronym&gt; 标签定义和用法 HTML 5 不支持 acronym 标签。 请使用 abbr 标签代替它。 在 HTML 4.01 中，acronym 标签定义首字母缩略词。 如果首字母缩略词是一个单词，则可以被读出来，例如 NATO、NASA、ASAP、GUI。HTML5 &lt;area&gt; 标签area 元素始终嵌套在 map 标签内部。area 标签定义图像映射内部的区域（图像映射指的是带有可点击区域的图像）。HTML5 &lt;aside&gt; 标签html5 aside 标签定义其所处内容之外的内容。aside 标签的内容应该与附近的内容相关。HTML5 &lt;audio&gt; 标签audio 标签是 HTML 5 的新标签, audio 标签想网页中插入声音，比如音乐或其他音频流。HTML5 &lt;b&gt; 标签html5 b 标签定义粗体的文本。b 标签用于强调某些文本。如果您希望把文本标记为相比其他文本更为重要，应该使用 strong 标签。HTML5 &lt;base&gt; 标签base 标签为页面上的所有链接规定默认地址或默认目标。base 标签必须位于 head 元素内部。HTML5 &lt;basefont&gt; 标签HTML5 中不支持 basefont 标签。请用 CSS 代替。HTML5 &lt;bdi&gt; 标签bdi 标签是 HTML5 中的新标签。bdi 标签允许您设置一段文本，使其脱离其父元素的文本方向设置。HTML5 &lt;bdo&gt; 标签bdo 标签覆盖默认的文本方向。通过设置 dir 属性来设置文本的显示方向。HTML5 &lt;big&gt; 标签HTML5 中不支持 big 标签。请用 CSS 代替HTML5 &lt;blockquote&gt; 标签blockquote 标签之间的所有文本都会从常规文本中分离出来，经常会在左、右两边进行缩进，而且有时会使用斜体。HTML5 &lt;body&gt; 标签body 标签定义文档的主体。 body 标签包含文档的所有内容，比如文本、超链接、图像、表格、列表等。在 HTML 5 中，删除了所有 的特殊属性。HTML5 &lt;br&gt; 标签br 标签插入简单的换行符。br 标签是一个空标签，意味着它没有结束标签。br 标签常用来输出空行HTML5 &lt;button&gt; 标签button 标签定义按钮。您可以在 button 标签内放置内容，比如文本或图像。但是在 form 中通常使用 input 标签创建按钮。HTML5 &lt;caption&gt; 标签caption 标签定义表格的标题。caption 标签必须直接放置到 table 标签之后。通常标题会居中显示在表格上方。HTML5 &lt;center&gt; 标签HTML5 中不支持该 center 标签。请使用 CSS 代替。HTML5 &lt;cite&gt; 标签cite 标签定义作品（比如书籍、歌曲、电影、电视节目、绘画、雕塑等等）的标题，通常斜体显示。HTML5 &lt;code&gt; 标签em,strong,dfn,code,samp,kbd,var,cite 标签常用来格式话文本，使用 css 样式表可以显示更丰富的效果。HTML5 &lt;col&gt; 标签col 标签为表格中的一个或多个列定义属性值。通过使用 col 标签，可以向整个列应用样式，而不需要重复为每个单元格或每一行设置样式。HTML5 &lt;colgroup&gt; 标签通过使用 colgroup 标签，可以向整个列应用样式，而不需要重复为每个单元格或每一行设置样式。只能在 table 元素内使用 colgroup 标签。HTML5 &lt;command&gt; 标签command 元素表示用户能够调用的命令。可以用它规定键盘快捷键。只有当 command 元素位于 menu 元素内时，该元素才是可见的。HTML5 &lt;datalist&gt; 标签datalist 标签定义选项列表。请与 input 元素配合使用该元素，来定义 input 可能的值。HTML5 &lt;dd&gt; 标签dd 标签定义一个定义列表中对项目的描述。dt 标签定义列表中的项目，而 dd&gt; 标签描述这些项目。HTML5 &lt;del&gt; 标签del 标签定义文档中已删除的文本。与 ins 标签一起使用，描述文档中的更新和修正。HTML5 &lt;details&gt; 标签details 标签是 HTML 5 中的新标签。details 标签用于描述文档或文档某个部分的细节。目前只有 Chrome 支持 details 标签。HTML5 &lt;dfn&gt; 标签HTML5 &lt;dir&gt; 标签HTML5 中不支持 dir 标签。请用 CSS 代替。HTML5 &lt;div&gt; 标签div 标签常用于组合块级元素，以便通过样式表来对这些元素进行格式化。通常使用 div + css 对网页进行布局。HTML5 &lt;dl&gt; 标签dl 标签定义一个定义列表。dl 标签内部使用 dd 和 dt 定义列表中的项目。HTML5 &lt;dt&gt; 标签dt 标签定义一个定义列表中的一个项目。dd 标签描述这些项目。HTML5 &lt;em&gt; 标签HTML5 &lt;embed&gt; 标签embed 标签是 HTML 5 中的新标签。embed 标签定义嵌入的内容，比如插件。HTML5 &lt;fieldset&gt; 标签fieldset 标签会在相关表单元素周围绘制边框。fieldset 标签会在相关表单元素周围绘制边框。HTML5 &lt;figcaption&gt; 标签figcaption 标签是 HTML 5 中的新标签。figcaption 标签定义 figure 元素的标题（caption）。HTML5 &lt;figure&gt; 标签figure 标签是 HTML 5 中的新标签。figure 标签规定独立的流内容（图像、图表、照片、代码等等）。HTML5 &lt;font&gt; 标签定义和用法 在 HTML 5 中，不支持 font 标签。请用 CSS 代替它。 font 标签规定文本的字体、大小和颜色。HTML5 &lt;footer&gt; 标签footer 标签是 HTML 5 中的新标签。footer 标签定义 section 或 document 的页脚。HTML5 &lt;form&gt; 标签form 标签标签用于创建供用户输入的 HTML 表单。form 标签包含多个表单元素，如：button,input,keygen,object,output,select,textareaHTML5 &lt;frame&gt; 标签定义和用法 在 HTML 5 中不支持 frame 标签。 frame 标签定义框架集中的子窗口（框架）。 由于该标签对网页可用性的负面影响，在 HTML 5 中 frame 和 frameset 标签没有得到支持。HTML5 &lt;frameset&gt; 标签定义和用法 在 HTML 5 中不支持 frameset 标签。 frameset 标签定义框架集。它用于组织多个窗口（框架）。 由于该标签对网页可用性的负面影响，在 HTML 5 中 frame 和 frameset 标签没有得到支持。HTML5 &lt;h1 - h6&gt; 标签h1,h2,h3,h4,h5,h6 标签用来定义文档中的标题。h1 定义最大的标题。h6 定义最小的标题。HTML5 &lt;head&gt; 标签head 标签是所有头部元素的容器。位于 head 内部的元素可以包含 title,base,link,meta,script,style等。HTML5 &lt;header&gt; 标签header 标签是 HTML 5 中的新标签。header 标签定义文档的页眉（介绍信息）。HTML5 &lt;hgroup&gt; 标签hgroup 标签是 HTML 5 中的新标签。hgroup 标签用于对网页或区段（section）的标题进行组合。HTML5 &lt;hr&gt; 标签在 HTML 5 中，hr 标签定义内容中的主题变化，并显示为一条水平线。在 HTML 4.01 中，hr 标签仅仅显示为一条水平线。HTML5 &lt;html&gt; 标签html 标签告知浏览器这是一个 HTML 文档。html 元素是 HTML 文档中最外层的根元素。HTML5 &lt;i&gt; 标签i 标签定义的文本在 html 文档中呈现为斜体，以便与文档中其余部分区别开来。HTML5 &lt;iframe&gt; 标签iframe 标签创建包含另一个文档的行内框架。在 HTML 5 中，仅仅支持 src 属性。HTML5 &lt;img&gt; 标签img 标签定义 HTML 页面中的图像。img 标签定义 HTML 页面中的图像。img 标签定义 HTML 页面中的图像。HTML5 &lt;input&gt; 标签input 标签规定 form 表单中用户可输入数据的输入字段。根据不同的 type 属性，输入字段可以是文本字段、复选框、密码字段、单选按钮、按钮等。HTML5 &lt;ins&gt; 标签ins 标签定义文档的其余部分之外的插入文本。通常能够与 del 标签一起使用，来描述对文档的更新和修正。HTML5 &lt;keygen&gt; 标签keygen 是 HTML5 中的新元素。keygen 标签规定用于表单的密钥对生成器字段。当提交表单时，私钥存储在本地，公钥发送到服务器。HTML5 &lt;kbd&gt; 标签HTML5 &lt;label&gt; 标签label 标签为 input 元素定义文字标识，label 标签的 for 属性应该等于相关元素的 id 元素，以便将它们捆绑起来。HTML5 &lt;legend&gt; 标签legend 元素为以下元素定义标题（caption）：fieldset、figure、details 。 legend 元素为以下元素定义标题（caption）：fieldset、figure&gt;、details。HTML5 &lt;li&gt; 标签li 标签定义列表项，有序列表 ol 和无序列表 ul 中都使用 li 标签。 HTML 5 中，li 标签不再支持 type 属性。HTML5 &lt;link&gt; 标签link 标签定义文档与外部资源之间的关系。link 标签大多数时候都用来连接 css 样式表。link 标签只能位于head 标签中。HTML5 &lt;map&gt; 标签map 标签用于定义图像中可点击的热点区域。map 标签的 name 属性与 img 标签的 usemap 属性相关联，以创建图像与映射之间的关系HTML5 &lt;mark&gt; 标签mark 标签是 HTML 5 中的新标签。mark 标签定义带有记号的文本。请在需要突出显示文本时使用 mark 标签。HTML5 &lt;menu&gt; 标签menu 标签定义菜单列表。当希望列出表单控件时使用该标签。在 HTML 5 中，重新定义了 menu 元素，且使用用于排列表单控件。HTML5 &lt;meta&gt; 标签meta 标签位于文档的头部 head 标签中，meta 标签的属性用来定义有关页面的元信息，比如 字符集，关键词，描述，重定向等。HTML5 &lt;meter&gt; 标签meter 标签是 HTML 5 中的新标签。meter 标签定义度量的范围，既可以在元素的文本中，也可以在 min/max 属性中定义。HTML5 &lt;nav&gt; 标签nav 标签是 HTML 5 中的新标签。nav 标签定义导航链接的部分。HTML5 &lt;noframes&gt; 标签定义和用法 在 HTML 5 中不支持 noframes 标签。 noframes 标签向浏览器显示无法处理框架的提示文本。HTML5 标签noscript 元素用来定义在脚本未被执行时的替代内容（文本）。此标签用于可识别 script 标签但无法支持其中脚本的浏览器。HTML5 &lt;object&gt; 标签object 定义一个嵌入的对象。请使用此元素向您的 HTML5 页面添加多媒体。HTML5 &lt;ol&gt; 标签ol 标签定义有序列表。在 HTML 5 中，不再支持 compact 和 type 这两个属性HTML5 &lt;optgroup&gt; 标签optgroup 标签定义选项组。此元素允许您组合选项。当您使用一个长的选项列表时，对相关的选项进行组合会使处理更加容易。HTML5 &lt;option&gt; 标签option 标签定义下拉列表中的一个选项。在 HTML 5 中，option 标签也用于新元素 datalist 中。HTML5 &lt;output&gt; 标签output 标签是 HTML 5 中的新标签。output 标签定义不同类型的输出，比如脚本的输出。HTML5 &lt;p&gt; 标签p 标签定义段落。在 HTML 5 中不再支持 p 标签的 align 属性。HTML5 &lt;param&gt; 标签param 标签允许您为插入 XHTML 文档的对象规定 run-time 设置，也就是说，此标签可为包含它的 object 标签提供参数。HTML5 &lt;pre&gt; 标签pre 标签可定义预格式化的文本。pre 标签的一个常见应用就是用来表示计算机的源代码。HTML5 &lt;progress&gt; 标签progress 标签是 HTML 5 中的新标签。progress 标签定义运行中的进度（进程）。HTML5 &lt;q&gt; 标签q 标签定义一个短的引用。浏览器经常会在这种引用的周围插入引号。HTML5 &lt;rp&gt; 标签rp 标签是 HTML 5 的新标签。rp 标签在 ruby 注释中使用，以定义不支持 ruby 元素的浏览器所显示的内容。HTML5 &lt;ruby&gt; 标签ruby 标签是 HTML 5 的新标签。ruby 标签定义 ruby 注释（中文注音或字符）。HTML5 &lt;s&gt; 标签s 标签定义加删除线的文本。HTML 5 中不再支持 s 标签。HTML5 &lt;samp&gt; 标签HTML5 &lt;script&gt; 标签script 标签用于定义客户端脚本，比如 JavaScript。script 元素既可包含脚本语句，也可以通过 src 属性指向外部脚本文件。HTML5 &lt;select&gt; 标签select 标签创建下拉列表。请在 form 元素中使用此标签来接受用户的输入HTML5 &lt;small&gt; 标签在 HTML5 中，small 元素定义旁注信息，并显示为更小的文本。对于由 em 元素强调过的或由 strong 元素标记为重要的文本，small 元素不会取消对文本的强调，也不会降低这些文本的重要性。HTML5 &lt;source&gt; 标签source 标签是 HTML 5 中的新标签。source 标签为媒介元素（比如 video 和 audio）定义媒介资源。HTML5 &lt;span&gt; 标签span 标签用于对文档中的行内元素进行组合,以便通过样式表 css 对它们进行格式化。HTML5 &lt;strike&gt; 标签定义和用法 在 HTML 5 中不支持 strike 标签。请使用 CSS 代替。 strike 标签定义加删除线的文本。请使用 del 标签代替。HTML5 &lt;strong&gt; 标签HTML5 &lt;style&gt; 标签style 标签定义 HTML 文档的样式信息。scoped 属性是 HTML 5 中的新属性，它允许我们为文档的指定部分定义样式，而不是整个文档。HTML5 &lt;sub&gt; 标签sub 标签可定义下标文本。sup 可定义上标文本。HTML5 &lt;summary&gt; 标签summary 标签是 HTML 5 中的新标签。是 details 元素的第一个子元素，定义 details 元素的标题。HTML5 &lt;sup&gt; 标签HTML5 &lt;table&gt; 标签table 标签定义 HTML 表格。一个简单的 HTML 表格包括 table 元素，一个或多个 tr、th 以及 td 元素。HTML5 &lt;tbody&gt; 标签使用 tbody 标签，可以将表格分为一个单独的部分。tbody 标签可将表格中的一行或几行合成一组。在 HTML 5 中，不支持 tbody 标签的任何属性。HTML5 &lt;td&gt; 标签td 标签定义 HTML 表格中的标准单元格。thead 元素中只能使用 th 标签按，不允许使用 td 标签。HTML5 &lt;textarea&gt; 标签textarea 定义一个多行的文本输入区域。文本区中的默认字体是等宽字体 (fixed pitch)。HTML5 &lt;tfoot&gt; 标签tfoot 定义表格的页脚（脚注），tfoot 内部必须拥有 tr 标签！tfoot 表亲必须位于 table 标签内。HTML5 &lt;th&gt; 标签th 标签定义 HTML 表格中的表头单元格。th 元素中的文本呈现为粗体并且居中。th 标签在 tr 标签中定义。HTML5 &lt;thead&gt; 标签thead 标签在 table 标签中使用，定义表格的表头。thead 内部必须拥有 tr 标签！HTML5 &lt;time&gt; 标签time 标签是 HTML 5 中的新标签。time 标签定义公历的时间（24 小时制）或日期，时间和时区偏移是可选的。HTML5 &lt;title&gt; 标签title 位于 head 部分，用来定义文档的标题。title 元素在所有 HTML 文档中是必需且唯一的。HTML5 &lt;tr&gt; 标签tr 标签定义表格中的行，一个 tr 元素包含一个或多个 td 或 th 标签。HTML5 &lt;track&gt; 标签track 标签是 HTML 5 中的新标签。track 标签为诸如 video 元素之类的媒介规定外部字幕文件或其他包含的文版文件。HTML5 &lt;tt&gt; 标签定义和用法 在 HTML 5 中不支持 tt 标签。 tt 标签定义打字机文本。HTML5 &lt;u&gt; 标签在 HTML 5 中不支持 u 标签HTML5 &lt;ul&gt; 标签ul 标签定义无序列表。请使用 CSS 来定义列表的显示样式。HTML5 &lt;var&gt; 标签HTML5 &lt;video&gt; 标签video 标签是 HTML 5 的新标签。video 标签定义视频，比如电影片段或其他视频流。HTML5 &lt;wbr&gt; 标签wbr 标签是 HTML 5 中的新标签。wbr 规定在文本中的何处适合添加换行符。HTML5 &lt;rt&gt; 标签定义和用法 rt 标签定义字符（中文注音或字符）的解释或发音。 ruby 注释是中文注音或字符。 在东亚使用，显示的是东亚字符的发音。 与 ruby 以及 rt 标签一同使用： ruby 元素由一个或多个字符（需要一个解释/发音）和一个提供该信息的 rt 元素组成，还包括可选的 rp 元素，定义当浏览器不支持 ruby 元素时显示的内容。 实例 一个 ruby 注释： ruby漢 rt ㄏㄢˋ /rt/ruby HTML 4.01 与 HTML 5 之间的差异 rt 标签是 HTML 5 的新标HTML5 &lt;section&gt; 标签section 标签是 HTML 5 中的新标签。section 标签定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F03%2F09%2Fhello-world%2F</url>
      <content type="text"><![CDATA[环境准备需要git,Node.js环境 安装hexo利用 npm 命令即可安装。（在任意位置点击鼠标右键，选择Git bash） 1npm install -g hexo 创建hexo文件夹选择存放hexo文件的位置,执行以下指令(Git bash终端下)，Hexo即会自动在目标文件夹建立网站所需要的所有文件。 1hexo init 安装依赖包1npm install 本地查看现在我们已经搭建起本地的hexo博客了，执行以下命令(在hexo文件下)，然后到浏览器输入localhost:4000看看。 12hexo generate #此命令是生成静态页面，不执行该命令也可以hexo server 到此，本地服务以及搭建好了。 打包上传到github如果没有github账户，则需要注册 创建仓库，配置ssh秘钥 注意：Repository name命名规则：你的github账号.github.io (这个一定要这么命名，具体我也不清楚) hexo使用目录结构12345678910├── .deploy #需要部署的文件├── node_modules #Hexo插件├── public #生成的静态网页文件├── scaffolds #模板├── source #博客正文和其他源文件，404、favicon、CNAME├── _drafts #草稿├── _posts #文章,可以用子文件来存放文章├── themes #主题├── _config.yml #全局配置文件└── package.json 配置文件的冒号“:”后面有一个空格repo: 刚刚github创库地址.githexo命令行使用12345678hexo help #查看帮助hexo init #初始化一个目录hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成网页，可以在 public 目录查看整个网站的文件hexo server #本地预览，&apos;Ctrl+C&apos;关闭hexo deploy #部署.deploy目录hexo clean #清除缓存，**强烈建议每次执行命令前先清理缓存，每次部署前先删除 .deploy 文件夹** 简写 1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 编辑文章新建文章1hexo new &quot;标题&quot; 在 _posts 目录下会生成文件 标题.md12345678910title: Hello Worlddate: 2015-07-30 07:56:29 #发表日期，一般不改动categories: hexo #文章文类tags: [hexo,github] #文章标签，多于一项时用这种格式---正文，使用Markdown语法书写编辑完后保存，hexo server 预览hexo部署执行下列指令即可完成部署。 123hexo generatehexo deployhexo deploy问题：Deployer not found: git 1npm install hexo-deployer-git --save 重新deploy即可 图片我这里是使用本地的图片 安装 1npm install hexo-asset-image --save 安装该插件后，每次hexo new 新建博文后，会在该文件同级目录下生成一个和文件同名的文件夹，该文件夹就是用来存放图片的确保你的_config.yml 配置 post_asset_folder: true然后使用1![logo](logo.jpg) 在博文中插入logo.jpg. 来源：http://wuxiaolong.me/2015/07/31/build-blog-by-hexo/http://www.tuicool.com/articles/umEBVfI]]></content>
    </entry>

    
  
  
</search>
