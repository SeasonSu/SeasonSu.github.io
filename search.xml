<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[shell 命令大全]]></title>
      <url>%2F2017%2F04%2F07%2Fshell-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8%2F</url>
      <content type="text"><![CDATA[1.系统信息arch 显示机器的处理器架构(1)uname -m 显示机器的处理器架构(2)uname -r 显示正在使用的内核版本dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI)hdparm -i /dev/hda 罗列一个磁盘的架构特性hdparm -tT /dev/sda 在磁盘上执行测试性读取操作cat /proc/cpuinfo 显示CPU info的信息cat /proc/interrupts 显示中断cat /proc/meminfo 校验内存使用cat /proc/swaps 显示哪些swap被使用cat /proc/version 显示内核的版本cat /proc/net/dev 显示网络适配器及统计cat /proc/mounts 显示已加载的文件系统lspci -tv 罗列 PCI 设备lsusb -tv 显示 USB 设备date 显示系统日期cal 2007 显示2007年的日历表date 041217002007.00 设置日期和时间 - 月日时分年.秒clock -w 将时间修改保存到 BIOS 2.关机 (系统的关机、重启以及登出 )shutdown -h now 关闭系统(1)init 0 关闭系统(2)telinit 0 关闭系统(3)shutdown -h hours:minutes &amp; 按预定时间关闭系统shutdown -c 取消按预定时间关闭系统shutdown -r now 重启(1)reboot 重启(2)logout 注销 3.文件和目录cd /home 进入 ‘/ home’ 目录’cd .. 返回上一级目录cd ../.. 返回上两级目录cd 进入个人的主目录cd ~user1 进入个人的主目录cd - 返回上次所在的目录pwd 显示工作路径ls 查看目录中的文件ls -F 查看目录中的文件ls -l 显示文件和目录的详细资料ls -a 显示隐藏文件ls [0-9] 显示包含数字的文件名和目录名tree 显示文件和目录由根目录开始的树形结构(1)lstree 显示文件和目录由根目录开始的树形结构(2)mkdir dir1 创建一个叫做 ‘dir1’ 的目录’mkdir dir1 dir2 同时创建两个目录mkdir -p /tmp/dir1/dir2 创建一个目录树rm -f file1 删除一个叫做 ‘file1’ 的文件’rmdir dir1 删除一个叫做 ‘dir1’ 的目录’rm -rf dir1 删除一个叫做 ‘dir1’ 的目录并同时删除其内容rm -rf dir1 dir2 同时删除两个目录及它们的内容mv dir1 new_dir 重命名/移动 一个目录cp file1 file2 复制一个文件cp dir/ . 复制一个目录下的所有文件到当前工作目录cp -a /tmp/dir1 . 复制一个目录到当前工作目录cp -a dir1 dir2 复制一个目录ln -s file1 lnk1 创建一个指向文件或目录的软链接ln file1 lnk1 创建一个指向文件或目录的物理链接touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm)file file1 outputs the mime type of the file as texticonv -l 列出已知的编码iconv -f fromEncoding -t toEncoding inputFile &gt; outputFile creates a new from the given input file by assuming it is encoded in fromEncoding and converting it to toEncoding.find . -maxdepth 1 -name .jpg -print -exec convert “{}” -resize 80x60 “thumbs/{}” \; batch resize files in the current directory and send them to a thumbnails directory (requires convert from Imagemagick) 4.文件搜索find / -name file1 从 ‘/‘ 开始进入根文件系统搜索文件和目录find / -user user1 搜索属于用户 ‘user1’ 的文件和目录find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件find / -name *.rpm -exec chmod 755 ‘{}’ \; 搜索以 ‘.rpm’ 结尾的文件并定义其权限find / -xdev -name *.rpm 搜索以 ‘.rpm’ 结尾的文件，忽略光驱、捷盘等可移动设备locate *.ps 寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令whereis halt 显示一个二进制文件、源码或man的位置which halt 显示一个二进制文件或可执行文件的完整路径 5.挂载一个文件系统mount /dev/hda2 /mnt/hda2 挂载一个叫做hda2的盘 - 确定目录 ‘/ mnt/hda2’ 已经存在umount /dev/hda2 卸载一个叫做hda2的盘 - 先从挂载点 ‘/ mnt/hda2’ 退出fuser -km /mnt/hda2 当设备繁忙时强制卸载umount -n /mnt/hda2 运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用mount /dev/fd0 /mnt/floppy 挂载一个软盘mount /dev/cdrom /mnt/cdrom 挂载一个cdrom或dvdrommount /dev/hdc /mnt/cdrecorder 挂载一个cdrw或dvdrommount /dev/hdb /mnt/cdrecorder 挂载一个cdrw或dvdrommount -o loop file.iso /mnt/cdrom 挂载一个文件或ISO镜像文件mount -t vfat /dev/hda5 /mnt/hda5 挂载一个Windows FAT32文件系统mount /dev/sda1 /mnt/usbdisk 挂载一个usb 捷盘或闪存设备mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 挂载一个windows网络共享 6.磁盘空间df -h 显示已经挂载的分区列表ls -lSr |more 以尺寸大小排列文件和目录du -sh dir1 估算目录 ‘dir1’ 已经使用的磁盘空间’du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小rpm -q -a –qf ‘%10{SIZE}t%{NAME}n’ | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统)dpkg-query -W -f=’${Installed-Size;10}t${Package}n’ | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统) 返回顶部索引 ^ 7.用户和群组groupadd group_name 创建一个新用户组groupdel group_name 删除一个用户组groupmod -n new_group_name old_group_name 重命名一个用户组useradd -c “Name Surname “ -g admin -d /home/user1 -s /bin/bash user1 创建一个属于 “admin” 用户组的用户useradd user1 创建一个新用户userdel -r user1 删除一个用户 ( ‘-r’ 排除主目录)usermod -c “User FTP” -g system -d /ftp/user1 -s /bin/nologin user1 修改用户属性passwd 修改口令passwd user1 修改一个用户的口令 (只允许root执行)chage -E 2005-12-31 user1 设置用户口令的失效期限pwck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的用户grpck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的群组newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组 8.文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消ls -lh 显示权限ls /tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限chown user1 file1 改变一个文件的所有人属性chown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性chgrp group1 file1 改变文件的群组chown user1:group1 file1 改变一个文件的所有人和群组属性find / -perm -u+s 罗列一个系统中所有使用了SUID控制的文件chmod u+s /bin/file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限chmod u-s /bin/file1 禁用一个二进制文件的 SUID位chmod g+s /home/public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的chmod g-s /home/public 禁用一个目录的 SGID 位chmod o+t /home/public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件chmod o-t /home/public 禁用一个目录的 STIKY 位 9.文件的特殊属性 - 使用 “+” 设置权限，使用 “-“ 用于取消chattr +a file1 只允许以追加方式读写文件chattr +c file1 允许这个文件能被内核自动压缩/解压chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接chattr +s file1 允许一个文件被安全地删除chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件lsattr 显示特殊的属性 10.打包和压缩文件bunzip2 file1.bz2 解压一个叫做 ‘file1.bz2’的文件bzip2 file1 压缩一个叫做 ‘file1’ 的文件gunzip file1.gz 解压一个叫做 ‘file1.gz’的文件gzip file1 压缩一个叫做 ‘file1’的文件gzip -9 file1 最大程度压缩rar a file1.rar test_file 创建一个叫做 ‘file1.rar’ 的包rar a file1.rar file1 file2 dir1 同时压缩 ‘file1’, ‘file2’ 以及目录 ‘dir1’rar x file1.rar 解压rar包unrar x file1.rar 解压rar包tar -cvf archive.tar file1 创建一个非压缩的 tarballtar -cvf archive.tar file1 file2 dir1 创建一个包含了 ‘file1’, ‘file2’ 以及 ‘dir1’的档案文件tar -tf archive.tar 显示一个包中的内容tar -xvf archive.tar 释放一个包tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包tar -xvfj archive.tar.bz2 解压一个bzip2格式的压缩包tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包tar -xvfz archive.tar.gz 解压一个gzip格式的压缩包zip file1.zip file1 创建一个zip格式的压缩包zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包unzip file1.zip 解压一个zip格式压缩包 11.RPM 包 - （Fedora, Redhat及类似系统）rpm -ivh package.rpm 安装一个rpm包rpm -ivh –nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告rpm -U package.rpm 更新一个rpm包但不改变其配置文件rpm -F package.rpm 更新一个确定已经安装的rpm包rpm -e package_name.rpm 删除一个rpm包rpm -qa 显示系统中所有已经安装的rpm包rpm -qa | grep httpd 显示所有名称中包含 “httpd” 字样的rpm包rpm -qi package_name 获取一个已安装包的特殊信息rpm -qg “System Environment/Daemons” 显示一个组件的rpm包rpm -ql package_name 显示一个已经安装的rpm包提供的文件列表rpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表rpm -q package_name –whatrequires 显示与一个rpm包存在依赖关系的列表rpm -q package_name –whatprovides 显示一个rpm包所占的体积rpm -q package_name –scripts 显示在安装/删除期间所执行的脚本lrpm -q package_name –changelog 显示一个rpm包的修改历史rpm -qf /etc/httpd/conf/httpd.conf 确认所给的文件由哪个rpm包所提供rpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表rpm –import /media/cdrom/RPM-GPG-KEY 导入公钥数字证书rpm –checksig package.rpm 确认一个rpm包的完整性rpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性rpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间rpm -Va 检查系统中所有已安装的rpm包- 小心使用rpm -Vp package.rpm 确认一个rpm包还未安装rpm2cpio package.rpm | cpio –extract –make-directories bin 从一个rpm包运行可执行文件rpm -ivh /usr/src/redhat/RPMS/arch/package.rpm 从一个rpm源码安装一个构建好的包rpmbuild –rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包 12.YUM 软件包升级器 - （Fedora, RedHat及类似系统）yum install package_name 下载并安装一个rpm包yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系yum update package_name.rpm 更新当前系统中所有安装的rpm包yum update package_name 更新一个rpm包yum remove package_name 删除一个rpm包yum list 列出当前系统中安装的所有包yum search package_name 在rpm仓库中搜寻软件包yum clean packages 清理rpm缓存删除下载的包yum clean headers 删除所有头文件yum clean all 删除所有缓存的包和头文件 13.DEB 包 (Debian, Ubuntu 以及类似系统)dpkg -i package.deb 安装/更新一个 deb 包dpkg -r package_name 从系统删除一个 deb 包dpkg -l 显示系统中所有已经安装的 deb 包dpkg -l | grep httpd 显示所有名称中包含 “httpd” 字样的deb包dpkg -s package_name 获得已经安装在系统中一个特殊包的信息dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表dpkg –contents package.deb 显示尚未安装的一个包所提供的文件列表dpkg -S /bin/ping 确认所给的文件由哪个deb包提供 14.APT 软件工具 (Debian, Ubuntu 以及类似系统)apt-get install package_name 安装/更新一个 deb 包apt-cdrom install package_name 从光盘安装/更新一个 deb 包apt-get update 升级列表中的软件包apt-get upgrade 升级所有已安装的软件apt-get remove package_name 从系统删除一个deb包apt-get check 确认依赖的软件仓库正确apt-get clean 从下载的软件包中清理缓存apt-cache search searched-package 返回包含所要搜索字符串的软件包名称 15.查看文件内容cat file1 从第一个字节开始正向查看文件的内容tac file1 从最后一行开始反向查看一个文件的内容more file1 查看一个长文件的内容less file1 类似于 ‘more’ 命令，但是它允许在文件中和正向操作一样的反向操作head -2 file1 查看一个文件的前两行tail -2 file1 查看一个文件的最后两行tail -f /var/log/messages 实时查看被添加到一个文件中的内容 16.文本处理cat file1 file2 … | command &lt;&gt; file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUTcat file1 | command( sed, grep, awk, grep, etc…) &gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中cat file1 | command( sed, grep, awk, grep, etc…) &gt;&gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中grep Aug /var/log/messages 在文件 ‘/var/log/messages’中查找关键词”Aug”grep ^Aug /var/log/messages 在文件 ‘/var/log/messages’中查找以”Aug”开始的词汇grep [0-9] /var/log/messages 选择 ‘/var/log/messages’ 文件中所有包含数字的行grep Aug -R /var/log/ 在目录 ‘/var/log’ 及随后的目录中搜索字符串”Aug”sed ‘s/stringa1/stringa2/g’ example.txt 将example.txt文件中的 “string1” 替换成 “string2”sed ‘/^$/d’ example.txt 从example.txt文件中删除所有空白行sed ‘/ #/d; /^$/d’ example.txt 从example.txt文件中删除所有注释和空白行echo ‘esempio’ | tr ‘[:lower:]’ ‘[:upper:]’ 合并上下单元格内容sed -e ‘1d’ result.txt 从文件example.txt 中排除第一行sed -n ‘/stringa1/p’ 查看只包含词汇 “string1”的行sed -e ‘s/ $//‘ example.txt 删除每一行最后的空白字符sed -e ‘s/stringa1//g’ example.txt 从文档中只删除词汇 “string1” 并保留剩余全部sed -n ‘1,5p;5q’ example.txt 查看从第一行到第5行内容sed -n ‘5p;5q’ example.txt 查看第5行sed -e ‘s/00/0/g’ example.txt 用单个零替换多个零cat -n file1 标示文件的行数cat example.txt | awk ‘NR%2==1’ 删除example.txt文件中的所有偶数行echo a b c | awk ‘{print $1}’ 查看一行第一栏echo a b c | awk ‘{print $1,$3}’ 查看一行的第一和第三栏paste file1 file2 合并两个文件或两栏的内容paste -d ‘+’ file1 file2 合并两个文件或两栏的内容，中间用”+”区分sort file1 file2 排序两个文件的内容sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份)sort file1 file2 | uniq -u 删除交集，留下其他的行sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件)comm -1 file1 file2 比较两个文件的内容只删除 ‘file1’ 所包含的内容comm -2 file1 file2 比较两个文件的内容只删除 ‘file2’ 所包含的内容comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分 17.字符设置和文件格式转换dos2unix filedos.txt fileunix.txt 将一个文本文件的格式从MSDOS转换成UNIXunix2dos fileunix.txt filedos.txt 将一个文本文件的格式从UNIX转换成MSDOSrecode ..HTML &lt; page.txt &gt; page.html 将一个文本文件转换成htmlrecode -l | more 显示所有允许的转换格式 18.文件系统分析badblocks -v /dev/hda1 检查磁盘hda1上的坏磁块fsck /dev/hda1 修复/检查hda1磁盘上linux文件系统的完整性fsck.ext2 /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性e2fsck /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性e2fsck -j /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性fsck.ext3 /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性fsck.vfat /dev/hda1 修复/检查hda1磁盘上fat文件系统的完整性fsck.msdos /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性dosfsck /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性 19.初始化一个文件系统mkfs /dev/hda1 在hda1分区创建一个文件系统mke2fs /dev/hda1 在hda1分区创建一个linux ext2的文件系统mke2fs -j /dev/hda1 在hda1分区创建一个linux ext3(日志型)的文件系统mkfs -t vfat 32 -F /dev/hda1 创建一个 FAT32 文件系统fdformat -n /dev/fd0 格式化一个软盘mkswap /dev/hda3 创建一个swap文件系统 20.SWAP文件系统mkswap /dev/hda3 创建一个swap文件系统swapon /dev/hda3 启用一个新的swap文件系统swapon /dev/hda2 /dev/hdb3 启用两个swap分区 21.备份dump -0aj -f /tmp/home0.bak /home 制作一个 ‘/home’ 目录的完整备份dump -1aj -f /tmp/home0.bak /home 制作一个 ‘/home’ 目录的交互式备份restore -if /tmp/home0.bak 还原一个交互式备份rsync -rogpav –delete /home /tmp 同步两边的目录rsync -rogpav -e ssh –delete /home ip_address:/tmp 通过SSH通道rsyncrsync -az -e ssh –delete ip_addr:/home/public /home/local 通过ssh和压缩将一个远程目录同步到本地目录rsync -az -e ssh –delete /home/local ip_addr:/home/public 通过ssh和压缩将本地目录同步到远程目录dd bs=1M if=/dev/hda | gzip | ssh user@ip_addr ‘dd of=hda.gz’ 通过ssh在远程主机上执行一次备份本地磁盘的操作dd if=/dev/sda of=/tmp/file1 备份磁盘内容到一个文件tar -Puf backup.tar /home/user 执行一次对 ‘/home/user’ 目录的交互式备份操作( cd /tmp/local/ &amp;&amp; tar c . ) | ssh -C user@ip_addr ‘cd /home/share/ &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个目录内容( tar c /home ) | ssh -C user@ip_addr ‘cd /home/backup-home &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个本地目录tar cf - . | (cd /tmp/backup ; tar xf - ) 本地将一个目录复制到另一个地方，保留原有权限及链接find /home/user1 -name ‘.txt’ | xargs cp -av –target-directory=/home/backup/ –parents 从一个目录查找并复制所有以 ‘.txt’ 结尾的文件到另一个目录find /var/log -name ‘.log’ | tar cv –files-from=- | bzip2 &gt; log.tar.bz2 查找所有以 ‘.log’ 结尾的文件并做成一个bzip包dd if=/dev/hda of=/dev/fd0 bs=512 count=1 做一个将 MBR (Master Boot Record)内容复制到软盘的动作dd if=/dev/fd0 of=/dev/hda bs=512 count=1 从已经保存到软盘的备份中恢复MBR内容 22.光盘cdrecord -v gracetime=2 dev=/dev/cdrom -eject blank=fast -force 清空一个可复写的光盘内容mkisofs /dev/cdrom &gt; cd.iso 在磁盘上创建一个光盘的iso镜像文件mkisofs /dev/cdrom | gzip &gt; cd_iso.gz 在磁盘上创建一个压缩了的光盘iso镜像文件mkisofs -J -allow-leading-dots -R -V “Label CD” -iso-level 4 -o ./cd.iso data_cd 创建一个目录的iso镜像文件cdrecord -v dev=/dev/cdrom cd.iso 刻录一个ISO镜像文件gzip -dc cd_iso.gz | cdrecord dev=/dev/cdrom - 刻录一个压缩了的ISO镜像文件mount -o loop cd.iso /mnt/iso 挂载一个ISO镜像文件cd-paranoia -B 从一个CD光盘转录音轨到 wav 文件中cd-paranoia – “-3” 从一个CD光盘转录音轨到 wav 文件中（参数-3）cdrecord –scanbus 扫描总线以识别scsi通道dd if=/dev/hdc | md5sum 校验一个设备的md5sum编码，例如一张 CD 23.网络 - （以太网和WIFI无线）ifconfig eth0 显示一个以太网卡的配置ifup eth0 启用一个 ‘eth0’ 网络设备ifdown eth0 禁用一个 ‘eth0’ 网络设备ifconfig eth0 192.168.1.1 netmask 255.255.255.0 控制IP地址ifconfig eth0 promisc 设置 ‘eth0’ 成混杂模式以嗅探数据包 (sniffing)dhclient eth0 以dhcp模式启用 ‘eth0’route -n show routing tableroute add -net 0/0 gw IP_Gateway configura default gatewayroute add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1 configure static route to reach network ‘192.168.0.0/16’route del 0/0 gw IP_gateway remove static routeecho “1” &gt; /proc/sys/net/ipv4/ip_forward activate ip routinghostname show hostname of systemhost www.example.com lookup hostname to resolve name to ip address and viceversa(1)nslookup www.example.com lookup hostname to resolve name to ip address and viceversa(2)ip link show show link status of all interfacesmii-tool eth0 show link status of ‘eth0’ethtool eth0 show statistics of network card ‘eth0’netstat -tup show all active network connections and their PIDnetstat -tupl show all network services listening on the system and their PIDtcpdump tcp port 80 show all HTTP trafficiwlist scan show wireless networksiwconfig eth1 show configuration of a wireless network cardhostname show hostnamehost www.example.com lookup hostname to resolve name to ip address and viceversanslookup www.example.com lookup hostname to resolve name to ip address and viceversawhois www.example.com lookup on Whois database Microsoft Windows networks (SAMBA)nbtscan ip_addr netbios name resolutionnmblookup -A ip_addr netbios name resolutionsmbclient -L ip_addr/hostname show remote shares of a windows hostsmbget -Rr smb://ip_addr/share like wget can download files from a host windows via smbmount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share mount a windows network share]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CI常用函数]]></title>
      <url>%2F2017%2F04%2F07%2FCI%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%2F</url>
      <content type="text"><![CDATA[选择数据$this-&gt;db-&gt;select();允许你在SQL查询中写 SELECT 部分。$this-&gt;db-&gt;where();$this-&gt;db-&gt;or_where();$this-&gt;db-&gt;where_in();允许你在SQL查询中写 WHERE部分，其余各种where语句请看手册。$this-&gt;db-&gt;get();运行选择查询语句并且返回结果集。可以获取一个表的全部数据。$this-&gt;db-&gt;like();$this-&gt;db-&gt;or_like();$this-&gt;db-&gt;not_like();本函数允许你生成 LIKE 子句，在做查询时非常有用，其余语法请看手册。$this-&gt;db-&gt;order_by();帮助你设置一个 ORDER BY 子句。$this-&gt;db-&gt;group_by();允许你编写查询语句中的 GROUP BY 部分:$this-&gt;db-&gt;distinct();为查询语句添加 “DISTINCT” 关键字:$this-&gt;db-&gt;having();允许你为你的查询语句编写 HAVING 部分。$this-&gt;db-&gt;limit();限制查询所返回的结果数量:$this-&gt;db-&gt;select_max();为你的查询编写一个 “SELECT MAX(field)”。$this-&gt;db-&gt;select_min();为你的查询编写一个 “SELECT MIN(field)” 。$this-&gt;db-&gt;select_avg();为你的查询编写一个 “SELECT AVG(field)” 。$this-&gt;db-&gt;select_sum();为你的查询编写一个 “SELECT SUM(field)” 。$this-&gt;db-&gt;join();允许你编写查询中的JOIN部分。$this-&gt;db-&gt;count_all_results();允许你获得某个特定的Active Record查询所返回的结果数量。可以使用Active Record限制函数，例如 where(), or_where(), like(), or_like() 等等。 插入数据$this-&gt;db-&gt;insert();生成一条基于你所提供的数据的SQL插入字符串并执行查询。你可以向函数传递 数组 或一个 对象。$this-&gt;db-&gt;insert_batch();一次插入多条数据，生成一条基于你所提供的数据的SQL插入字符串并执行查询。你可以向函数传递 数组 或一个 对象。$this-&gt;db-&gt;set();本函数使您能够设置inserts(插入)或updates(更新)值。它可以用来代替那种直接传递数组给插入和更新函数的方式。 更新数据$this-&gt;db-&gt;update();根据你提供的数据生成并执行一条update(更新)语句。你可以将一个数组或者对象传递给本函数。$this-&gt;db-&gt;update_batch();Generates an update string based on the data you supply, and runs the query. You can either pass an array or an object to the function. Here is an example using an array: 删除数据$this-&gt;db-&gt;delete();生成并执行一条DELETE(删除)语句。$this-&gt;db-&gt;empty_table();生成并执行一条DELETE(删除)语句。$this-&gt;db-&gt;truncate();生成并执行一条TRUNCATE(截断)语句。 链式方法 链式方法允许你以连接多个函数的方式简化你的语法。考虑一下这个范例:$this-&gt;db-&gt;select(‘title’)-&gt;from(‘mytable’)-&gt;where(‘id’, $id)-&gt;limit(10, 20);$query = $this-&gt;db-&gt;get();说明: 链式方法只能在PHP 5下面运行。 查询 $this-&gt;db-&gt;query();要提交一个查询，用以下函数：$this-&gt;db-&gt;query(‘YOUR QUERY HERE’);query() 函数以object(对象)的形式返回一个数据库结果集。 当使用 “read” 模式来运行查询时, 你可以使用“显示你的结果集”来显示查询结果; 当使用 “write” 模式来运行查询时, 将会仅根据执行的成功或失败来返回 TRUE 或 FALSE. 转义查询$this-&gt;db-&gt;escape()这个函数将会确定数据类型，以便仅对字符串类型数据进行转义。并且，它也会自动把数据用单引号括起来，所以你不必手动添加单引号，用法如下： $sql = “INSERT INTO table (title) VALUES(“.$this-&gt;db-&gt;escape($title).”)”; 查询辅助函数$this-&gt;db-&gt;insert_id()这个ID号是执行数据插入时的ID。$this-&gt;db-&gt;affected_rows()当执行写入操作（insert,update等）的查询后，显示被影响的行数。$this-&gt;db-&gt;count_all();计算出指定表的总行数并返回。在第一个参数中写入被提交的表名。 生成查询记录集result()该方法执行成功返回一个object 数组，失败则返回一个空数组。result_array()该方法执行成功时将记录集作为关联数组返回。失败时返回空数组。row()该函数将当前请求的第一行数据作为 object 返回。 你可以传递参数(参数是行的索引)以便获得某一行的数据。比如我们要获得第 5 行的数据： $row = $query-&gt;row(4); row_array()功能与 row() 一样, 区别在于该函数返回的是一个数组。除此以外, 我们还可以使用下面的方法通过游标的方式获取记录：$row = $query-&gt;first_row()$row = $query-&gt;last_row()$row = $query-&gt;next_row()$row = $query-&gt;previous_row()默认情况下他们将返回一个 object，同时你也可以传递参数 “array” 以便使用 array 的方式获取数据 $row = $query-&gt;first_row(‘array’)$row = $query-&gt;last_row(‘array’)$row = $query-&gt;next_row(‘array’)$row = $query-&gt;previous_row(‘array’) 结果集辅助函数$query-&gt;num_rows()该函数将会返回当前请求的行数。$query-&gt;num_fields()该函数返回当前请求的字段数（列数）：$query-&gt;free_result()该函数将会释放当前查询所占用的内存并删除其关联的资源标识。 自动连接 “自动连接” 功能将在每个一页面加载时被自动实例化数据库类。要启用“自动连接”，可在application/config/autoload.php中的 library 数组里添加 database：$autoload[‘libraries’] = array(‘database’); 手动连接 如果仅仅是一部分页面要求数据库连接，你可以在你有需要的函数里手工添加如下代码或者在你的类里手工添加以供该类使用。$this-&gt;load-&gt;database(); 连接多数据库 如果你需要同时连接多于一个的数据库，你可以用以下方式来实现：$DB1 = $this-&gt;load-&gt;database(‘group_one’, TRUE);$DB2 = $this-&gt;load-&gt;database(‘group_two’, TRUE); 表数据 $this-&gt;db-&gt;list_tables();返回一个包含当前连接数据库中所有表名称的数组。$this-&gt;db-&gt;table_exists();有时，在对某个表执行操作之前，使用该函数判断指定表是否存在很有用。返回一个布尔值。 数据库工具类 重要提示： 初始化数据库工具类之前，你的数据库驱动必须已经运行,因为工具类依赖于此。加载工具类： $this-&gt;load-&gt;dbutil()一旦初始化完毕，你可以通过 $this-&gt;dbutil 对象来访问成员函数：$this-&gt;dbutil-&gt;list_databases()$this-&gt;dbutil-&gt;database_exists();$this-&gt;dbutil-&gt;xml_from_result($db_result)$this-&gt;dbutil-&gt;backup() 数据库缓存类 激活缓存需要三步：1、在服务器上创建一个可写的目录以便保存缓存文件。2、在文件 application/config/database.php 中$db[‘xxxx’][‘cachedir’]设置其目录。3、激活缓存特性，可以在文件 application/config/database.php 中设置全局选项$db[‘xxxx’][‘cache_on’]=’TRUE’，也可以用以本页下面的方法手动设置。一旦被激活，每一次含有数据库查询的页面被加载时缓存就会自动发生。 当有数据库更新，我们需要删除缓存文件$this-&gt;db-&gt;cache_delete()删除缓存文件与特定网页。如果你需要清除缓存后，更新您的数据库$this-&gt;db-&gt;cache_delete(‘/blog’, ‘comments’);注意，手册上写的是 $this-&gt;db-&gt;cache_delete(‘blog’, ‘comments’);但根据实际测试应该在控制器名字前加斜杠’/‘才能正确执行。$this-&gt;db-&gt;cache_delete_all()清除所有所有的缓存文件。 数据库维护类 注意: 欲初始化数据库维护类，请确保你的数据库驱动已经运行，因为该类依赖于数据库驱动。使用如下方法载入数据库维护类:$this-&gt;load-&gt;dbforge()一旦初始化，就可以使用$this-&gt;dbforge 对象访问类中函数:$this-&gt;dbforge-&gt;create_database(‘db_name’)允许你创建由第一个参数指定的数据库。$this-&gt;dbforge-&gt;drop_database(‘db_name’)允许你删除由第一个参数指定的数据库。$this-&gt;dbforge-&gt;create_table(‘table_name’);声明了字段和键之后，你就可以创建一个表。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端知识点2]]></title>
      <url>%2F2017%2F04%2F07%2F%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B92%2F</url>
      <content type="text"><![CDATA[1,将url的查询参数解析成字典对象这个题目不约而同的出现在了多家公司的面试题中，当然也是因为太过于典型，解决方案无非就是拆字符或者用正则匹配来解决，我个人强烈建议用正则匹配，因为url允许用户随意输入，如果用拆字符的方式，有任何一处没有考虑到容错，就会导致整个js都报错。而正则就没有这个问题，他只匹配出正确的配对，非法的全部过滤掉，简单，方便。实现代码：123456789101112131415function getQueryObject(url) &#123; url = url == null ? window.location.href : url; var search = url.substring(url.lastIndexOf(&quot;?&quot;) + 1); var obj = &#123;&#125;; var reg = /([^?&amp;=]+)=([^?&amp;=]*)/g; search.replace(reg, function (rs, $1, $2) &#123; var name = decodeURIComponent($1); var val = decodeURIComponent($2); val = String(val); obj[name] = val; return rs; &#125;); return obj;&#125;getQueryObject(&quot;http://www.cnblogs.com/leee/p/4456840.html?name=1&amp;dd=ddd**&quot;) Object {name: &quot;1&quot;, dd: &quot;ddd**&quot;} 2.console.log(1+ +”2”);输出的是3等同于: 1+(+’2’)：+’2’ 的 + 是一元操作符，对 ‘2’ 进行Number()操作，转为数字的2，所以等于312console.log(&quot;A&quot;-&quot;B&quot;+&quot;2&quot;) NaN2console.log(&quot;A&quot;-&quot;B&quot;+2) NaN 3. 算法12345678910function test(a,b)&#123; console.log(b); return&#123; test:function(x)&#123; return test(x,a); &#125; &#125; &#125; var a=test(0);a.test(1);a.test(2);a.test(3); // underfined 0 0 0 4. 三次握手第一次第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。 第二次第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。完成三次握手，客户端与服务器开始传送数据，在上述过程中，还有一些重要的概念： 5. http 状态码一、HTTP状态码如果某项请求发送到您的服务器要求显示您网站上的某个网页（例如，用户通过浏览器访问您的网页或 Googlebot 抓取网页时），服务器将会返回 HTTP 状态代码以响应请求。 此状态代码提供关于请求状态的信息， 告诉 Googlebot 关于您的网站和请求的网页的信息。一些常见的状态代码包括：200 – 服务器成功返回网页404 – 请求的网页不存在503 – 服务器暂时不可用 下面提供 HTTP 状态代码的完整列表。 点击链接可了解详情。 您也可以访问有关 HTTP 状态代码的 W3C 网页以获得更多信息 。 1xx：请求收到，继续处理2xx：操作成功收到，分析、接受3xx：完成此请求必须进一步处理4xx：请求包含一个错误语法或不能完成5xx：服务器执行一个完全有效请求失败1xx （临时响应）表示临时响应并需要请求者继续执行操作的状态代码。 代码 说明100（继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。101（切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。 2xx （成功）表示服务器成功处理了请求的状态代码。 代码 说明200（成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。 如果针对您的 robots.txt 文件显示此状态，则表示 Googlebot 已成功检索到该文件。201（已创建） 请求成功并且服务器创建了新的资源。202（已接受） 服务器已接受请求，但尚未处理。203（非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。204（无内容） 服务器成功处理了请求，但没有返回任何内容。205（重置内容） 服务器成功处理了请求，但没有返回任何内容。 与 204 响应不同，此响应要求请求者重置文档视图（例如，清除表单内容以输入新内容）。206（部分内容） 服务器成功处理了部分 GET 请求。 3xx （重定向）要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。 Google 建议您在每次请求中使用重定向不要超过 5 次。 您可以使用网站管理员工具查看一下 Googlebot 在抓取重定向网页时是否遇到问题。 诊断 下的网 络抓取 页面列出了由于重定向错误而导致 Googlebot 无法抓取的网址。 代码 说明300（多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者（用户代理）选择一项操作，或提供操作列表供请求者选择。301（永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。 您应使用此代码告诉 Googlebot 某个网页或网站已永久移动到新位置。302（暂时移动） 服 务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 此代码与响应 GET 或 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个网页或网站已经移动，因为 Googlebot 会继续抓取原有位置并编入索引。303（查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。 对于除 HEAD 之外的所有请求，服务器会自动转到其他位置。304（未修改） 自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。如果网页自请求者上次请求后再也没有更改 过，您应当将服务器配置为返回此响应（称为 If-Modified-Since HTTP 标头）。 由于服务器可以告诉 Googlebot 自从上次抓取后网页没有更改过，因此可节省带宽和开销。305（使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。307（暂时重定向） 服 务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个页面或网站已经移动，因为 Googlebot 会继续抓取原有位置并编入索引。 4xx（请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。 代码 说明400（错误请求） 服务器不理解请求的语法。401（未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。403（禁止） 服务器拒绝请求。 如果您看到 Googlebot 在尝试抓取您网站上的有效网页时收到此状态代码（可以在 Google 网站管理员工具诊 断 下的网络抓取 页面上看到此信息），可能是您的服务器或主机拒绝 Googlebot 访问。404（未找到） 服务器找不到请求的网页。 例如，如果请求服务器上不存在的网页，服务器通常会返回此代码。如果您的网站上没有 robots.txt 文件，而您在 Google 网站管理员工具”诊断”标签的 robots.txt 页 上看到此状态，那么这是正确的状态。 但是，如果您有 robots.txt 文件而又看到此状态，则说明您的 robots.txt 文件可能命名错误或位于错误的位置 （该文件应当位于顶级域名，名为 robots.txt）。如果您看到有关 Googlebot 尝试抓取的网址的此状态（在”诊断”标签的 HTTP 错误页上），则表示 Googlebot 追踪的可能是另一个页面的无效链接（是旧链接或输入有误的链接）。405（禁用的方法） 禁用请求中指定的方法。406（不可接受） 无法使用请求的内容特性响应请求的网页。407（需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。 如果服务器返回此响应，还会指明请求者应当使用的代理。408（请求超时） 服务器等候请求时发生超时。409（冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 服务器在响应与前一个请求相冲突的 PUT 请求时可能会返回此代码，同时会附上两个请求的差异列表。410（已删除） 如果请求的资源已永久删除，服务器就会返回此响应。 该代码与 404（未找到）代码相似，但在资源以前存在而现在不存在的情况下，有时会用来替代 404 代码。 如果资源已永久删除，您应当使用 301 指定资源的新位置。411（需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。412（未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。413（请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。414（请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。415（不支持的媒体类型） 请求的格式不受请求页面的支持。416（请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。417（未满足期望要求） 服务器未满足”期望”请求标头字段的要求。 5xx （服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。 代码 说明500（服务器内部错误） 服务器遇到错误，无法完成请求。501（尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。502（错误网关） 服务器充当网关或代理，从上游服务器收到无效响应。503（服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。504（网关超时） 服务器充当网关或代理，但没有及时从上游服务器收到请求。505（HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。 HTML+CSS1.对WEB标准以及W3C的理解与认识标签闭合、标签小写、不乱嵌套、提高搜索机器人搜索几率、使用外 链css和js脚本、结构行为表现的分离、文件下载与页面速度更快、内容能被更多的用户所访问、内容能被更广泛的设备所访问、更少的代码和组件，容易维 护、改版方便，不需要变动页面内容、提供打印版本而不需要复制内容、提高网站易用性； 2.xhtml和html有什么区别HTML是一种基本的WEB网页设计语言，XHTML是一个基于XML的置标语言最主要的不同：XHTML 元素必须被正确地嵌套。XHTML 元素必须被关闭。标签名必须用小写字母。XHTML 文档必须拥有根元素。 3.Doctype? 严格模式与混杂模式-如何触发这两种模式，区分它们有何意义?用于声明文档使用那种规范（html/Xhtml）一般为 严格 过度 基于框架的html文档加入XMl声明可触发，解析方式更改为IE5.5 拥有IE5.5的bug 4.行内元素有哪些?块级元素有哪些?CSS的盒模型?块级元素：div p h1 h2 h3 h4 form ul行内元素: a b br i span input selectCss盒模型:内容，border ,margin，padding 5.CSS引入的方式有哪些? link和@import的区别是?内联 内嵌 外链 导入区别 ：同时加载前者无兼容性，后者CSS2.1以下浏览器不支持Link 支持使用javascript改变样式，后者不可 6.CSS选择符有哪些?哪些属性可以继承?优先级算法如何计算?内联和important哪个优先级高?标签选择符 类选择符 id选择符继承不如指定 Id&gt;class&gt;标签选择后者优先级高 7.前端页面有哪三层构成，分别是什么?作用是什么?结构层 Html 表示层 CSS 行为层 js 8.css的基本语句构成是?选择器{属性1:值1;属性2:值2;……} 9.你做的页面在哪些流览器测试过?这些浏览器的内核分别是什么?Ie(Ie内核) 火狐（Gecko） 谷歌（webkit） opear(Presto) 10.写出几种IE6 BUG的解决方法1.双边距BUG float引起的 使用display2.3像素问题 使用float引起的 使用dislpay:inline -3px3.超链接hover 点击后失效 使用正确的书写顺序 link visited hover active4.Ie z-index问题 给父级添加position:relative5.Png 透明 使用js代码 改6.Min-height 最小高度 ！Important 解决’7.select 在ie6下遮盖 使用iframe嵌套8.为什么没有办法定义1px左右的宽度容器（IE6默认的行高造成的，使用over:hidden,zoom:0.08 line-height:1px） 11.标签上title与alt属性的区别是什么?Alt 当图片不显示是 用文字代表。Title 为该属性提供信息 12.描述css reset的作用和用途。Reset重置浏览器的css默认属性 浏览器的品种不同，样式不同，然后重置，让他们统一 13.解释css sprites，如何使用。Css 精灵 把一堆小的图片整合到一张大的图片上，减轻服务器对图片的请求数量 14.浏览器标准模式和怪异模式之间的区别是什么?盒子模型 渲染模式的不同使用 window.top.document.compatMode 可显示为什么模式 15.你如何对网站的文件和资源进行优化?期待的解决方案包括：文件合并文件最小化/文件压缩使用CDN托管缓存的使用 16.什么是语义化的HTML?直观的认识标签 对于搜索引擎的抓取有好处 17.清除浮动的几种方式，各自的优缺点1.使用空标签清除浮动 clear:both（理论上能清楚任何标签，，，增加无意义的标签）2.使用overflow:auto（空标签元素清除浮动而不得不增加无意代码的弊端,,使用zoom:1用于兼容IE）3.是用afert伪元素清除浮动(用于非IE浏览器) Javascript1.javascript的typeof返回哪些数据类型Object number function boolean underfind 2.例举3种强制类型转换和2种隐式类型转换?强制（parseInt,parseFloat,number）隐式（== – ===） 3.split() join() 的区别前者是切割成数组的形式，后者是将数组转换成字符串 4.数组方法pop() push() unshift() shift()Push()尾部添加 pop()尾部删除Unshift()头部添加 shift()头部删除 5.事件绑定和普通事件有什么区别6.IE和DOM事件流的区别1.执行顺序不一样、2.参数不一样3.事件加不加on4.this指向问题 7.IE和标准下有哪些兼容性的写法Var ev = ev || window.eventdocument.documentElement.clientWidth || document.body.clientWidthVar target = ev.srcElement||ev.target 8.ajax请求的时候get 和post方式的区别一个在url后面 一个放在虚拟载体里面有大小限制安全问题应用不同 一个是论坛等只需要请求的，一个是类似修改密码的 9.call和apply的区别Object.call(this,obj1,obj2,obj3)Object.apply(this,arguments)obj.call(thisObj, arg1, arg2, …);obj.apply(thisObj, [arg1, arg2, …]);两者作用一致，都是把obj(即this)绑定到thisObj，这时候thisObj具备了obj的属性和方法。或者说thisObj『继承』了obj的属性和方法。唯一区别是apply接受的是数组参数，call接受的是连续参数。1234567function add(j, k)&#123; return j+k;&#125;function sub(j, k)&#123; return j-k;&#125; 我们在控制台运行：1234567add(5,3); //8add.call(sub, 5, 3); //8add.apply(sub, [5, 3]); //8sub(5, 3); //2sub.call(add, 5, 3); //2sub.apply(add, [5, 3]); //2 10.ajax请求时，如何解释json数据使用eval parse 鉴于安全性考虑 使用parse更靠谱11.b继承a的方法 12.写一个获取非行间样式的函数123456789101112131415161718function getStyle(obj,attr,value)&#123;if(!value)&#123;if(obj.currentStyle)&#123;return obj.currentStyle(attr)&#125;else&#123;obj.getComputedStyle(attr,false)&#125;&#125;else&#123;obj.style[attr]=value&#125;&#125; 13.事件委托是什么让利用事件冒泡的原理，让自己的所触发的事件，让他的父元素代替执行！http://www.webasily.com/?p=78 例子可见此链接 14.闭包是什么，有什么特性，对页面有什么影响闭包就是能够读取其他函数内部变量的函数。http://blog.csdn.net/gaoshanwudi/article/details/7355794 此链接可查看（问这个问题的不是一个公司） 15.如何阻止事件冒泡和默认事件canceBubble return false 16.添加 删除 替换 插入到某个接点的方法obj.appendChidl()obj.innersetBeforeobj.replaceChildobj.removeChild 17.解释jsonp的原理，以及为什么不是真正的ajax动态创建script标签，回调函数Ajax是页面无刷新请求数据操作 18.javascript的本地对象，内置对象和宿主对象本地对象为array obj regexp等可以new实例化内置对象为gload Math 等不可以实例化的宿主为浏览器自带的document,window 等 19.document load 和document ready的区别Document.onload 是在结构和样式加载完才执行jsDocument.ready原生种没有这个方法，jquery中有 $().ready(function) 20.”==”和“===”的不同前者会自动转换类型后者不会 21.javascript的同源策略一段脚本只能读取来自于同一来源的窗口和文档的属性，这里的同一来源指的是主机名、协议和端口号的组合 22.编写一个数组去重的方法function oSort(arr){ var result ={}; var newArr=[];for(var i=0;i&lt;arr.length;i++){ if(!result[arr]) { newArr.push(arr) result[arr]=1 }}return newArr} 23.cookie sessionstorage localstoragecookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。Web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者。Web Storage 的 api 接口使用更方便。24.split var str=”How are you doing today?” document.write(str.split(“ “) + ““)document.write(str.split(“”) + ““)document.write(str.split(“ “,3)) 输出：How,are,you,doing,today?H,o,w, ,a,r,e, ,y,o,u, ,d,o,i,n,g, ,t,o,d,a,y,?How,are,you 25. 对象创建过程1.分配空间。要注意的是，分配空间不光是分配子类的空间，子类对象中包含的父类对象所需要的空间，一样在这一步统一分配。在分配的空间的时候，会把所有的属性设置为默认值。 2.递归的构造父类对象。 3.初始化本类属性。 4.调用本类的构造方法。 总结一下，创建B类对象的步骤一共有5步 1.分配空间 2.初始化A类属性。 3.调用A类的构造方法. 4.初始化B的属性。 5.调用B的构造方法。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[跨域]]></title>
      <url>%2F2017%2F04%2F06%2F%E8%B7%A8%E5%9F%9F%2F</url>
      <content type="text"><![CDATA[什么是跨域JavaScript出于安全方面的考虑，不允许跨域调用其他页面的对象。但在安全限制的同时也给注入iframe或是ajax应用上带来了不少麻烦。这里把涉及到跨域的一些问题简单地整理一下：首先什么是跨域，简单地理解就是因为JavaScript同源策略的限制，a.com 域名下的js无法操作b.com或是c.a.com域名下的对象。更详细的说明可以看下表： 特别注意两点： 第一，如果是协议和端口造成的跨域问题“前台”是无能为力的，第二：在跨域问题上，域仅仅是通过“URL的首部”来识别而不会去尝试判断相同的ip地址对应着两个域或两个域是否在同一个ip上。“URL的首部”指window.location.protocol +window.location.host，也可以理解为“Domains, protocols and ports must match”。接下来简单地总结一下在“前台”一般处理跨域的办法，后台proxy这种方案牵涉到后台配置，这里就不阐述了，有兴趣的可以看看yahoo的这篇文章：《JavaScript: Use a Web Proxy for Cross-Domain XMLHttpRequest Calls》 1、document.domain+iframe的设置对于主域相同而子域不同的例子，可以通过设置document.domain的办法来解决。 具体的做法是可以在http://www.a.com/a.html和http://script.a.com/b.html两个文件中分别加上 document.domain = ‘a.com’；然后通过a.html文件中创建一个iframe，去控制iframe的contentDocument，这样两个js文件之间就可以 “交互”了。当然这种办法只能解决主域相同而二级域名不同的情况，如果你异想天开的把script.a.com的domian设为alibaba.com 那显然是会报错地！代码如下： www.a.com上的a.html12345678910document.domain = &apos;a.com&apos;;var ifr = document.createElement(&apos;iframe&apos;);ifr.src = &apos;http://script.a.com/b.html&apos;;ifr.style.display = &apos;none&apos;;document.body.appendChild(ifr);ifr.onload = function()&#123; var doc = ifr.contentDocument || ifr.contentWindow.document; // 在这里操纵b.html alert(doc.getElementsByTagName(&quot;h1&quot;)[0].childNodes[0].nodeValue);&#125;; script.a.com上的b.htmldocument.domain = ‘a.com’; 这种方式适用于{www.kuqin.com, kuqin.com, script.kuqin.com, css.kuqin.com}中的任何页面相互通信。 备注：某一页面的domain默认等于window.location.hostname。主域名是不带www的域名，例如a.com，主域名前面带前缀的通常都为二级域名或多级域名，例如www.a.com其实是二级域名。 domain只能设置为主域名，不可以在b.a.com中将domain设置为c.a.com。 问题： 1、安全性，当一个站点（b.a.com）被攻击后，另一个站点（c.a.com）会引起安全漏洞。2、如果一个页面中引入多个iframe，要想能够操作所有iframe，必须都得设置相同domain。 2、动态创建script虽然浏览器默认禁止了跨域访问，但并不禁止在页面中引用其他域的JS文件，并可以自由执行引入的JS文件中的function（包括操作cookie、Dom等等）。根据这一点，可以方便地通过创建script节点的方法来实现完全跨域的通信。具体的做法可以参考YUI的Get Utility 这里判断script节点加载完毕还是蛮有意思的：ie只能通过script的readystatechange属性，其它浏览器是script的load事件。以下是部分判断script加载完毕的方法。123456js.onload = js.onreadystatechange = function() &#123; if (!this.readyState || this.readyState === &apos;loaded&apos; || this.readyState === &apos;complete&apos;) &#123; // callback在此处执行 js.onload = js.onreadystatechange = null; &#125;&#125;; 3、利用iframe和location.hash这个办法比较绕，但是可以解决完全跨域情况下的脚步置换问题。原理是利用location.hash来进行传值。在url： http://a.com#helloword中的‘#helloworld’就是location.hash，改变hash并不会导致页面刷新，所以可 以利用hash值来进行数据传递，当然数据容量是有限的。假设域名a.com下的文件cs1.html要和cnblogs.com域名下的 cs2.html传递信息，cs1.html首先创建自动创建一个隐藏的iframe，iframe的src指向cnblogs.com域名下的 cs2.html页面，这时的hash值可以做参数传递用。cs2.html响应请求后再将通过修改cs1.html的hash值来传递数据（由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于a.com域名下的一个代理iframe；Firefox可以修改）。同时在cs1.html上加一个定时器，隔一段时间来判断location.hash的值有没有变化，一点有变化则获取获取hash值。代码如下： 先是a.com下的文件cs1.html文件：12345678910111213141516function startRequest()&#123; var ifr = document.createElement(&apos;iframe&apos;); ifr.style.display = &apos;none&apos;; ifr.src = &apos;http://www.cnblogs.com/lab/cscript/cs2.html#paramdo&apos;; document.body.appendChild(ifr);&#125;function checkHash() &#123; try &#123; var data = location.hash ? location.hash.substring(1) : &apos;&apos;; if (console.log) &#123; console.log(&apos;Now the data is &apos;+data); &#125; &#125; catch(e) &#123;&#125;;&#125;setInterval(checkHash, 2000); cnblogs.com域名下的cs2.html:12345678910111213141516171819202122//模拟一个简单的参数处理操作switch(location.hash)&#123; case &apos;#paramdo&apos;: callBack(); break; case &apos;#paramset&apos;: //do something…… break;&#125;function callBack()&#123; try &#123; parent.location.hash = &apos;somedata&apos;; &#125; catch (e) &#123; // ie、chrome的安全机制无法修改parent.location.hash， // 所以要利用一个中间的cnblogs域下的代理iframe var ifrproxy = document.createElement(&apos;iframe&apos;); ifrproxy.style.display = &apos;none&apos;; ifrproxy.src = &apos;http://a.com/test/cscript/cs3.html#somedata&apos;; // 注意该文件在&quot;a.com&quot;域下 document.body.appendChild(ifrproxy); &#125;&#125; a.com下的域名cs3.html //因为parent.parent和自身属于同一个域，所以可以改变其location.hash的值parent.parent.location.hash = self.location.hash.substring(1); 当然这样做也存在很多缺点，诸如数据直接暴露在了url中，数据容量和类型都有限等…… 4、window.name实现的跨域数据传输文章较长列在此处不便于阅读，详细请看 window.name实现的跨域数据传输（http://www.cnblogs.com/rainman/archive/2011/02/21/1960044.html）。 5、使用HTML5 postMessageHTML5中最酷的新功能之一就是 跨文档消息传输Cross Document Messaging。 下一代浏览器都将支持这个功能：Chrome 2.0+、Internet Explorer 8.0+, Firefox 3.0+, Opera 9.6+, 和 Safari 4.0+ 。 Facebook已经使用了这个功能，用postMessage支持基于web的实时消息传递。 otherWindow.postMessage(message, targetOrigin);otherWindow: 对接收信息页面的window的引用。可以是页面中iframe的contentWindow属性；window.open的返回值；通过name或下标从window.frames取到的值。message: 所要发送的数据，string类型。targetOrigin: 用于限制otherWindow，“*”表示不作限制a.com/index.html中的代码：1234567891011&lt;iframe id=&quot;ifr&quot; src=&quot;b.com/index.html&quot;&gt;&lt;/iframe&gt;&lt;script type=&quot;text/javascript&quot;&gt;window.onload = function() &#123; var ifr = document.getElementById(&apos;ifr&apos;); var targetOrigin = &apos;http://b.com&apos;; // 若写成&apos;http://b.com/c/proxy.html&apos;效果一样 // 若写成&apos;http://c.com&apos;就不会执行postMessage了 ifr.contentWindow.postMessage(&apos;I was there!&apos;, targetOrigin);&#125;;&lt;/script&gt;b.co```m/index.html中的代码： 12345678910&lt;script type=&quot;text/javascript&quot;&gt; window.addEventListener(&apos;message&apos;, function(event)&#123; // 通过origin属性判断消息来源地址 if (event.origin == &apos;http://a.com&apos;) &#123; alert(event.data); // 弹出&quot;I was there!&quot; alert(event.source); // 对a.com、index.html中window对象的引用 // 但由于同源策略，这里event.source不可以访问window对象 &#125; &#125;, false);&lt;/script&gt; 参考文章：《精通HTML5编程》第五章——跨文档消息机制、https://developer.mozilla.org/en/dom/window.postmessage 6、利用flash这是从YUI3的IO组件中看到的办法，具体可见http://developer.yahoo.com/yui/3/io/。可以看在Adobe Developer Connection看到更多的跨域代理文件规范：ross-Domain Policy File Specifications、HTTP Headers Blacklist。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端知识点1]]></title>
      <url>%2F2017%2F04%2F06%2F%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B91%2F</url>
      <content type="text"><![CDATA[1. 常用那几种浏览器测试？有哪些内核(Layout Engine)?(Q1) 浏览器：IE，Chrome，FireFox，Safari，Opera。(Q2) 内核：Trident，Gecko，Presto，Webkit。 2. 说下行内元素和块级元素的区别？行内块元素的兼容性使用？（IE8 以下）(Q1) 行内元素：会在水平方向排列，不能包含块级元素，设置width无效，height无效(可以设置line-height)，margin上下无效，padding上下无效。 块级元素：各占据一行，垂直方向排列。从新行开始结束接着一个断行。 (Q2)兼容性：display:inline-block;display:inline;zoom:1; 3. 清除浮动有哪些方式？比较好的方式是哪一种？(Q1)（1）父级div定义height。（2）结尾处加空div标签clear:both。（3）父级div定义伪类:after和zoom。（4）父级div定义overflow:hidden。（5）父级div定义overflow:auto。（6）父级div也浮动，需要定义宽度。（7）父级div定义display:table。（8）结尾处加br标签clear:both。 (Q2) 比较好的是第3种方式，好多网站都这么用。 4. box-sizing常用的属性有哪些？分别有什么作用？(Q1)box-sizing: content-box|border-box|inherit; (Q2)content-box:宽度和高度分别应用到元素的内容框。在宽度和高度之外绘制元素的内边距和边框(元素默认效果)。border-box:元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。 5. Doctype作用？标准模式与兼容模式各有什么区别?(Q1) &lt;!DOCTYPE&gt;告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。 (Q2) 标准模式的排版和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。 6. HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;？HTML5不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）。 而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。 7. 页面导入样式时，使用link和@import有什么区别？（1）link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS;（2）页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;（3）import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题。 8. 介绍一下你对浏览器内核的理解？主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。 渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、我们组建一大牛裙前面是4七一，整理讯息（例如加入CSS等），中间是零2七，以及计算网页的显示方式，后面是壹武四，是学习的就加，不是学习的请勿打扰。然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。 JS引擎则：解析和执行javascript来实现网页的动态效果。 最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。 9. html5有哪些新特性？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？(Q1)HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。(1)绘画 canvas;(2)用于媒介回放的 video 和 audio 元素;(3)本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;(4)sessionStorage 的数据在浏览器关闭后自动删除;(5)语意化更好的内容元素，比如 article、footer、header、nav、section;(6)表单控件，calendar、date、time、email、url、search;(7)新的技术webworker, websocket, Geolocation; (Q2)IE8/IE7/IE6支持通过document.createElement方法产生的标签，可以利用这一特性让这些浏览器支持HTML5新标签，浏览器支持新标签后，还需要添加标签默认的样式。当然也可以直接使用成熟的框架、比如html5shim， &lt; !–[if lt IE 9]&gt;&lt; ![endif]–&gt; 10. 简述一下你对HTML语义化的理解？用正确的标签做正确的事情。 html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的;搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO;使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。 JavaScript1. 介绍js的基本数据类型Undefined、Null、Boolean、Number、String 2. js有哪些内置对象？数据封装类对象：Object、Array、Boolean、Number 和 String其他对象：Function、Arguments、Math、Date、RegExp、Error 3. this对象的理解this总是指向函数的直接调用者（而非间接调用者）；如果有new关键字，this指向new出来的那个对象；在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window。 4. eval是做什么的？它的功能是把对应的字符串解析成JS代码并运行；应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval(‘(‘+ str +’)’)。 5. DOM怎样添加、移除、移动、复制、创建和查找节点// 创建新节点123createDocumentFragment() //创建一个DOM片段createElement() //创建一个具体的元素createTextNode() //创建一个文本节点 // 添加、移除、替换、插入1234appendChild()removeChild()replaceChild()insertBefore() //在已有的子节点前插入一个新的子节点 // 查找123getElementsByTagName() //通过标签名称getElementsByName() //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)getElementById() //通过元素Id，唯一性 6. null和undefined的区别？null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。undefined：（1）变量被声明了，但没有赋值时，就等于undefined。（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。（3）对象没有赋值的属性，该属性的值为undefined。（4）函数没有返回值时，默认返回undefined。null：（1） 作为函数的参数，表示该函数的参数不是对象。（2） 作为对象原型链的终点。 7. new操作符具体干了什么呢?（1）创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。（2）属性和方法被加入到 this 引用的对象中。（3）新创建的对象由 this 所引用，并且最后隐式的返回 this 。 8. JSON 的了解？JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小。格式：采用键值对，例如：{‘age’:’12’, ‘name’:’back’} 9. call() 和 apply() 的区别和作用？apply()函数有两个参数：第一个参数是上下文，第二个参数是参数组成的数组。如果上下文是null，则使用全局对象代替。如：function.apply(this,[1,2,3]);call()的第一个参数是上下文，后续是实例传入的参数序列。如：function.call(this,1,2,3); 10. 如何获取UA？123456function whatBrowser() &#123; document.Browser.Name.value=navigator.appName; document.Browser.Version.value=navigator.appVersion; document.Browser.Code.value=navigator.appCodeName; document.Browser.Agent.value=navigator.userAgent; &#125; 其他1. HTTP状态码知道哪些？100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息200 OK 正常返回信息201 Created 请求成功并且服务器创建了新的资源202 Accepted 服务器已接受请求，但尚未处理301 Moved Permanently 请求的网页已永久移动到新位置。302 Found 临时性重定向。303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。304 Not Modified 自从上次请求后，请求的网页未修改过。400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。401 Unauthorized 请求未授权。403 Forbidden 禁止访问。404 Not Found 找不到如何与 URI 相匹配的资源。500 Internal Server Error 最常见的服务器端错误。503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。 2. 你有哪些性能优化的方法？（1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。（2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数（3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。（4） 当需要设置的样式很多时设置className而不是直接操作style。（5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。（6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。（7） 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。 3. 什么叫优雅降级和渐进增强？优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了,为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效。渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能,向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。 4. 哪些常见操作会造成内存泄漏？内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）。 5. 线程与进程的区别一个程序至少有一个进程,一个进程至少有一个线程。线程的划分尺度小于进程，使得多线程程序的并发性高。另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML5 标签列表]]></title>
      <url>%2F2017%2F04%2F05%2F%E6%A0%87%E7%AD%BE%E5%88%97%E8%A1%A8%2F</url>
      <content type="text"><![CDATA[HTML5 &lt;article&gt; 标签article 标签是 HTML 5 的新标签, article 标签的内容独立于文档的其余部分。HTML5 &lt;canvas&gt; 标签html5 canvas 标签定义图形，比如图表和其他图像。canvas 标签只是图形容器，您必须使用脚本来绘制图形。HTML5 &lt;!--...--&gt; 标签comment 注释标签用于在源文档中插入注释。注释内容不会被浏览器显示。为代码编写注释的好处是，有助于增强代码的可读性。HTML5 &lt;!DOCTYPE&gt; 标签!DOCTYPE 文档声明必须位于 HTML5 文档中的第一行，也就是位于 html 标签之前。该标签告知浏览器文档所使用的 HTML 规范。HTML5 &lt;a&gt; 标签html5 a 标签定义超链接，用于从一个页面链接到另一个页面。a 标签最重要的属性是 href 属性，它指定链接的目标 url 。HTML5 &lt;abbr&gt; 标签abbr 标签最初是在 HTML 4.0 中引入的，表示它所包含的文本是一个更长的单词或短语的缩写形式。HTML5 &lt;address&gt; 标签address 标签定义文档作者或拥有者的联系信息。通常的做法是将 address 元素添加到网页的头部或底部。HTML5 &lt;applet&gt; 标签定义和用法 applet 定义嵌入的 applet。 HTML 5 中不支持 applet 标签 请使用 object 标签代替它。HTML5 &lt;acronym&gt; 标签定义和用法 HTML 5 不支持 acronym 标签。 请使用 abbr 标签代替它。 在 HTML 4.01 中，acronym 标签定义首字母缩略词。 如果首字母缩略词是一个单词，则可以被读出来，例如 NATO、NASA、ASAP、GUI。HTML5 &lt;area&gt; 标签area 元素始终嵌套在 map 标签内部。area 标签定义图像映射内部的区域（图像映射指的是带有可点击区域的图像）。HTML5 &lt;aside&gt; 标签html5 aside 标签定义其所处内容之外的内容。aside 标签的内容应该与附近的内容相关。HTML5 &lt;audio&gt; 标签audio 标签是 HTML 5 的新标签, audio 标签想网页中插入声音，比如音乐或其他音频流。HTML5 &lt;b&gt; 标签html5 b 标签定义粗体的文本。b 标签用于强调某些文本。如果您希望把文本标记为相比其他文本更为重要，应该使用 strong 标签。HTML5 &lt;base&gt; 标签base 标签为页面上的所有链接规定默认地址或默认目标。base 标签必须位于 head 元素内部。HTML5 &lt;basefont&gt; 标签HTML5 中不支持 basefont 标签。请用 CSS 代替。HTML5 &lt;bdi&gt; 标签bdi 标签是 HTML5 中的新标签。bdi 标签允许您设置一段文本，使其脱离其父元素的文本方向设置。HTML5 &lt;bdo&gt; 标签bdo 标签覆盖默认的文本方向。通过设置 dir 属性来设置文本的显示方向。HTML5 &lt;big&gt; 标签HTML5 中不支持 big 标签。请用 CSS 代替HTML5 &lt;blockquote&gt; 标签blockquote 标签之间的所有文本都会从常规文本中分离出来，经常会在左、右两边进行缩进，而且有时会使用斜体。HTML5 &lt;body&gt; 标签body 标签定义文档的主体。 body 标签包含文档的所有内容，比如文本、超链接、图像、表格、列表等。在 HTML 5 中，删除了所有 的特殊属性。HTML5 &lt;br&gt; 标签br 标签插入简单的换行符。br 标签是一个空标签，意味着它没有结束标签。br 标签常用来输出空行HTML5 &lt;button&gt; 标签button 标签定义按钮。您可以在 button 标签内放置内容，比如文本或图像。但是在 form 中通常使用 input 标签创建按钮。HTML5 &lt;caption&gt; 标签caption 标签定义表格的标题。caption 标签必须直接放置到 table 标签之后。通常标题会居中显示在表格上方。HTML5 &lt;center&gt; 标签HTML5 中不支持该 center 标签。请使用 CSS 代替。HTML5 &lt;cite&gt; 标签cite 标签定义作品（比如书籍、歌曲、电影、电视节目、绘画、雕塑等等）的标题，通常斜体显示。HTML5 &lt;code&gt; 标签em,strong,dfn,code,samp,kbd,var,cite 标签常用来格式话文本，使用 css 样式表可以显示更丰富的效果。HTML5 &lt;col&gt; 标签col 标签为表格中的一个或多个列定义属性值。通过使用 col 标签，可以向整个列应用样式，而不需要重复为每个单元格或每一行设置样式。HTML5 &lt;colgroup&gt; 标签通过使用 colgroup 标签，可以向整个列应用样式，而不需要重复为每个单元格或每一行设置样式。只能在 table 元素内使用 colgroup 标签。HTML5 &lt;command&gt; 标签command 元素表示用户能够调用的命令。可以用它规定键盘快捷键。只有当 command 元素位于 menu 元素内时，该元素才是可见的。HTML5 &lt;datalist&gt; 标签datalist 标签定义选项列表。请与 input 元素配合使用该元素，来定义 input 可能的值。HTML5 &lt;dd&gt; 标签dd 标签定义一个定义列表中对项目的描述。dt 标签定义列表中的项目，而 dd&gt; 标签描述这些项目。HTML5 &lt;del&gt; 标签del 标签定义文档中已删除的文本。与 ins 标签一起使用，描述文档中的更新和修正。HTML5 &lt;details&gt; 标签details 标签是 HTML 5 中的新标签。details 标签用于描述文档或文档某个部分的细节。目前只有 Chrome 支持 details 标签。HTML5 &lt;dfn&gt; 标签HTML5 &lt;dir&gt; 标签HTML5 中不支持 dir 标签。请用 CSS 代替。HTML5 &lt;div&gt; 标签div 标签常用于组合块级元素，以便通过样式表来对这些元素进行格式化。通常使用 div + css 对网页进行布局。HTML5 &lt;dl&gt; 标签dl 标签定义一个定义列表。dl 标签内部使用 dd 和 dt 定义列表中的项目。HTML5 &lt;dt&gt; 标签dt 标签定义一个定义列表中的一个项目。dd 标签描述这些项目。HTML5 &lt;em&gt; 标签HTML5 &lt;embed&gt; 标签embed 标签是 HTML 5 中的新标签。embed 标签定义嵌入的内容，比如插件。HTML5 &lt;fieldset&gt; 标签fieldset 标签会在相关表单元素周围绘制边框。fieldset 标签会在相关表单元素周围绘制边框。HTML5 &lt;figcaption&gt; 标签figcaption 标签是 HTML 5 中的新标签。figcaption 标签定义 figure 元素的标题（caption）。HTML5 &lt;figure&gt; 标签figure 标签是 HTML 5 中的新标签。figure 标签规定独立的流内容（图像、图表、照片、代码等等）。HTML5 &lt;font&gt; 标签定义和用法 在 HTML 5 中，不支持 font 标签。请用 CSS 代替它。 font 标签规定文本的字体、大小和颜色。HTML5 &lt;footer&gt; 标签footer 标签是 HTML 5 中的新标签。footer 标签定义 section 或 document 的页脚。HTML5 &lt;form&gt; 标签form 标签标签用于创建供用户输入的 HTML 表单。form 标签包含多个表单元素，如：button,input,keygen,object,output,select,textareaHTML5 &lt;frame&gt; 标签定义和用法 在 HTML 5 中不支持 frame 标签。 frame 标签定义框架集中的子窗口（框架）。 由于该标签对网页可用性的负面影响，在 HTML 5 中 frame 和 frameset 标签没有得到支持。HTML5 &lt;frameset&gt; 标签定义和用法 在 HTML 5 中不支持 frameset 标签。 frameset 标签定义框架集。它用于组织多个窗口（框架）。 由于该标签对网页可用性的负面影响，在 HTML 5 中 frame 和 frameset 标签没有得到支持。HTML5 &lt;h1 - h6&gt; 标签h1,h2,h3,h4,h5,h6 标签用来定义文档中的标题。h1 定义最大的标题。h6 定义最小的标题。HTML5 &lt;head&gt; 标签head 标签是所有头部元素的容器。位于 head 内部的元素可以包含 title,base,link,meta,script,style等。HTML5 &lt;header&gt; 标签header 标签是 HTML 5 中的新标签。header 标签定义文档的页眉（介绍信息）。HTML5 &lt;hgroup&gt; 标签hgroup 标签是 HTML 5 中的新标签。hgroup 标签用于对网页或区段（section）的标题进行组合。HTML5 &lt;hr&gt; 标签在 HTML 5 中，hr 标签定义内容中的主题变化，并显示为一条水平线。在 HTML 4.01 中，hr 标签仅仅显示为一条水平线。HTML5 &lt;html&gt; 标签html 标签告知浏览器这是一个 HTML 文档。html 元素是 HTML 文档中最外层的根元素。HTML5 &lt;i&gt; 标签i 标签定义的文本在 html 文档中呈现为斜体，以便与文档中其余部分区别开来。HTML5 &lt;iframe&gt; 标签iframe 标签创建包含另一个文档的行内框架。在 HTML 5 中，仅仅支持 src 属性。HTML5 &lt;img&gt; 标签img 标签定义 HTML 页面中的图像。img 标签定义 HTML 页面中的图像。img 标签定义 HTML 页面中的图像。HTML5 &lt;input&gt; 标签input 标签规定 form 表单中用户可输入数据的输入字段。根据不同的 type 属性，输入字段可以是文本字段、复选框、密码字段、单选按钮、按钮等。HTML5 &lt;ins&gt; 标签ins 标签定义文档的其余部分之外的插入文本。通常能够与 del 标签一起使用，来描述对文档的更新和修正。HTML5 &lt;keygen&gt; 标签keygen 是 HTML5 中的新元素。keygen 标签规定用于表单的密钥对生成器字段。当提交表单时，私钥存储在本地，公钥发送到服务器。HTML5 &lt;kbd&gt; 标签HTML5 &lt;label&gt; 标签label 标签为 input 元素定义文字标识，label 标签的 for 属性应该等于相关元素的 id 元素，以便将它们捆绑起来。HTML5 &lt;legend&gt; 标签legend 元素为以下元素定义标题（caption）：fieldset、figure、details 。 legend 元素为以下元素定义标题（caption）：fieldset、figure&gt;、details。HTML5 &lt;li&gt; 标签li 标签定义列表项，有序列表 ol 和无序列表 ul 中都使用 li 标签。 HTML 5 中，li 标签不再支持 type 属性。HTML5 &lt;link&gt; 标签link 标签定义文档与外部资源之间的关系。link 标签大多数时候都用来连接 css 样式表。link 标签只能位于head 标签中。HTML5 &lt;map&gt; 标签map 标签用于定义图像中可点击的热点区域。map 标签的 name 属性与 img 标签的 usemap 属性相关联，以创建图像与映射之间的关系HTML5 &lt;mark&gt; 标签mark 标签是 HTML 5 中的新标签。mark 标签定义带有记号的文本。请在需要突出显示文本时使用 mark 标签。HTML5 &lt;menu&gt; 标签menu 标签定义菜单列表。当希望列出表单控件时使用该标签。在 HTML 5 中，重新定义了 menu 元素，且使用用于排列表单控件。HTML5 &lt;meta&gt; 标签meta 标签位于文档的头部 head 标签中，meta 标签的属性用来定义有关页面的元信息，比如 字符集，关键词，描述，重定向等。HTML5 &lt;meter&gt; 标签meter 标签是 HTML 5 中的新标签。meter 标签定义度量的范围，既可以在元素的文本中，也可以在 min/max 属性中定义。HTML5 &lt;nav&gt; 标签nav 标签是 HTML 5 中的新标签。nav 标签定义导航链接的部分。HTML5 &lt;noframes&gt; 标签定义和用法 在 HTML 5 中不支持 noframes 标签。 noframes 标签向浏览器显示无法处理框架的提示文本。HTML5 标签noscript 元素用来定义在脚本未被执行时的替代内容（文本）。此标签用于可识别 script 标签但无法支持其中脚本的浏览器。HTML5 &lt;object&gt; 标签object 定义一个嵌入的对象。请使用此元素向您的 HTML5 页面添加多媒体。HTML5 &lt;ol&gt; 标签ol 标签定义有序列表。在 HTML 5 中，不再支持 compact 和 type 这两个属性HTML5 &lt;optgroup&gt; 标签optgroup 标签定义选项组。此元素允许您组合选项。当您使用一个长的选项列表时，对相关的选项进行组合会使处理更加容易。HTML5 &lt;option&gt; 标签option 标签定义下拉列表中的一个选项。在 HTML 5 中，option 标签也用于新元素 datalist 中。HTML5 &lt;output&gt; 标签output 标签是 HTML 5 中的新标签。output 标签定义不同类型的输出，比如脚本的输出。HTML5 &lt;p&gt; 标签p 标签定义段落。在 HTML 5 中不再支持 p 标签的 align 属性。HTML5 &lt;param&gt; 标签param 标签允许您为插入 XHTML 文档的对象规定 run-time 设置，也就是说，此标签可为包含它的 object 标签提供参数。HTML5 &lt;pre&gt; 标签pre 标签可定义预格式化的文本。pre 标签的一个常见应用就是用来表示计算机的源代码。HTML5 &lt;progress&gt; 标签progress 标签是 HTML 5 中的新标签。progress 标签定义运行中的进度（进程）。HTML5 &lt;q&gt; 标签q 标签定义一个短的引用。浏览器经常会在这种引用的周围插入引号。HTML5 &lt;rp&gt; 标签rp 标签是 HTML 5 的新标签。rp 标签在 ruby 注释中使用，以定义不支持 ruby 元素的浏览器所显示的内容。HTML5 &lt;ruby&gt; 标签ruby 标签是 HTML 5 的新标签。ruby 标签定义 ruby 注释（中文注音或字符）。HTML5 &lt;s&gt; 标签s 标签定义加删除线的文本。HTML 5 中不再支持 s 标签。HTML5 &lt;samp&gt; 标签HTML5 &lt;script&gt; 标签script 标签用于定义客户端脚本，比如 JavaScript。script 元素既可包含脚本语句，也可以通过 src 属性指向外部脚本文件。HTML5 &lt;select&gt; 标签select 标签创建下拉列表。请在 form 元素中使用此标签来接受用户的输入HTML5 &lt;small&gt; 标签在 HTML5 中，small 元素定义旁注信息，并显示为更小的文本。对于由 em 元素强调过的或由 strong 元素标记为重要的文本，small 元素不会取消对文本的强调，也不会降低这些文本的重要性。HTML5 &lt;source&gt; 标签source 标签是 HTML 5 中的新标签。source 标签为媒介元素（比如 video 和 audio）定义媒介资源。HTML5 &lt;span&gt; 标签span 标签用于对文档中的行内元素进行组合,以便通过样式表 css 对它们进行格式化。HTML5 &lt;strike&gt; 标签定义和用法 在 HTML 5 中不支持 strike 标签。请使用 CSS 代替。 strike 标签定义加删除线的文本。请使用 del 标签代替。HTML5 &lt;strong&gt; 标签HTML5 &lt;style&gt; 标签style 标签定义 HTML 文档的样式信息。scoped 属性是 HTML 5 中的新属性，它允许我们为文档的指定部分定义样式，而不是整个文档。HTML5 &lt;sub&gt; 标签sub 标签可定义下标文本。sup 可定义上标文本。HTML5 &lt;summary&gt; 标签summary 标签是 HTML 5 中的新标签。是 details 元素的第一个子元素，定义 details 元素的标题。HTML5 &lt;sup&gt; 标签HTML5 &lt;table&gt; 标签table 标签定义 HTML 表格。一个简单的 HTML 表格包括 table 元素，一个或多个 tr、th 以及 td 元素。HTML5 &lt;tbody&gt; 标签使用 tbody 标签，可以将表格分为一个单独的部分。tbody 标签可将表格中的一行或几行合成一组。在 HTML 5 中，不支持 tbody 标签的任何属性。HTML5 &lt;td&gt; 标签td 标签定义 HTML 表格中的标准单元格。thead 元素中只能使用 th 标签按，不允许使用 td 标签。HTML5 &lt;textarea&gt; 标签textarea 定义一个多行的文本输入区域。文本区中的默认字体是等宽字体 (fixed pitch)。HTML5 &lt;tfoot&gt; 标签tfoot 定义表格的页脚（脚注），tfoot 内部必须拥有 tr 标签！tfoot 表亲必须位于 table 标签内。HTML5 &lt;th&gt; 标签th 标签定义 HTML 表格中的表头单元格。th 元素中的文本呈现为粗体并且居中。th 标签在 tr 标签中定义。HTML5 &lt;thead&gt; 标签thead 标签在 table 标签中使用，定义表格的表头。thead 内部必须拥有 tr 标签！HTML5 &lt;time&gt; 标签time 标签是 HTML 5 中的新标签。time 标签定义公历的时间（24 小时制）或日期，时间和时区偏移是可选的。HTML5 &lt;title&gt; 标签title 位于 head 部分，用来定义文档的标题。title 元素在所有 HTML 文档中是必需且唯一的。HTML5 &lt;tr&gt; 标签tr 标签定义表格中的行，一个 tr 元素包含一个或多个 td 或 th 标签。HTML5 &lt;track&gt; 标签track 标签是 HTML 5 中的新标签。track 标签为诸如 video 元素之类的媒介规定外部字幕文件或其他包含的文版文件。HTML5 &lt;tt&gt; 标签定义和用法 在 HTML 5 中不支持 tt 标签。 tt 标签定义打字机文本。HTML5 &lt;u&gt; 标签在 HTML 5 中不支持 u 标签HTML5 &lt;ul&gt; 标签ul 标签定义无序列表。请使用 CSS 来定义列表的显示样式。HTML5 &lt;var&gt; 标签HTML5 &lt;video&gt; 标签video 标签是 HTML 5 的新标签。video 标签定义视频，比如电影片段或其他视频流。HTML5 &lt;wbr&gt; 标签wbr 标签是 HTML 5 中的新标签。wbr 规定在文本中的何处适合添加换行符。HTML5 &lt;rt&gt; 标签定义和用法 rt 标签定义字符（中文注音或字符）的解释或发音。 ruby 注释是中文注音或字符。 在东亚使用，显示的是东亚字符的发音。 与 ruby 以及 rt 标签一同使用： ruby 元素由一个或多个字符（需要一个解释/发音）和一个提供该信息的 rt 元素组成，还包括可选的 rp 元素，定义当浏览器不支持 ruby 元素时显示的内容。 实例 一个 ruby 注释： ruby漢 rt ㄏㄢˋ /rt/ruby HTML 4.01 与 HTML 5 之间的差异 rt 标签是 HTML 5 的新标HTML5 &lt;section&gt; 标签section 标签是 HTML 5 中的新标签。section 标签定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F03%2F09%2Fhello-world%2F</url>
      <content type="text"><![CDATA[环境准备需要git,Node.js环境 安装hexo利用 npm 命令即可安装。（在任意位置点击鼠标右键，选择Git bash） 1npm install -g hexo 创建hexo文件夹选择存放hexo文件的位置,执行以下指令(Git bash终端下)，Hexo即会自动在目标文件夹建立网站所需要的所有文件。 1hexo init 安装依赖包1npm install 本地查看现在我们已经搭建起本地的hexo博客了，执行以下命令(在hexo文件下)，然后到浏览器输入localhost:4000看看。 12hexo generate #此命令是生成静态页面，不执行该命令也可以hexo server 到此，本地服务以及搭建好了。 打包上传到github如果没有github账户，则需要注册 创建仓库，配置ssh秘钥 注意：Repository name命名规则：你的github账号.github.io (这个一定要这么命名，具体我也不清楚) hexo使用目录结构12345678910├── .deploy #需要部署的文件├── node_modules #Hexo插件├── public #生成的静态网页文件├── scaffolds #模板├── source #博客正文和其他源文件，404、favicon、CNAME├── _drafts #草稿├── _posts #文章,可以用子文件来存放文章├── themes #主题├── _config.yml #全局配置文件└── package.json 配置文件的冒号“:”后面有一个空格repo: 刚刚github创库地址.githexo命令行使用12345678hexo help #查看帮助hexo init #初始化一个目录hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成网页，可以在 public 目录查看整个网站的文件hexo server #本地预览，&apos;Ctrl+C&apos;关闭hexo deploy #部署.deploy目录hexo clean #清除缓存，**强烈建议每次执行命令前先清理缓存，每次部署前先删除 .deploy 文件夹** 简写 1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 编辑文章新建文章1hexo new &quot;标题&quot; 在 _posts 目录下会生成文件 标题.md12345678910title: Hello Worlddate: 2015-07-30 07:56:29 #发表日期，一般不改动categories: hexo #文章文类tags: [hexo,github] #文章标签，多于一项时用这种格式---正文，使用Markdown语法书写编辑完后保存，hexo server 预览hexo部署执行下列指令即可完成部署。 123hexo generatehexo deployhexo deploy问题：Deployer not found: git 1npm install hexo-deployer-git --save 重新deploy即可 图片我这里是使用本地的图片 安装 1npm install hexo-asset-image --save 安装该插件后，每次hexo new 新建博文后，会在该文件同级目录下生成一个和文件同名的文件夹，该文件夹就是用来存放图片的确保你的_config.yml 配置 post_asset_folder: true然后使用1![logo](logo.jpg) 在博文中插入logo.jpg. 来源：http://wuxiaolong.me/2015/07/31/build-blog-by-hexo/http://www.tuicool.com/articles/umEBVfI]]></content>
    </entry>

    
  
  
</search>
