<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[浅析前端渲染机制]]></title>
      <url>%2F2017%2F04%2F10%2F%E6%B5%85%E6%9E%90%E5%89%8D%E7%AB%AF%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%2F</url>
      <content type="text"><![CDATA[作为一个前端开发，最常见的运行环境应该是浏览器吧，为了更好的通过浏览器把优秀的产品带给用户，也为了更好的发展自己的前端职业之路，有必要了解从我们在浏览器地址栏输入网址到看到页面这期间浏览器是如何进行工作的,进而了解如何更好的优化实践，本篇主要围绕这两点展开阐述。前端页面渲染机制可谓是老生常谈，但又很有必要再谈的话题，于是还是决定写一篇，即是对知识的回顾总结，又能与大家分享，何乐而不为。网上相关类型的文章也很多，有兴趣的可以多学习一下。 浏览器在介绍浏览器工作流程之前，先了解一下主流浏览器的基础结构，本文所介绍的浏览器主要为开源的Chrome，FireFox及部分开源的Safari，这也是目前市场占比最高的几大浏览器，以本人博客网站为例，可以大致看出各浏览器使用比例： 浏览器占比浏览器基础结构 浏览器基础结构主要包括如下7部分： 1.用户界面（User Interface）:用户所看到及与之交互的功能组件，如地址栏，返回，前进按钮等； 2.浏览器引擎（Browser engine）:负责控制和管理下一级的渲染引擎； 3.渲染引擎（Rendering engine）:负责解析用户请求的内容（如HTML或XML，渲染引擎会解析HTML或XML，以及相关CSS，然后返回解析后的内容）； 4.网络（Networking）:负责处理网络相关的事务，如HTTP请求等； 5.UI后端（UI backend）:负责绘制提示框等浏览器组件，其底层使用的是操作系统的用户接口； 6.JavaScript解释器（JavaScript interpreter）:负责解析和执行JavaScript代码； 7.数据存储（Data storage）:负责持久存储诸如cookie和缓存等应用数据。浏览器基础结构浏览器内核 各大主要浏览器使用内核也是有差别的，大致可以分为以下几类： Trident内核： IEWebkit内核：Chrome,SafariGecko内核：FireFox 网络当用户访问页面时，浏览器需要获取用户请求内容，这个过程主要涉及浏览器网络模块： 1.用户在地址栏输入域名，如baidu.com，DNS（Domain Name System，域名解析系统）服务器根据输入的域名查找对应IP，然后向该IP地址发起请求；DNS 2.浏览器获得并解析服务器的返回内容(HTTP response)；3.浏览器加载HTML文件及文件内包含的外部引用文件及图片，多媒体等资源。DNS预解析（DNS PREFETCH） 浏览器DNS解析大多时候较快，且会缓存常用域名的解析值，但是如果网站涉及多域名，在对每一个域名访问时都需要先解析出IP地址，而我们希望在跳转或者请求其他域名资源时尽量快，则可以开启域名预解析，浏览器会在空闲时提前解析声明需要预解析的域名，如： 域名预解析多进程 我们通常说JavaScript执行是单进程的，但是浏览器网络部分通常是有几个平行进程同时开启，但是也会有限制，一般为2-6个。 渲染引擎及关键渲染路径（Critical Rendering Path）渲染引擎所做的事是将请求内容展现给我们，默认支持HTML,XML和图片类型，对于其他诸如PDF等类型的内容则需要安装相应插件，但浏览器的展示工作流程基本是一样的。 通过网络模块加载到HTML文件后渲染引擎渲染流程如下，这也通常被称作关键渲染路径（Critical Rendering Path）： 1.构建DOM树(DOM tree)：从上到下解析HTML文档生成DOM节点树（DOM tree），也叫内容树（content tree）； 2.构建CSSOM(CSS Object Model)树：加载解析样式生成CSSOM树； 3.执行JavaScript：加载并执行JavaScript代码（包括内联代码或外联JavaScript文件）； 4.构建渲染树(render tree)：根据DOM树和CSSOM树,生成渲染树(render tree)；渲染树：按顺序展示在屏幕上的一系列矩形，这些矩形带有字体，颜色和尺寸等视觉属性。 5.布局（layout）：根据渲染树将节点树的每一个节点布局在屏幕上的正确位置； 6.绘制（painting）：遍历渲染树绘制所有节点，为每一个节点适用对应的样式，这一过程是通过UI后端模块完成；关键渲染路径为了更友好的用户体验，浏览器会尽可能快的展现内容，而不会等到文档所有内容到达才开始解析和构建/布局渲染树，而是每次处理一部分，并展现在屏幕上，这也是为什么我们经常可以看到页面加载的时候内容是从上到下一点一点展现的。 流程图Webkit渲染引擎流程如下图： Gecko渲染引擎流程如下图： 如上图，Webkit浏览器和Gecko浏览器渲染流程大致相同,不同的是：1231.Webkit浏览器中的渲染树(render tree)，在Gecko浏览器中对应的则是框架树（frame tree）,渲染对象(render object)对应的是框架（frame）;2.Webkit中的布局（Layout）过程，在Gecko中称为回流（Reflow）,本质是一样的，后文会解释回流的另一层含义–重新布局；3.Gecko中HTML和DOM树中间多了一层内容池（Content sink）,可以理解成生成DOM元素的工厂。 单进程不同于网络部分的多进程渲染引擎是单线程工作的，意味着渲染流程是一步一步渐进完成的。 解析文档(PARSER HTML)在详细介绍浏览器渲染文档之前，先应该理解浏览器如何解析文档：解析文档的顺序，对于CSS和JavaScript如何处理等。 解析顺序浏览器按从上到下的顺序扫描解析文档； 解析样式和脚本脚本 或许是由于通常会在JavaScript脚本中改变文档DOM结构，于是浏览器以同步方式解析，加载和执行脚本，浏览器在解析文档时，当解析到标签时，会解析其中的脚本（对于外链的JavaScript文件，需要先加载该文件内容，再进行解析），然后立即执行，这整个过程都会阻塞文档解析，直到脚本执行完才会继续解析文档。就是说由于脚本是同步加载和执行的，它会阻塞文档解析，这也解释了为什么现在通常建议将标签放在标签前面，而不是放在标签里。现在HTML5提供defer和async两个属性支持延迟和异步加载JavaScript文件，如：1&lt;script defer src=&quot;script.js&quot;&gt; 改进 针对上文说的脚本阻塞文档解析，主流浏览器如Chrome和FireFox等都有一些优化，比如在执行脚本时，开启另一个进程解析剩余的文档以找出并加载其他的待下载外部资源（不改变主进程的DOM树，仅优化加载外部资源）。 样式 不同于脚本，浏览器对样式的处理并不会阻塞文档解析，大概是因为样式表并不会改变DOM结构。 样式表与脚本 你可能想问样式是否会阻塞脚本文件的加载执行呢？正常情况是不会的，但是存在一个问题是通常我们会在脚本中请求样式信息，但是在文档解析时，如果样式尚未加载或解析，将会得到错误信息，对于这一问题，FireFox浏览器和Webkit浏览器处理策略不同： 当存在有样式文件未被加载和解析时，FireFox浏览器会阻塞所有脚本；而Webkit浏览器只会阻塞操作了改文件内声明的样式属性的脚本。构建DOM树 DOM，即文档对象模型（Document Object Model）,DOM树，即文档内所有节点构成的一个树形结构。 假设浏览器获取返回的如下HTML文档： 12345678910111213&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./theme.css&quot;&gt;&lt;/link&gt; &lt;script src=&quot;./config.js&quot;&gt;&lt;/script&gt; &lt;title&gt;关键渲染路径&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 class=&quot;title&quot;&gt;关键渲染路径&lt;/h1&gt; &lt;p&gt;关键渲染路径介绍&lt;/p&gt; &lt;footer&gt;@copyright2017&lt;/footer&gt;&lt;/body&gt;&lt;/html&gt; 首先浏览器从上到下依次解析文档构建DOM树，如下： 构建CSSOM树 CSSOM，即CSS对象模型（CSS Object Model），CSSOM树，与DOM树结构相似，只是另外为每一个节点关联了样式信息。 theme.css样式内容如下： 123456789101112html, body &#123;width: 100%;height: 100%;background-color: #fcfcfc;&#125;.title &#123;font-size: 20px;&#125;.footer &#123;font-size: 12px;color: #aaa;&#125; 构建CSSOM树如图： 执行JAVASCRIPT 上文已经阐述了文档解析时对脚本的处理，我们得知脚本加载，解析和执行会阻塞文档解析，而在特殊情况下样式的加载和解析也会阻塞脚本，所以现在推荐的实践是标签放在标签前面。 构建渲染树(RENDER TREE) DOM树和CSSOM树都构建完了，接着浏览器会构建渲染树： 渲染树，代表一个文档的视觉展示，浏览器通过它将文档内容绘制在浏览器窗口，展示给用户，它由按顺序展示在屏幕上的一系列矩形对象组成，这些矩形对象都带有字体，颜色和尺寸，位置等视觉样式属性。对于这些矩对象，FireFox称之为框架（frame）,Webkit浏览器称之为渲染对象（render object, renderer），后文统称为渲染对象。这里把渲染树节点称为矩形对象，是因为，每一个渲染对象都代表着其对应DOM节点的CSS盒子,该盒子包含了尺寸，位置等几何信息，同时它指向一个样式对象包含其他视觉样式信息。 渲染树与DOM树每一个渲染对象都对应着DOM节点，但是非视觉（隐藏，不占位）DOM元素不会插入渲染树，如元素或声明display: none;的元素，渲染对象与DOM节点不是简单的一对一的关系，一个DOM可以对应一个渲染对象，但一个DOM元素也可能对应多个渲染对象，因为有很多元素不止包含一个CSS盒子，如当文本被折行时，会产生多个行盒，这些行会生成多个渲染对象；又如行内元素同时包含块元素和行内元素，则会创建一个匿名块级盒包含内部行内元素，此时一个DOM对应多个矩形对象（渲染对象）。 渲染树及其对应DOM树如图： 图中渲染树viewport即视口，是文档的初始包含块，scroll代表滚动区域，详见CSS之视觉格式化模型(Visual Formatting Model)渲染树并不会包含显式或隐式地display：none;的标签元素。布局（LAYOUT）或回流（REFLOW，RELAYOUT） 创建渲染树后，下一步就是布局（Layout）,或者叫回流（reflow,relayout），这个过程就是通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸，将其安置在浏览器窗口的正确位置，而有些时候我们会在文档布局完成后对DOM进行修改，这时候可能需要重新进行布局，也可称其为回流，本质上还是一个布局的过程，每一个渲染对象都有一个布局或者回流方法，实现其布局或回流。 流（flow）HTML采用的是基于流的方式定位布局，其按照从左到右，从上到下的顺序进行排列，详见CSS定位机制。 全局布局与局部布局对渲染树的布局可以分为全局和局部的，全局即对整个渲染树进行重新布局，如当我们改变了窗口尺寸或方向或者是修改了根元素的尺寸或者字体大小等；而局部布局可以是对渲染树的某部分或某一个渲染对象进行重新布局。 脏位系统（dirty bit system）大多数web应用对DOM的操作都是比较频繁，这意味着经常需要对DOM进行布局和回流，而如果仅仅是一些小改变，就触发整个渲染树的回流，这显然是不好的，为了避免这种情况，浏览器使用了脏位系统，只有一个渲染对象改变了或者某渲染对象及其子渲染对象脏位值为”dirty”时，说明需要回流。 表示需要布局的脏位值有两种： “dirty”–自身改变，需要回流“children are dirty”–子节点改变，需要回流布局过程布局是一个从上到下，从外到内进行的递归过程，从根渲染对象，即对应着HTML文档根元素，然后下一级渲染对象，如对应着元素，如此层层递归，依次计算每一个渲染对象的几何信息（位置和尺寸）。 几何信息-位置和尺寸，即相对于窗口的坐标和尺寸，如根渲染对象，其坐标为（0， 0），尺寸即是视口尺寸（浏览器窗口的可视区域）。 每一个渲染对象的布局流程基本如： 1.计算此渲染对象的宽度（width）；2.遍历此渲染对象的所有子级，依次：2.1设置子级渲染对象的坐标2.2判断是否需要触发子渲染对象的布局或回流方法，计算子渲染对象的高度（height）3.设置此渲染对象的高度：根据子渲染对象的累积高，margin和padding的高度设置其高度；4.设置此渲染对象脏位值为false。强制回流在渲染树布局完成后，再次操作文档，改变文档的内容或结构，或者元素定位时，会触发回流，即需要重新布局，如请求某DOM的”offsetHeight”样式信息等诸多情况： DOM操作，如增加，删除，修改或移动；变更内容；激活伪类；访问或改变某些CSS属性（包括修改样式表或元素类名或使用JavaScript操作等方式）；浏览器窗口变化（滚动或尺寸变化） $(&apos;body&apos;).css(&apos;padding&apos;); // reflow 有过CSS3动画开发经验的同学可能会有经历，如下入场动画： .slide-left { -webkit-transition: margin-left 1s ease-out; -moz-transition: margin-left 1s ease-out; -o-transition: margin-left 1s ease-out; transition: margin-left 1s ease-out; } 然后执行如下脚本： var $slide = $(&apos;.slide-left&apos;); $slide.css({ &quot;margin-left&quot;: &quot;100px&quot; }).addClass(&apos;slide-left&apos;); $slide.css({ &quot;margin-left&quot;: &quot;10px&quot; }); 我们会发现并没有效果，为什么呢？因为对margin-left的修改并没有触发回流，元素margin-left值的改变被缓存，如果我们在中间强制触发回流： var $slide = $(&apos;.slide-left&apos;); $slide.css({ &quot;margin-left&quot;: &quot;100px&quot; }); console.log($slide.css(&apos;padding&apos;); $slide.addClass(&apos;slide-left&apos;); $slide.css({ &quot;margin-left&quot;: &quot;10px&quot; }); 再看就达到了预期效果。 绘制（PAINTING） 最后是绘制(paint)阶段或重绘（repaint）阶段，浏览器UI组件将遍历渲染树并调用渲染对象的绘制（paint）方法，将内容展现在屏幕上，也有可能在之后对DOM进行修改，需要重新绘制渲染对象，也就是重绘，绘制和重绘的关系可以参考布局和回流的关系。 全局与局部绘制与布局相似，绘制也分为全局和局部绘制，即对整个渲染树或某些渲染对象进行绘制。 触发重绘我们已经知道很多操作可能会触发回流，那么什么时候可能触发重绘呢，通常，当改变元素的视觉样式，如background-color,visibility，margin，padding或字体颜色时会触发全局或局部重绘，如： $(&apos;body&apos;).css(&apos;color&apos;, &apos;red&apos;); // repaint $(&apos;body&apos;).css(&apos;margin&apos;, &apos;2px&apos;); // reflow, repaint 页面渲染优化浏览器对上文介绍的关键渲染路径进行了很多优化，针对每一次变化产生尽量少的操作，还有优化判断重新绘制或布局的方式等等。 在改变文档根元素的字体颜色等视觉性信息时，会触发整个文档的重绘，而改变某元素的字体颜色则只触发特定元素的重绘；改变元素的位置信息会同时触发此元素（可能还包括其兄弟元素或子级元素）的布局和重绘。某些重大改变，如更改文档根元素的字体尺寸，则会触发整个文档的重新布局和重绘，据此及上文所述，推荐以下优化和实践：` 1.HTML文档结构层次尽量少，最好不深于六层； 2.脚本尽量后放，放在前即可； 3.少量首屏样式内联放在标签内； 4.样式结构层次尽量简单； 5.在脚本中尽量减少DOM操作，尽量缓存访问DOM的样式信息，避免过度触发回流； 6.减少通过JavaScript代码修改元素样式，尽量使用修改class名方式操作样式或动画； 7.动画尽量使用在绝对定位或固定定位的元素上； 8.隐藏在屏幕外，或在页面滚动时，尽量停止动画； 9.尽量缓存DOM查找，查找器尽量简洁； 10.涉及多域名的网站，可以开启域名预解析` 实例当我们访问一个页面时，浏览器渲染事件详细日志图如下：浏览器渲染事件日志 1.发起请求；2.解析HTML；3.解析样式；4.执行JavaScript；5.布局；6.绘制]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[移动端资源整理]]></title>
      <url>%2F2017%2F04%2F08%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%B5%84%E6%BA%90%E6%95%B4%E7%90%86%2F</url>
      <content type="text"><![CDATA[meta基础知识 H5页面窗口自动调整到设备宽度，并禁止用户缩放页面 &lt;meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no" /&gt; 忽略将页面中的数字识别为电话号码 &lt;meta name="format-detection" content="telephone=no" /&gt; 忽略Android平台中对邮箱地址的识别 &lt;meta name="format-detection" content="email=no" /&gt; 当网站添加到主屏幕快速启动方式，可隐藏地址栏，仅针对ios的safari &lt;meta name="apple-mobile-web-app-capable" content="yes" /&gt; &lt;!-- ios7.0版本以后，safari上已看不到效果 --&gt; 将网站添加到主屏幕快速启动方式，仅针对ios的safari顶端状态条的样式 &lt;meta name="apple-mobile-web-app-status-bar-style" content="black" /&gt; &lt;!-- 可选default、black、black-translucent --&gt; viewport模板 viewport模板&mdash;&mdash;通用 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" name="viewport"&gt; &lt;meta content="yes" name="apple-mobile-web-app-capable"&gt; &lt;meta content="black" name="apple-mobile-web-app-status-bar-style"&gt; &lt;meta content="telephone=no" name="format-detection"&gt; &lt;meta content="email=no" name="format-detection"&gt; &lt;title&gt;标题&lt;/title&gt; &lt;link rel="stylesheet" href="index.css"&gt; &lt;/head&gt; &lt;body&gt; 这里开始内容 &lt;/body&gt; &lt;/html&gt; &nbsp; viewport模板 -&nbsp;target-densitydpi=device-dpi，android 2.3.5以下版本不支持 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=750, user-scalable=no, target-densitydpi=device-dpi"&gt;&lt;!-- width取值与页面定义的宽度一致 --&gt; &lt;meta content="yes" name="apple-mobile-web-app-capable"&gt; &lt;meta content="black" name="apple-mobile-web-app-status-bar-style"&gt; &lt;meta content="telephone=no" name="format-detection"&gt; &lt;meta content="email=no" name="format-detection"&gt; &lt;title&gt;标题&lt;/title&gt; &lt;link rel="stylesheet" href="index.css"&gt; &lt;/head&gt; &lt;body&gt; 这里开始内容 &lt;/body&gt; &lt;/html&gt; &nbsp; 常见问题 移动端如何定义字体font-family 中文字体使用系统默认即可，英文用Helvetica /* 移动端定义字体的代码 */ body{font-family:Helvetica;} 参考《移动端使用字体的思考》 移动端字体单位font-size选择px还是rem 对于只需要适配少部分手机设备，且分辨率对页面影响不大的，使用px即可 对于需要适配各种移动设备，使用rem，例如只需要适配iPhone和iPad等分辨率差别比较挺大的设备 rem配置参考： html{font-size:10px} @media screen and (min-width:321px) and (max-width:375px){html{font-size:11px}} @media screen and (min-width:376px) and (max-width:414px){html{font-size:12px}} @media screen and (min-width:415px) and (max-width:639px){html{font-size:15px}} @media screen and (min-width:640px) and (max-width:719px){html{font-size:20px}} @media screen and (min-width:720px) and (max-width:749px){html{font-size:22.5px}} @media screen and (min-width:750px) and (max-width:799px){html{font-size:23.5px}} @media screen and (min-width:800px){html{font-size:25px}} 体验demo：http://1.peunzhang.sinaapp.com/demo/rem/index.html 移动端touch事件(区分webkit 和 winphone) 当用户手指放在移动设备在屏幕上滑动会触发的touch事件 以下支持webkit touchstart&mdash;&mdash;当手指触碰屏幕时候发生。不管当前有多少只手指 touchmove&mdash;&mdash;当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用event的preventDefault()可以阻止默认情况的发生：阻止页面滚动 touchend&mdash;&mdash;当手指离开屏幕时触发 touchcancel&mdash;&mdash;系统停止跟踪触摸时候会触发。例如在触摸过程中突然页面alert()一个提示框，此时会触发该事件，这个事件比较少用 TouchEvent touches：屏幕上所有手指的信息 targetTouches：手指在目标区域的手指信息 changedTouches：最近一次触发该事件的手指信息 touchend时，touches与targetTouches信息会被删除，changedTouches保存的最后一次的信息，最好用于计算手指信息 参数信息(changedTouches[0]) clientX、clientY在显示区的坐标 target：当前元素 参考：https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent 以下支持winphone 8 MSPointerDown&mdash;&mdash;当手指触碰屏幕时候发生。不管当前有多少只手指 MSPointerMove&mdash;&mdash;当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用css的html{-ms-touch-action: none;}可以阻止默认情况的发生：阻止页面滚动 MSPointerUp&mdash;&mdash;当手指离开屏幕时触发 移动端click屏幕产生200-300 ms的延迟响应 移动设备上的web网页是有300ms延迟的，玩玩会造成按钮点击延迟甚至是点击失效。 以下是历史原因，来源一个公司内一个同事的分享： 2007年苹果发布首款iphone上IOS系统搭载的safari为了将适用于PC端上大屏幕的网页能比较好的展示在手机端上，使用了双击缩放(double tap to zoom)的方案，比如你在手机上用浏览器打开一个PC上的网页，你可能在看到页面内容虽然可以撑满整个屏幕，但是字体、图片都很小看不清，此时可以快速双击屏幕上的某一部分，你就能看清该部分放大后的内容，再次双击后能回到原始状态。 双击缩放是指用手指在屏幕上快速点击两次，iOS 自带的 Safari 浏览器会将网页缩放至原始比例。 原因就出在浏览器需要如何判断快速点击上，当用户在屏幕上单击某一个元素时候，例如跳转链接&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;，此处浏览器会先捕获该次单击，但浏览器不能决定用户是单纯要点击链接还是要双击该部分区域进行缩放操作，所以，捕获第一次单击后，浏览器会先Hold一段时间t，如果在t时间区间里用户未进行下一次点击，则浏览器会做单击跳转链接的处理，如果t时间里用户进行了第二次单击操作，则浏览器会禁止跳转，转而进行对该部分区域页面的缩放操作。那么这个时间区间t有多少呢？在IOS safari下，大概为300毫秒。这就是延迟的由来。造成的后果用户纯粹单击页面，页面需要过一段时间才响应，给用户慢体验感觉，对于web开发者来说是，页面js捕获click事件的回调函数处理，需要300ms后才生效，也就间接导致影响其他业务逻辑的处理。 解决方案： fastclick可以解决在手机上点击事件的300ms延迟 zepto的touch模块，tap事件也是为了解决在click的延迟问题 触摸事件的响应顺序 1、ontouchstart 2、ontouchmove 3、ontouchend 4、onclick 解决300ms延迟的问题，也可以通过绑定ontouchstart事件，加快对事件的响应 什么是Retina 显示屏，带来了什么问题 retina：一种具备超高像素密度的液晶屏，同样大小的屏幕上显示的像素点由1个变为多个，如在同样带下的屏幕上，苹果设备的retina显示屏中，像素点1个变为4个 在高清显示屏中的位图被放大，图片会变得模糊，因此移动端的视觉稿通常会设计为传统PC的2倍 那么，前端的应对方案是： 设计稿切出来的图片长宽保证为偶数，并使用backgroud-size把图片缩小为原来的1/2 //例如图片宽高为：200px*200px，那么写法如下 .css{width:100px;height:100px;background-size:100px 100px;} 其它元素的取值为原来的1/2，例如视觉稿40px的字体，使用样式的写法为20px .css{font-size:20px} 参考《高清显示屏原理及设计方案》 ios系统中元素被触摸时产生的半透明灰色遮罩怎么去掉 ios用户点击一个链接，会出现一个半透明灰色遮罩,&nbsp;如果想要禁用，可设置-webkit-tap-highlight-color的alpha值为0，也就是属性值的最后一位设置为0就可以去除半透明灰色遮罩 a,button,input,textarea{-webkit-tap-highlight-color: rgba(0,0,0,0;)} 部分android系统中元素被点击时产生的边框怎么去掉 android用户点击一个链接，会出现一个边框或者半透明灰色遮罩,&nbsp;不同生产商定义出来额效果不一样，可设置-webkit-tap-highlight-color的alpha值为0去除部分机器自带的效果 a,button,input,textarea{ -webkit-tap-highlight-color: rgba(0,0,0,0;) -webkit-user-modify:read-write-plaintext-only; } -webkit-user-modify有个副作用，就是输入法不再能够输入多个字符 另外，有些机型去除不了，如小米2 对于按钮类还有个办法，不使用a或者input标签，直接用div标签 参考《如何去除android上a标签产生的边框》 winphone系统a、input标签被点击时产生的半透明灰色背景怎么去掉 &lt;meta name="msapplication-tap-highlight" content="no"&gt; webkit表单元素的默认外观怎么重置 .css{-webkit-appearance:none;} webkit表单输入框placeholder的颜色值能改变么 input::-webkit-input-placeholder{color:#AAAAAA;} input:focus::-webkit-input-placeholder{color:#EEEEEE;} webkit表单输入框placeholder的文字能换行么 ios可以，android不行~ 在textarea标签下都可以换行~ IE10（winphone8）表单元素默认外观如何重置 禁用&nbsp;select&nbsp;默认下拉箭头 ::-ms-expand&nbsp;适用于表单选择控件下拉箭头的修改，有多个属性值，设置它隐藏&nbsp;(display:none)&nbsp;并使用背景图片来修饰可得到我们想要的效果。 select::-ms-expand { display: none; } 禁用&nbsp;radio&nbsp;和&nbsp;checkbox&nbsp;默认样式 ::-ms-check&nbsp;适用于表单复选框或单选按钮默认图标的修改，同样有多个属性值，设置它隐藏&nbsp;(display:none)&nbsp;并使用背景图片来修饰可得到我们想要的效果。 input[type=radio]::-ms-check,input[type=checkbox]::-ms-check{ display: none; } 禁用PC端表单输入框默认清除按钮 当表单文本输入框输入内容后会显示文本清除按钮，::-ms-clear&nbsp;适用于该清除按钮的修改，同样设置使它隐藏&nbsp;(display:none)&nbsp;并使用背景图片来修饰可得到我们想要的效果。 input[type=text]::-ms-clear,input[type=tel]::-ms-clear,input[type=number]::-ms-clear{ display: none; } 禁止ios 长按时不触发系统的菜单，禁止ios&amp;android长按时下载图片 .css{-webkit-touch-callout: none} 禁止ios和android用户选中文字 .css{-webkit-user-select:none} 参考《如何改变表单元素的外观(for Webkit and IE10)》 打电话发短信写邮件怎么实现 打电话 &lt;a href="tel:0755-10086"&gt;打电话给:0755-10086&lt;/a&gt; 发短信，winphone系统无效 &lt;a href="sms:10086"&gt;发短信给: 10086&lt;/a&gt; 写邮件，可参考《移动web页面给用户发送邮件的方法》 &lt;a href="mailto:peun@foxmail.com"&gt;peun@foxmail.com&lt;/a&gt; 模拟按钮hover效果 移动端触摸按钮的效果，可明示用户有些事情正要发生，是一个比较好体验，但是移动设备中并没有鼠标指针，使用css的hover并不能满足我们的需求，还好国外有个激活css的active效果，代码如下， &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" name="viewport"&gt; &lt;meta content="yes" name="apple-mobile-web-app-capable"&gt; &lt;meta content="black" name="apple-mobile-web-app-status-bar-style"&gt; &lt;meta content="telephone=no" name="format-detection"&gt; &lt;meta content="email=no" name="format-detection"&gt; &lt;style type="text/css"&gt; a{-webkit-tap-highlight-color: rgba(0,0,0,0);} .btn-blue{display:block;height:42px;line-height:42px;text-align:center;border-radius:4px;font-size:18px;color:#FFFFFF;background-color: #4185F3;} .btn-blue:active{background-color: #357AE8;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="btn-blue"&gt;按钮&lt;/div&gt; &lt;script type="text/javascript"&gt; document.addEventListener("touchstart", function(){}, true) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 兼容性ios5+、部分android 4+、winphone 8 要做到全兼容的办法，可通过绑定ontouchstart和ontouchend来控制按钮的类名 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" name="viewport"&gt; &lt;meta content="yes" name="apple-mobile-web-app-capable"&gt; &lt;meta content="black" name="apple-mobile-web-app-status-bar-style"&gt; &lt;meta content="telephone=no" name="format-detection"&gt; &lt;meta content="email=no" name="format-detection"&gt; &lt;style type="text/css"&gt; a{-webkit-tap-highlight-color: rgba(0,0,0,0);} .btn-blue{display:block;height:42px;line-height:42px;text-align:center;border-radius:4px;font-size:18px;color:#FFFFFF;background-color: #4185F3;} .btn-blue-on{background-color: #357AE8;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="btn-blue"&gt;按钮&lt;/div&gt; &lt;script type="text/javascript"&gt; var btnBlue = document.querySelector(".btn-blue"); btnBlue.ontouchstart = function(){this.className = "btn-blue btn-blue-on" } btnBlue.ontouchend = function(){this.className = "btn-blue" } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 屏幕旋转的事件和样式 事件 window.orientation，取值：正负90表示横屏模式、0和180表现为竖屏模式； window.onorientationchange = function(){ switch(window.orientation){ case -90: case 90: alert("横屏:" + window.orientation); case 0: case 180: alert("竖屏:" + window.orientation); break; } } 样式 //竖屏时使用的样式 @media all and (orientation:portrait) { .css{} } //横屏时使用的样式 @media all and (orientation:landscape) { .css{} } audio元素和video元素在ios和andriod中无法自动播放 应对方案：触屏即播 $('html').one('touchstart',function(){audio.play() }) 可参考《无法自动播放的audio元素》 摇一摇功能 HTML5 deviceMotion：封装了运动传感器数据的事件，可以获取手机运动状态下的运动加速度等数据。 var SHAKE_THRESHOLD = 2000; var last_update = 0; var x = y = z = last_x = last_y = last_z = 0; function init() { if (window.DeviceMotionEvent) { window.addEventListener('devicemotion', deviceMotionHandler, false); } else { alert('not support mobile event'); } } function deviceMotionHandler(eventData) { var acceleration = eventData.accelerationIncludingGravity; var curTime = new Date().getTime(); if ((curTime - last_update) &gt; 100) { var diffTime = curTime - last_update; last_update = curTime; x = acceleration.x; y = acceleration.y; z = acceleration.z; var speed = Math.abs(x + y + z - last_x - last_y - last_z) / diffTime * 10000; if (speed &gt; SHAKE_THRESHOLD) { //alert("摇动了"+SHAKE_THRESHOLD); } last_x = x; last_y = y; last_z = z; } } &nbsp; 手机拍照和上传图片 &lt;input type=&quot;file&quot;&gt;的accept 属性 &lt;!-- 选择照片 --&gt; &lt;input type=file accept="image/*"&gt; &lt;!-- 选择视频 --&gt; &lt;input type=file accept="video/*"&gt; 使用总结： ios 有拍照、录像、选取本地图片功能 部分android只有选取本地图片功能 winphone不支持 input控件默认外观丑陋 微信浏览器用户调整字体大小后页面矬了，怎么阻止用户调整 原因 android侧是复写了layoutinflater 对textview做了统一处理 ios侧是修改了body.style.webkitTextSizeAdjust值 解决方案： android使用以下代码，该接口只在微信浏览器下有效(感谢jationhuang同学提供) /** * 页面加入这段代码可使Android机器页面不再受到用户字体缩放强制改变大小 * 但是会有一个1秒左右的延迟，期间可以考虑通过loading展示 * 仅供参考 */ (function(){ if (typeof(WeixinJSBridge) == "undefined") { document.addEventListener("WeixinJSBridgeReady", function (e) { setTimeout(function(){ WeixinJSBridge.invoke('setFontSizeCallback',{"fontSize":0}, function(res) { alert(JSON.stringify(res)); }); },0); }); } else { setTimeout(function(){ WeixinJSBridge.invoke('setFontSizeCallback',{"fontSize":0}, function(res) { alert(JSON.stringify(res)); }); },0); } })(); &nbsp; ios使用-webkit-text-size-adjust禁止调整字体大小 body{-webkit-text-size-adjust: 100%!important;} 最好的解决方案： 整个页面用rem或者百分比布局 消除transition闪屏 网络都是这么写的，但我并没有测试出来 .css{ /*设置内嵌的元素在 3D 空间如何呈现：保留 3D*/ -webkit-transform-style: preserve-3d; /*（设置进行转换的元素的背面在面对用户时是否可见：隐藏）*/ -webkit-backface-visibility: hidden; } 开启硬件加速 解决页面闪白 保证动画流畅 .css { -webkit-transform: translate3d(0, 0, 0); -moz-transform: translate3d(0, 0, 0); -ms-transform: translate3d(0, 0, 0); transform: translate3d(0, 0, 0); } 参考《用CSS开启硬件加速来提高网站性能》 取消input在ios下，输入的时候英文首字母的默认大写 &lt;input autocapitalize="off" autocorrect="off" /&gt; android 上去掉语音输入按钮 input::-webkit-input-speech-button {display: none} android 2.3 bug @-webkit-keyframes 需要以0%开始100%结束，0%的百分号不能去掉 after和before伪类无法使用动画animation border-radius不支持%单位 translate百分比的写法和scale在一起会导致失效，例如-webkit-transform: translate(-50%,-50%) scale(-0.5, 1) android 4.x bug 三星 Galaxy S4中自带浏览器不支持border-radius缩写 同时设置border-radius和背景色的时候，背景色会溢出到圆角以外部分 部分手机(如三星)，a链接支持鼠标:visited事件，也就是说链接访问后文字变为紫色 android无法同时播放多音频audio 参考《border-radius 移动之伤》 设计高性能CSS3动画的几个要素 尽可能地使用合成属性transform和opacity来设计CSS3动画，不使用position的left和top来定位 利用translate3D开启GPU加速 参考《High Performance Animations》 fixed bug ios下fixed元素容易定位出错，软键盘弹出时，影响fixed元素定位 android下fixed表现要比iOS更好，软键盘弹出时，不会影响fixed元素定位 ios4下不支持position:fixed 解决方案 可用isroll.js，暂无完美方案 参考 《移动端web页面使用position:fixed问题总结》 《使用iScroll.js解决ios4下不支持position:fixed的问题》 &nbsp;如何阻止windows Phone的默认触摸事件 winphone下默认触摸事件事件使用e.preventDefault是无效的 目前解决方法是使用样式来禁用 html{-ms-touch-action: none;}/* 禁止winphone默认触摸事件 */ 参考 《Windows phone 8 touch support》 播放视频不全屏 &lt;!-- 1.目前只有ios7+、winphone8+支持自动播放 2.支持Airplay的设备（如：音箱、Apple TV)播放 x-webkit-airplay="true" 3.播放视频不全屏，ios7+、winphone8+支持，部分android4+支持（含华为、小米、魅族） webkit-playsinline="true" --&gt; &lt;video x-webkit-airplay="true" webkit-playsinline="true" preload="auto" autoplay src="http://"&gt;&lt;/video&gt; 体验demo：http://1.peunzhang.sinaapp.com/demo/video/index.html 常用的移动端框架 zepto.js 语法与jquery几乎一样，会jquery基本会zepto~ 最新版本已经更新到1.16 官网：http://zeptojs.com/ 中文(非官网)：http://www.css88.com/doc/zeptojs_api/ 常使用的扩展模块： 浏览器检测：https://github.com/madrobby/zepto/blob/master/src/detect.js tap事件：https://github.com/madrobby/zepto/blob/master/src/touch.js iscroll.js 解决页面不支持弹性滚动，不支持fixed引起的问题~ 实现下拉刷新，滑屏，缩放等功能~ 最新版本已经更新到5.0 官网：http://cubiq.org/iscroll-5 underscore.js 笔者没用过，不过听说好用，推荐给大家~ 该库提供了一整套函数式编程的实用功能，但是没有扩展任何JavaScript内置对象。 最新版本已经更新到1.8.2 官网：http://underscorejs.org/ 滑屏框架 适合上下滑屏、左右滑屏等滑屏切换页面的效果 slip.js iSlider.js fullpage.js swiper.js flex布局 使用注意： flex下的子元素必须为块级元素，非块级元素在android2.3机器下flex失效 flex下的子元素宽度和高度不能超过父元素，否则会导致子元素定位错误，例如水平垂直居中 FastClick 消除在移动浏览器上触发click事件与一个物理Tap(敲击)之间的300延迟 参考《FastClick》 Sea.js&nbsp; 提供简单、极致的模块化开发体验 简单友好的模块定义规范：Sea.js 遵循&nbsp;CMD&nbsp;规范，可以像&nbsp;Node.js&nbsp;一般书写模块代码。 自然直观的代码组织方式：依赖的自动加载、配置的简洁清晰，可以让我们更多地享受编码的乐趣。 地址：http://seajs.org/docs/ &nbsp;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[排序算法整理]]></title>
      <url>%2F2017%2F04%2F08%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%2F</url>
      <content type="text"><![CDATA[冒泡排序 冒泡排序是最简单的排序之一了，其大体思想就是通过与相邻元素的比较和交换来把小的数交换到最前面。这个过程类似于水泡向上升一样，因此而得名。举个栗子，对5,3,8,6,4这个无序序列进行冒泡排序。首先从后向前冒泡，4和6比较，把4交换到前面，序列变成5,3,8,4,6。同理4和8交换，变成5,3,4,8,6,3和4无需交换。5和3交换，变成3,5,4,8,6,3.这样一次冒泡就完了，把最小的数3排到最前面了。对剩下的序列依次冒泡就会得到一个有序序列。冒泡排序的时间复杂度为O(n^2)。 实现代码： /** *@Description:&lt;p&gt;冒泡排序算法实现&lt;/p&gt; *@author 王旭 *@time 2016-3-3 下午8:54:27 */ public class BubbleSort { public static void bubbleSort(int[] arr) { if(arr == null || arr.length == 0) return ; for(int i=0; i&lt;arr.length-1; i++) { for(int j=arr.length-1; j&gt;i; j--) { if(arr[j] &lt; arr[j-1]) { swap(arr, j-1, j); } } } } public static void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } } 选择排序 选择排序的思想其实和冒泡排序有点类似，都是在一次排序后把最小的元素放到最前面。但是过程不同，冒泡排序是通过相邻的比较和交换。而选择排序是通过对整体的选择。举个栗子，对5,3,8,6,4这个无序序列进行简单选择排序，首先要选择5以外的最小数来和5交换，也就是选择3和5交换，一次排序后就变成了3,5,8,6,4.对剩下的序列一次进行选择和交换，最终就会得到一个有序序列。其实选择排序可以看成冒泡排序的优化，因为其目的相同，只是选择排序只有在确定了最小数的前提下才进行交换，大大减少了交换的次数。选择排序的时间复杂度为O(n^2) 实现代码： /** *@Description:&lt;p&gt;简单选择排序算法的实现&lt;/p&gt; *@author 王旭 *@time 2016-3-3 下午9:13:35 */public class SelectSort { public static void selectSort(int[] arr) { if(arr == null || arr.length == 0) return ; int minIndex = 0; for(int i=0; i&lt;arr.length-1; i++) { //只需要比较n-1次 minIndex = i; for(int j=i+1; j&lt;arr.length; j++) { //从i+1开始比较，因为minIndex默认为i了，i就没必要比了。 if(arr[j] &lt; arr[minIndex]) { minIndex = j; } } if(minIndex != i) { //如果minIndex不为i，说明找到了更小的值，交换之。 swap(arr, i, minIndex); } } } public static void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } 插入排序 插入排序不是通过交换位置而是通过比较找到合适的位置插入元素来达到排序的目的的。相信大家都有过打扑克牌的经历，特别是牌数较大的。在分牌时可能要整理自己的牌，牌多的时候怎么整理呢？就是拿到一张牌，找到一个合适的位置插入。这个原理其实和插入排序是一样的。举个栗子，对5,3,8,6,4这个无序序列进行简单插入排序，首先假设第一个数的位置时正确的，想一下在拿到第一张牌的时候，没必要整理。然后3要插到5前面，把5后移一位，变成3,5,8,6,4.想一下整理牌的时候应该也是这样吧。然后8不用动，6插在8前面，8后移一位，4插在5前面，从5开始都向后移一位。注意在插入一个数的时候要保证这个数前面的数已经有序。简单插入排序的时间复杂度也是O(n^2)。 实现代码： /** *@Description:&lt;p&gt;简单插入排序算法实现&lt;/p&gt; *@author 王旭 *@time 2016-3-3 下午9:38:55 */ public class InsertSort { public static void insertSort(int[] arr) { if(arr == null || arr.length == 0) return ; for(int i=1; i&lt;arr.length; i++) { //假设第一个数位置时正确的；要往后移，必须要假设第一个。 int j = i; int target = arr[i]; //待插入的 //后移 while(j &gt; 0 &amp;&amp; target &lt; arr[j-1]) { arr[j] = arr[j-1]; j --; } //插入 arr[j] = target; } } } 快速排序 快速排序一听名字就觉得很高端，在实际应用当中快速排序确实也是表现最好的排序算法。冒泡排序虽然高端，但其实其思想是来自冒泡排序，冒泡排序是通过相邻元素的比较和交换把最小的冒泡到最顶端，而快速排序是比较和交换小数和大数，这样一来不仅把小数冒泡到上面同时也把大数沉到下面。 举个栗子：对5,3,8,6,4这个无序序列进行快速排序，思路是右指针找比基准数小的，左指针找比基准数大的，交换之。 5,3,8,6,4 用5作为比较的基准，最终会把5小的移动到5的左边，比5大的移动到5的右边。 5,3,8,6,4 首先设置i,j两个指针分别指向两端，j指针先扫描（思考一下为什么？）4比5小停止。然后i扫描，8比5大停止。交换i,j位置。 5,3,4,6,8 然后j指针再扫描，这时j扫描4时两指针相遇。停止。然后交换4和基准数。 4,3,5,6,8 一次划分后达到了左边比5小，右边比5大的目的。之后对左右子序列递归排序，最终得到有序序列。 上面留下来了一个问题为什么一定要j指针先动呢？首先这也不是绝对的，这取决于基准数的位置，因为在最后两个指针相遇的时候，要交换基准数到相遇的位置。一般选取第一个数作为基准数，那么就是在左边，所以最后相遇的数要和基准数交换，那么相遇的数一定要比基准数小。所以j指针先移动才能先找到比基准数小的数。 快速排序是不稳定的，其时间平均时间复杂度是O(nlgn)。 实现代码： /** *@Description:&lt;p&gt;实现快速排序算法&lt;/p&gt; *@author 王旭 *@time 2016-3-3 下午5:07:29 */ public class QuickSort { //一次划分 public static int partition(int[] arr, int left, int right) { int pivotKey = arr[left]; int pivotPointer = left; while(left &lt; right) { while(left &lt; right &amp;&amp; arr[right] &gt;= pivotKey) right --; while(left &lt; right &amp;&amp; arr[left] &lt;= pivotKey) left ++; swap(arr, left, right); //把大的交换到右边，把小的交换到左边。 } swap(arr, pivotPointer, left); //最后把pivot交换到中间 return left; } public static void quickSort(int[] arr, int left, int right) { if(left &gt;= right) return ; int pivotPos = partition(arr, left, right); quickSort(arr, left, pivotPos-1); quickSort(arr, pivotPos+1, right); } public static void sort(int[] arr) { if(arr == null || arr.length == 0) return ; quickSort(arr, 0, arr.length-1); } public static void swap(int[] arr, int left, int right) { int temp = arr[left]; arr[left] = arr[right]; arr[right] = temp; } } &nbsp; 其实上面的代码还可以再优化，上面代码中基准数已经在pivotKey中保存了，所以不需要每次交换都设置一个temp变量，在交换左右指针的时候只需要先后覆盖就可以了。这样既能减少空间的使用还能降低赋值运算的次数。优化代码如下： /** *@Description:&lt;p&gt;实现快速排序算法&lt;/p&gt; *@author 王旭 *@time 2016-3-3 下午5:07:29 */public class QuickSort { /** * 划分 * @param arr * @param left * @param right * @return */ public static int partition(int[] arr, int left, int right) { int pivotKey = arr[left]; while(left &lt; right) { while(left &lt; right &amp;&amp; arr[right] &gt;= pivotKey) right --; arr[left] = arr[right]; //把小的移动到左边 while(left &lt; right &amp;&amp; arr[left] &lt;= pivotKey) left ++; arr[right] = arr[left]; //把大的移动到右边 } arr[left] = pivotKey; //最后把pivot赋值到中间 return left; } /** * 递归划分子序列 * @param arr * @param left * @param right */ public static void quickSort(int[] arr, int left, int right) { if(left &gt;= right) return ; int pivotPos = partition(arr, left, right); quickSort(arr, left, pivotPos-1); quickSort(arr, pivotPos+1, right); } public static void sort(int[] arr) { if(arr == null || arr.length == 0) return ; quickSort(arr, 0, arr.length-1); } } 总结快速排序的思想：冒泡+二分+递归分治，慢慢体会。。。 堆排序 堆排序是借助堆来实现的选择排序，思想同简单的选择排序，以下以大顶堆为例。注意：如果想升序排序就使用大顶堆，反之使用小顶堆。原因是堆顶元素需要交换到序列尾部。 首先，实现堆排序需要解决两个问题： 1. 如何由一个无序序列键成一个堆？ 2. 如何在输出堆顶元素之后，调整剩余元素成为一个新的堆？ 第一个问题，可以直接使用线性数组来表示一个堆，由初始的无序序列建成一个堆就需要自底向上从第一个非叶元素开始挨个调整成一个堆。 第二个问题，怎么调整成堆？首先是将堆顶元素和最后一个元素交换。然后比较当前堆顶元素的左右孩子节点，因为除了当前的堆顶元素，左右孩子堆均满足条件，这时需要选择当前堆顶元素与左右孩子节点的较大者（大顶堆）交换，直至叶子节点。我们称这个自堆顶自叶子的调整成为筛选。 从一个无序序列建堆的过程就是一个反复筛选的过程。若将此序列看成是一个完全二叉树，则最后一个非终端节点是n/2取底个元素，由此筛选即可。举个栗子： 49,38,65,97,76,13,27,49序列的堆排序建初始堆和调整的过程如下： &nbsp; &nbsp; &nbsp; 实现代码： /** *@Description:&lt;p&gt;堆排序算法的实现，以大顶堆为例。&lt;/p&gt; *@author 王旭 *@time 2016-3-4 上午9:26:02 */public class HeapSort { /** * 堆筛选，除了start之外，start~end均满足大顶堆的定义。 * 调整之后start~end称为一个大顶堆。 * @param arr 待调整数组 * @param start 起始指针 * @param end 结束指针 */ public static void heapAdjust(int[] arr, int start, int end) { int temp = arr[start]; for(int i=2*start+1; i&lt;=end; i*=2) { //左右孩子的节点分别为2*i+1,2*i+2 //选择出左右孩子较小的下标 if(i &lt; end &amp;&amp; arr[i] &lt; arr[i+1]) { i ++; } if(temp &gt;= arr[i]) { break; //已经为大顶堆，=保持稳定性。 } arr[start] = arr[i]; //将子节点上移 start = i; //下一轮筛选 } arr[start] = temp; //插入正确的位置 } public static void heapSort(int[] arr) { if(arr == null || arr.length == 0) return ; //建立大顶堆 for(int i=arr.length/2; i&gt;=0; i--) { heapAdjust(arr, i, arr.length-1); } for(int i=arr.length-1; i&gt;=0; i--) { swap(arr, 0, i); heapAdjust(arr, 0, i-1); } } public static void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } 希尔排序 希尔排序是插入排序的一种高效率的实现，也叫缩小增量排序。简单的插入排序中，如果待排序列是正序时，时间复杂度是O(n)，如果序列是基本有序的，使用直接插入排序效率就非常高。希尔排序就利用了这个特点。基本思想是：先将整个待排记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录基本有序时再对全体记录进行一次直接插入排序。 举个栗子： &nbsp; &nbsp; 从上述排序过程可见，希尔排序的特点是，子序列的构成不是简单的逐段分割，而是将某个相隔某个增量的记录组成一个子序列。如上面的例子，第一堂排序时的增量为5，第二趟排序的增量为3。由于前两趟的插入排序中记录的关键字是和同一子序列中的前一个记录的关键字进行比较，因此关键字较小的记录就不是一步一步地向前挪动，而是跳跃式地往前移，从而使得进行最后一趟排序时，整个序列已经做到基本有序，只要作记录的少量比较和移动即可。因此希尔排序的效率要比直接插入排序高。 希尔排序的分析是复杂的，时间复杂度是所取增量的函数，这涉及一些数学上的难题。但是在大量实验的基础上推出当n在某个范围内时，时间复杂度可以达到O(n^1.3)。 实现代码： /** *@Description:&lt;p&gt;希尔排序算法实现&lt;/p&gt; *@author 王旭 *@time 2016-3-3 下午10:53:55 */public class ShellSort { /** * 希尔排序的一趟插入 * @param arr 待排数组 * @param d 增量 */ public static void shellInsert(int[] arr, int d) { for(int i=d; i&lt;arr.length; i++) { int j = i - d; int temp = arr[i]; //记录要插入的数据 while (j&gt;=0 &amp;&amp; arr[j]&gt;temp) { //从后向前，找到比其小的数的位置 arr[j+d] = arr[j]; //向后挪动 j -= d; } if (j != i - d) //存在比其小的数 arr[j+d] = temp; } } public static void shellSort(int[] arr) { if(arr == null || arr.length == 0) return ; int d = arr.length / 2; while(d &gt;= 1) { shellInsert(arr, d); d /= 2; } } } 归并排序 归并排序是另一种不同的排序方法，因为归并排序使用了递归分治的思想，所以理解起来比较容易。其基本思想是，先递归划分子问题，然后合并结果。把待排序列看成由两个有序的子序列，然后合并两个子序列，然后把子序列看成由两个有序序列。。。。。倒着来看，其实就是先两两合并，然后四四合并。。。最终形成有序序列。空间复杂度为O(n)，时间复杂度为O(nlogn)。 举个栗子： 实现代码： /** *@Description:&lt;p&gt;归并排序算法的实现&lt;/p&gt; *@author 王旭 *@time 2016-3-4 上午8:14:20 */public class MergeSort { public static void mergeSort(int[] arr) { mSort(arr, 0, arr.length-1); } /** * 递归分治 * @param arr 待排数组 * @param left 左指针 * @param right 右指针 */ public static void mSort(int[] arr, int left, int right) { if(left &gt;= right) return ; int mid = (left + right) / 2; mSort(arr, left, mid); //递归排序左边 mSort(arr, mid+1, right); //递归排序右边 merge(arr, left, mid, right); //合并 } /** * 合并两个有序数组 * @param arr 待合并数组 * @param left 左指针 * @param mid 中间指针 * @param right 右指针 */ public static void merge(int[] arr, int left, int mid, int right) { //[left, mid] [mid+1, right] int[] temp = new int[right - left + 1]; //中间数组 int i = left; int j = mid + 1; int k = 0; while(i &lt;= mid &amp;&amp; j &lt;= right) { if(arr[i] &lt;= arr[j]) { temp[k++] = arr[i++]; } else { temp[k++] = arr[j++]; } } while(i &lt;= mid) { temp[k++] = arr[i++]; } while(j &lt;= right) { temp[k++] = arr[j++]; } for(int p=0; p&lt;temp.length; p++) { arr[left + p] = temp[p]; } } } 计数排序 如果在面试中有面试官要求你写一个O(n)时间复杂度的排序算法，你千万不要立刻说：这不可能！虽然前面基于比较的排序的下限是O(nlogn)。但是确实也有线性时间复杂度的排序，只不过有前提条件，就是待排序的数要满足一定的范围的整数，而且计数排序需要比较多的辅助空间。其基本思想是，用待排序的数作为计数数组的下标，统计每个数字的个数。然后依次输出即可得到有序序列。 实现代码： /** *@Description:&lt;p&gt;计数排序算法实现&lt;/p&gt; *@author 王旭 *@time 2016-3-4 下午4:52:02 */public class CountSort { public static void countSort(int[] arr) { if(arr == null || arr.length == 0) return ; int max = max(arr); int[] count = new int[max+1]; Arrays.fill(count, 0); for(int i=0; i&lt;arr.length; i++) { count[arr[i]] ++; } int k = 0; for(int i=0; i&lt;=max; i++) { for(int j=0; j&lt;count[i]; j++) { arr[k++] = i; } } } public static int max(int[] arr) { int max = Integer.MIN_VALUE; for(int ele : arr) { if(ele &gt; max) max = ele; } return max; } } 桶排序 桶排序算是计数排序的一种改进和推广，但是网上有许多资料把计数排序和桶排序混为一谈。其实桶排序要比计数排序复杂许多。 对桶排序的分析和解释借鉴这位兄弟的文章（有改动）：http://hxraid.iteye.com/blog/647759 桶排序的基本思想： &nbsp; 假设有一组长度为N的待排关键字序列K[1….n]。首先将这个序列划分成M个的子区间(桶)&nbsp;。然后基于某种映射函数&nbsp;，将待排序列的关键字k映射到第i个桶中(即桶数组B的下标 i) ，那么该关键字k就作为B[i]中的元素(每个桶B[i]都是一组大小为N/M的序列)。接着对每个桶B[i]中的所有元素进行比较排序(可以使用快排)。然后依次枚举输出B[0]….B[M]中的全部内容即是一个有序序列。bindex=f(key)&nbsp;&nbsp; 其中，bindex 为桶数组B的下标(即第bindex个桶), k为待排序列的关键字。桶排序之所以能够高效，其关键在于这个映射函数，它必须做到：如果关键字k1&lt;k2，那么f(k1)&lt;=f(k2)。也就是说B(i)中的最小数据都要大于B(i-1)中最大数据。很显然，映射函数的确定与数据本身的特点有很大的关系。 举个栗子： 假如待排序列K= {49、&nbsp;38&nbsp;、&nbsp;35、&nbsp;97&nbsp;、&nbsp;76、&nbsp;73&nbsp;、&nbsp;27、&nbsp;49&nbsp;}。这些数据全部在1&mdash;100之间。因此我们定制10个桶，然后确定映射函数f(k)=k/10。则第一个关键字49将定位到第4个桶中(49/10=4)。依次将所有关键字全部堆入桶中，并在每个非空的桶中进行快速排序后得到如图所示。只要顺序输出每个B[i]中的数据就可以得到有序序列了。 桶排序分析： 桶排序利用函数的映射关系，减少了几乎所有的比较工作。实际上，桶排序的f(k)值的计算，其作用就相当于快排中划分，希尔排序中的子序列，归并排序中的子问题，已经把大量数据分割成了基本有序的数据块(桶)。然后只需要对桶中的少量数据做先进的比较排序即可。 对N个关键字进行桶排序的时间复杂度分为两个部分： (1) 循环计算每个关键字的桶映射函数，这个时间复杂度是O(N)。 (2) 利用先进的比较排序算法对每个桶内的所有数据进行排序，其时间复杂度为&nbsp; &sum; O(Ni*logNi) 。其中Ni 为第i个桶的数据量。 很显然，第(2)部分是桶排序性能好坏的决定因素。尽量减少桶内数据的数量是提高效率的唯一办法(因为基于比较排序的最好平均时间复杂度只能达到O(N*logN)了)。因此，我们需要尽量做到下面两点： (1) 映射函数f(k)能够将N个数据平均的分配到M个桶中，这样每个桶就有[N/M]个数据量。 (2) 尽量的增大桶的数量。极限情况下每个桶只能得到一个数据，这样就完全避开了桶内数据的&ldquo;比较&rdquo;排序操作。当然，做到这一点很不容易，数据量巨大的情况下，f(k)函数会使得桶集合的数量巨大，空间浪费严重。这就是一个时间代价和空间代价的权衡问题了。 对于N个待排数据，M个桶，平均每个桶[N/M]个数据的桶排序平均时间复杂度为： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; O(N)+O(M(N/M)log(N/M))=O(N+N(logN-logM))=O(N+NlogN-N*logM) 当N=M时，即极限情况下每个桶只有一个数据时。桶排序的最好效率能够达到O(N)。 总结：&nbsp;桶排序的平均时间复杂度为线性的O(N+C)，其中C=N*(logN-logM)。如果相对于同样的N，桶数量M越大，其效率越高，最好的时间复杂度达到O(N)。&nbsp;当然桶排序的空间复杂度&nbsp;为O(N+M)，如果输入数据非常庞大，而桶的数量也非常多，则空间代价无疑是昂贵的。此外，桶排序是稳定的。 实现代码： /** *@Description:&lt;p&gt;桶排序算法实现&lt;/p&gt; *@author 王旭 *@time 2016-3-4 下午7:39:31 */public class BucketSort { public static void bucketSort(int[] arr) { if(arr == null &amp;&amp; arr.length == 0) return ; int bucketNums = 10; //这里默认为10，规定待排数[0,100) List&lt;List&lt;Integer&gt;&gt; buckets = new ArrayList&lt;List&lt;Integer&gt;&gt;(); //桶的索引 for(int i=0; i&lt;10; i++) { buckets.add(new LinkedList&lt;Integer&gt;()); //用链表比较合适 } //划分桶 for(int i=0; i&lt;arr.length; i++) { buckets.get(f(arr[i])).add(arr[i]); } //对每个桶进行排序 for(int i=0; i&lt;buckets.size(); i++) { if(!buckets.get(i).isEmpty()) { Collections.sort(buckets.get(i)); //对每个桶进行快排 } } //还原排好序的数组 int k = 0; for(List&lt;Integer&gt; bucket : buckets) { for(int ele : bucket) { arr[k++] = ele; } } } /** * 映射函数 * @param x * @return */ public static int f(int x) { return x / 10; } } 基数排序 基数排序又是一种和前面排序方式不同的排序方式，基数排序不需要进行记录关键字之间的比较。基数排序是一种借助多关键字排序思想对单逻辑关键字进行排序的方法。所谓的多关键字排序就是有多个优先级不同的关键字。比如说成绩的排序，如果两个人总分相同，则语文高的排在前面，语文成绩也相同则数学高的排在前面。。。如果对数字进行排序，那么个位、十位、百位就是不同优先级的关键字，如果要进行升序排序，那么个位、十位、百位优先级一次增加。基数排序是通过多次的收分配和收集来实现的，关键字优先级低的先进行分配和收集。 举个栗子： &nbsp; &nbsp; 实现代码： /** *@Description:&lt;p&gt;基数排序算法实现&lt;/p&gt; *@author 王旭 *@time 2016-3-4 下午8:29:52 */public class RadixSort { public static void radixSort(int[] arr) { if(arr == null &amp;&amp; arr.length == 0) return ; int maxBit = getMaxBit(arr); for(int i=1; i&lt;=maxBit; i++) { List&lt;List&lt;Integer&gt;&gt; buf = distribute(arr, i); //分配 collecte(arr, buf); //收集 } } /** * 分配 * @param arr 待分配数组 * @param iBit 要分配第几位 * @return */ public static List&lt;List&lt;Integer&gt;&gt; distribute(int[] arr, int iBit) { List&lt;List&lt;Integer&gt;&gt; buf = new ArrayList&lt;List&lt;Integer&gt;&gt;(); for(int j=0; j&lt;10; j++) { buf.add(new LinkedList&lt;Integer&gt;()); } for(int i=0; i&lt;arr.length; i++) { buf.get(getNBit(arr[i], iBit)).add(arr[i]); } return buf; } /** * 收集 * @param arr 把分配的数据收集到arr中 * @param buf */ public static void collecte(int[] arr, List&lt;List&lt;Integer&gt;&gt; buf) { int k = 0; for(List&lt;Integer&gt; bucket : buf) { for(int ele : bucket) { arr[k++] = ele; } } } /** * 获取最大位数 * @param x * @return */ public static int getMaxBit(int[] arr) { int max = Integer.MIN_VALUE; for(int ele : arr) { int len = (ele+"").length(); if(len &gt; max) max = len; } return max; } /** * 获取x的第n位，如果没有则为0. * @param x * @param n * @return */ public static int getNBit(int x, int n) { String sx = x + ""; if(sx.length() &lt; n) return 0; else return sx.charAt(sx.length()-n) - '0'; } } 总结 在前面的介绍和分析中我们提到了冒泡排序、选择排序、插入排序三种简单的排序及其变种快速排序、堆排序、希尔排序三种比较高效的排序。后面我们又分析了基于分治递归思想的归并排序还有计数排序、桶排序、基数排序三种线性排序。我们可以知道排序算法要么简单有效，要么是利用简单排序的特点加以改进，要么是以空间换取时间在特定情况下的高效排序。但是这些排序方法都不是固定不变的，需要结合具体的需求和场景来选择甚至组合使用。才能达到高效稳定的目的。没有最好的排序，只有最适合的排序。 下面就总结一下排序算法的各自的使用场景和适用场合。 1. 从平均时间来看，快速排序是效率最高的，但快速排序在最坏情况下的时间性能不如堆排序和归并排序。而后者相比较的结果是，在n较大时归并排序使用时间较少，但使用辅助空间较多。 2. 上面说的简单排序包括除希尔排序之外的所有冒泡排序、插入排序、简单选择排序。其中直接插入排序最简单，但序列基本有序或者n较小时，直接插入排序是好的方法，因此常将它和其他的排序方法，如快速排序、归并排序等结合在一起使用。 3. 基数排序的时间复杂度也可以写成O(d*n)。因此它最使用于n值很大而关键字较小的的序列。若关键字也很大，而序列中大多数记录的最高关键字均不同，则亦可先按最高关键字不同，将序列分成若干小的子序列，而后进行直接插入排序。 4. 从方法的稳定性来比较，基数排序是稳定的内排方法，所有时间复杂度为O(n^2)的简单排序也是稳定的。但是快速排序、堆排序、希尔排序等时间性能较好的排序方法都是不稳定的。稳定性需要根据具体需求选择。 5. 上面的算法实现大多数是使用线性存储结构，像插入排序这种算法用链表实现更好，省去了移动元素的时间。具体的存储结构在具体的实现版本中也是不同的。 附：基于比较排序算法时间下限为O(nlogn)的证明： 基于比较排序下限的证明是通过决策树证明的，决策树的高度&Omega;（nlgn），这样就得出了比较排序的下限。 首先要引入决策树。 首先决策树是一颗二叉树，每个节点表示元素之间一组可能的排序，它予以京进行的比较相一致，比较的结果是树的边。 先来说明一些二叉树的性质，令T是深度为d的二叉树，则T最多有2^片树叶。 具有L片树叶的二叉树的深度至少是logL。 所以，对n个元素排序的决策树必然有n!片树叶（因为n个数有n!种不同的大小关系），所以决策树的深度至少是log(n!)，即至少需要log(n!)次比较。 而 log(n!)=logn+log(n-1)+log(n-2)+...+log2+log1 &gt;=logn+log(n-1)+log(n-2)+...+log(n/2) &gt;=(n/2)log(n/2) &gt;=(n/2)logn-n/2 =O(nlogn) 所以只用到比较的排序算法最低时间复杂度是O(nlogn)。 &nbsp;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[借助nodejs探究websocket]]></title>
      <url>%2F2017%2F04%2F08%2F%E5%80%9F%E5%8A%A9nodejs%E6%8E%A2%E7%A9%B6websocket%2F</url>
      <content type="text"><![CDATA[文章导读： 一、概述-what’s WebSocket? 二、运行在浏览器中的WebSocket客户端+使用ws模块搭建的简单服务器 三、Node中的WebSocket 四、socket.io 五、扩展阅读一、概述-what’s WebSocket? 1.1 为什么我们需要WebSocket这样的实时的通信协议？WebSocket是web通信方式的一种，像我们熟知的HTTP协议也是web通信方式的一种。但是我们知道HTTP协议是一种无状态的协议，其服务端本身不具备识别客户端的能力，必须借助外部的一些信息比如说session和cookie，才能与特定的客户端保持通信。也就是说我们所发送的每一个HTTP的请求都会带上请求头中一些相应的信息还有cookie，这明显会增加我们传输的信息的体量从而带来一定的网络延迟，对于一些对通信的实时性要求比较高的应用来说就是不可忍受的了，比如说聊天程序或者是运行在浏览器中的实时小游戏。最郁闷的却还是这些头信息和cookie往往对于服务器响应客户端的请求来说是多余的，也就是说虽然我每个请求都带了这些信息，但是服务器与客户端的交互过程中可能根本用不上这些信息。 为了改善HTTP请求的这种网络延迟的情况，也出现了一些适应不同需求的其他的[web通信]方式，比如说：轮询，长轮询( long-polling )，数据流，EventSouce等等，WebSocket便是其中一种。 实际上大多数基于因特网（或者局域网）的网络链接通常都包含长连接和基于TCP套接字的双向消息交换。但是TCP协议是属于最底层的网络通信协议了，让一些不能信任的客户端脚本去访问底层的TCP套接字显然是不太安全的，因此WebSocket实现了一种较为安全的方案，它允许客户端脚本在客户端和支持WebSocket协议的服务器之间创建双向的套接字连接。从而使实时通信的某些网络操作变得简单。 1.2 WebSocket是如何工作的？我们知道了WebSocket的主要作用是，允许服务器端与客户端进行全双工（full-duplex）的实时通信。这里有个例子特别好：HTTP协议像发电子邮件，发出后必须等待对方回信；WebSocket则是像打电话，服务器端和客户端可以同时向对方发送数据，它们之间存着一条持续打开的数据通道。 我们先看一下一个基于WebSocket协议通信的请求头和响应头(下面简单实例中的一个消息头)： 其中与WebSocket协议相关的信息： 1 Upgrade:websocket——-HTTP1.1协议规定，Upgrade头信息表示将通信协议从HTTP/1.1转向该项所指定的协议； 2 Connection:Upgrade——表示浏览器通知服务器，如果允许，就将通信协议升级到websocket协议； 3 Origin——————用于验证浏览器域名是否在服务器许可的范围内; 4 Sec-WebSocket-Key——-则是用于握手协议的密钥，是base64编码的16字节随机字符串; 5 Sec-WebSocket-Accept—-是服务器在浏览器提供的Sec-WebSocket-Key字符串后面，添加“258EAFA5-E914-47DA-95CA-C5AB0DC85B11” 字符串，然后再取sha-1的hash值。浏览器将对这个值进行验证，以证明确实是目标服务器回应了webSocket请求； 6.Sec-WebSocket-Location–一般情况下还有这个响应消息头用来表示进行通信的WebSocket网址，这里面可能是因为我例子中设置了127.0.0.1，所以这个信息省略掉了。客户端通过一个WebSocket握手的过程建立一个WebSocket连接。整个过程看起来是这个样子的： 完成握手以后，WebSocket协议就在TCP协议之上，客户端和服务器端就可以开始传送数据了。 websocket协议用ws表示，加密的websocket协议用wss协议，就像普通的HTTP协议用http表示，加密的HTTP协议用https表示一样。 下面我们就通过一些实例看一下websocket的不同实现是如何应用的。 二、 运行在浏览器中的WebSocket客户端+使用ws模块搭建的简单服务器我们可以通过跑起来这个简单的实例看一下如何编写运行在浏览器中的WebSocket客户端，并且看它是怎样与服务器端交互的。 2.1 运行实例我们把客户端代码和服务端代码准备好，然后启动服务器监听端口，比如说8080，再然后运行我们的客户端代码即可看到效果。 我们的客户端代码写在html文件中： 12345678910111213141516171819202122232425261 var onOpen = function() &#123;2 console.log(&quot;Socket opened.&quot;);3 socket.send(&quot;Hi, Server!&quot;);4 &#125;,5 onClose = function() &#123;6 console.log(&quot;Socket closed.&quot;);7 &#125;,8910 onMessage = function(data) &#123;11 console.log(&quot;We get signal:&quot;);12 console.log(data);13 &#125;,141516 onError = function() &#123;17 console.log(&quot;We got an error.&quot;);18 &#125;,1920 21 socket = new WebSocket(&quot;ws://127.0.0.1:8080/&quot;);2223 socket.onopen = onOpen;24 socket.onclose = onClose;25 socket.onerror = onError;26 socket.onmessage = onMessage; 我们通过它建立连接并且监听open和messege等事件，与此同时，我们想要得到服务器的响应。服务器端的js代码： 123456789101 var WebSocketServer = require(&apos;ws&apos;).Server; 2 var wss = new WebSocketServer(&#123; port: 8080 &#125;); 3 4 wss.on(&apos;connection&apos;, function connection(ws) &#123; 5 ws.on(&apos;message&apos;, function incoming(message) &#123; 6 console.log(&apos;received: %s&apos;, message); 7 &#125;); 8 9 ws.send(&apos;something&apos;);10 &#125;); 这个简单的websocket服务器使用了[ ws模块 ]，如果没有安装过，要先安装一下： 1 sudo npm install ws然后在我们的命令行执行： 1 node simpleWSserver.js我们的服务器启动之后，我们运行客户端代码可以看到： 浏览器： 命令行： 整个过程看起来是这个样子的： 2.2 运行在浏览器中的websocket客户端 我们在浏览器中的websocket主要做的事情无非是以下几个： 1 建立连接和关闭连接2 发送数据和接收数据3 处理错误对应的会触发以下的事件： 1onopen2onmessage3onclose4onerror2.2.1 建立连接和关闭连接 通常我们新建了一个WebSocket的实例就可以建立一个连接：1231 if(window.WebSocket != undefined) &#123;2 var socket = new WebSocket(&quot;ws://127.0.0.1:8080/&quot;);3 &#125; 建立连接之后的WebSocket实例有一个readyState属性，用来标识当前的状态： 0-正在连接1-连接成功2-正在关闭3-关闭成功连接成功后会触发onopen事件，这时我们就可以向服务器发送数据了：123451 var onOpen = function() &#123;2 console.log(&quot;Socket opened.&quot;);3 socket.send(&quot;Hi, Server!&quot;);4 &#125;5 socket.onopen = onOpen; 要是关闭连接的话就会出发onclose事件：12341 var onClose = function() &#123;2 console.log(&quot;Socket closed.&quot;);3 &#125;4 socket.onclose = onClose; 2.2.2 发送数据和接收数据 在连接建立成功后触发的onopen事件中我们通过send()方法发送数据给服务器： 1 socket.send(&quot;Hi, Server!&quot;);除了发送字符串类型的数据，也可以使用 Blob 或 ArrayBuffer 对象发送二进制数据。不仅如此，我们还可以发送JSON数据：1234567891011121 var onOpen = function() &#123; 2 var msg = &#123; 3 type: &quot;message&quot;, 4 text: &quot;something&quot;, 5 id: &quot;number&quot;, 6 date: Date.now() 7 &#125;; 8 9 // Send the msg object as a JSON-formatted string.10 socket.send(JSON.stringify(msg));11 &#125;12 socket.onopen = onOpen; 这时会触发服务器端的message事件：1231 ws.on(&apos;message&apos;, function incoming(message) &#123;2 console.log(&apos;received: %s&apos;, message);3 &#125;); 同时，服务器端发来信息的时候： 1 ws.send(&#39;something&#39;);也会触发客户端的onmessage事件：123451 var onMessage = function(data) &#123;2 console.log(&quot;We get signal:&quot;);3 console.log(data);4 &#125;5 socket.onmessage = onMessage; 2.2.3 处理错误 发生的错误会触发onerror事件：12341 var onError = function() &#123;2 console.log(&quot;We got an error.&quot;);3 &#125;4 socket.onerror = onError; 三、Node中的WebSocket WebSocket在Node中的实现[ WebSocket-Node ]使我们可以在Nodejs中使用websokcet开发客户端和服务器端实时交互的应用程序。我们可以运行客户端和服务器实时交换随机数的例子看看它是怎么工作的：node socketserver.js node socketclient.js 四、socket.io现在很流行的websocket的实现socket.io同样包括客户端和服务器端两部分。它不仅简化了接口，使得操作更容易，而且对于那些不支持WebSocket的浏览器，会自动降为Ajax连接，最大限度地保证了兼容性。它的目标是统一通信机制，使得所有浏览器和移动设备都可以进行实时通信。 4.1 socket.io与WebSocket的区别在哪里呢？websocket是浏览器对象，websocket api是浏览器提供给我们的用于浏览器和服务器实时通信的接口。 websocket在node中的实现使我们可以开发服务端程序时使用websocket的特性。 在我们使用websocket的时候，因为他是浏览器提供的接口，所以会涉及到一些兼容性和支持性的问题。如果我们对程序所运行的环境或局限不是那么了解的化，那么可能会出现问题： [ Differences between socket.io and websocket ] 。而socket.io则是进化了的websocket api。socket.io建立在websocket之上，它在合适的时候使用websocket。 4.2 socket.io实现聊天室 使用websocket或socket.io可以从一个简单的聊天室程序开始。对于socket.io来说，这非常容易。 基于 node ，这里使用express和socket.io： 1 npm install --save express@4.10.22 npm install --save socket.io那么我们就可以开始写聊天程序了。它需要的就是一个客户端的聊天窗口和一个用来接收消息和分发消息的服务器。 我们需要三个文件，分别新建：package.json,index.js,index.html. package.json: 1234567891 &#123;2 &quot;name&quot;: &quot;chat-application&quot;,3 &quot;version&quot;: &quot;0.0.1&quot;,4 &quot;description&quot;: &quot;my first socket.io app&quot;,5 &quot;dependencies&quot;: &#123;6 &quot;socket.io&quot;: &quot;^1.3.5&quot;7 &#125;8 &#125; index.js: 12345678910111213141516171819202122231 var app = require(&apos;express&apos;)(); 2 var http = require(&apos;http&apos;).Server(app); 3 var io = require(&apos;socket.io&apos;)(http); 4 5 app.get(&apos;/&apos;, function(req, res)&#123; 6 res.sendfile(&apos;index.html&apos;); 7 &#125;); 8 9 io.on(&apos;connection&apos;, function(socket)&#123;10 console.log(&apos;a user connected&apos;);11 //监听客户端的消息12 socket.on(&apos;chat message&apos;, function(msg)&#123;13 //用于将消息发送给每个人，包括发送者14 io.emit(&apos;chat message&apos;, msg);15 &#125;);16 socket.on(&apos;disconnect&apos;, function()&#123;17 console.log(&apos;user disconnected&apos;);18 &#125;);19 &#125;);2021 http.listen(3000, function()&#123;22 console.log(&apos;listening on *:3000&apos;);23 &#125;); index.html: 1234567891011121314151617181920212223242526272829303132333435361 &lt;!doctype html&gt; 2 &lt;html&gt; 3 &lt;head&gt; 4 &lt;title&gt;Socket.IO chat&lt;/title&gt; 5 &lt;style&gt; 6 * &#123; margin: 0; padding: 0; box-sizing: border-box; &#125; 7 body &#123; font: 13px Helvetica, Arial; &#125; 8 form &#123; background: #000; padding: 3px; position: fixed; bottom: 0; width: 100%; &#125; 9 form input &#123; border: 0; padding: 10px; width: 90%; margin-right: .5%; &#125;10 form button &#123; width: 9%; background: rgb(130, 224, 255); border: none; padding: 10px; &#125;11 #messages &#123; list-style-type: none; margin: 0; padding: 0; &#125;12 #messages li &#123; padding: 5px 10px; &#125;13 #messages li:nth-child(odd) &#123; background: #eee; &#125;14 &lt;/style&gt;15 &lt;/head&gt;16 &lt;body&gt;17 &lt;ul id=&quot;messages&quot;&gt;&lt;/ul&gt;18 &lt;form action=&quot;&quot;&gt;19 &lt;input id=&quot;m&quot; autocomplete=&quot;off&quot; /&gt;&lt;button&gt;Send&lt;/button&gt;20 &lt;/form&gt;21 &lt;script src=&quot;https://cdn.socket.io/socket.io-1.2.0.js&quot;&gt;&lt;/script&gt;22 &lt;script src=&quot;http://code.jquery.com/jquery-1.11.1.js&quot;&gt;&lt;/script&gt;23 &lt;script&gt;24 var socket = io();25 $(&apos;form&apos;).submit(function()&#123;26 //io.emit提供给我们可以发送给所有人的事件io.emit(&apos;some event&apos;, &#123; for: &apos;everyone&apos; &#125;);27 socket.emit(&apos;chat message&apos;, $(&apos;#m&apos;).val());28 $(&apos;#m&apos;).val(&apos;&apos;);29 return false;30 &#125;);31 socket.on(&apos;chat message&apos;, function(msg)&#123;32 $(&apos;#messages&apos;).append($(&apos;&lt;li&gt;&apos;).text(msg));33 &#125;);34 &lt;/script&gt;35 &lt;/body&gt;36 &lt;/html&gt; 先运行： node index.js在打开两个http://localhost:3000的窗口就可以开始聊天了： socket.io官网上有很详细的使用方法和教程：[ socket.io doc ] 五、扩展阅读 [ 浏览器对象-WebSocket ] [web通信] [细说WebSocket] [ WebSocket MDN ] [ WebSocket-Node implementation ] [ A Guide For WebSocket ] [ socket.IO ] [ writing websocket client ] [ deferences between socket.io and websocket ] [ websocket and socketio ] [ socket.io application ]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[nodejs模版引擎]]></title>
      <url>%2F2017%2F04%2F08%2Fnodejs%E6%A8%A1%E7%89%88%E5%BC%95%E6%93%8E%2F</url>
      <content type="text"><![CDATA[1.ejs （写法有点类jsp／php)Node 开源模板的选择很多，但推荐像我这样的老人去用 EJS，有 Classic ASP/PHP/JSP 的经验用起 EJS 来的确可以很自然，也就是说，你能够在 &lt;%…%&gt; 块中安排 JavaScript 代码，利用最传统的方式 &lt;%=输出变量%&gt;（另外 &lt;%-输出变量是不会对 &amp; 等符号进行转义的）1234567&lt;% if (names.length) &#123; %&gt; &lt;ul&gt; &lt;% names.forEach(function(name)&#123; %&gt; &lt;li foo=&apos;&lt;%= name + &quot;&apos;&quot; %&gt;&apos;&gt;&lt;%= name %&gt;&lt;/li&gt; &lt;% &#125;) %&gt; &lt;/ul&gt; &lt;% &#125; %&gt; 2. jadejade全新的Jade有两点是超出传统模板技术的。 第一、简洁。注意，简洁并非单指更少的符号，而是看是否能match你的需要。Jade强制的缩进格式能凸显html的结构，而对于前端来说，最重要的任务恰恰是处理结构，而不像一般的html author那样是处理内容。反过来说，假如你的主要任务是处理内容，比如写作blog之类的，那你应该用wiki或者markdown之类的，而不应该用Jade。 第二、html-aware传统模板技术其实是通用模板，即模板引擎并不care你输出的是html还是其他格式的文本。而Jade专为HTML设计，因此可以做许多传统模板做不到的专门针对html的优化。举个几个简单的例子： 决定如何输出属性（当属性赋值为null/false时不输出属性，为true时只需属性不需要值，这在传统模板里写起来很麻烦、代码难看易出错） 自动产生well-formed结构（甚至可决定是否要输出结束标签，而传统模板理论上也做不到这点，除非引入额外的html parse或tidy） 换行处理，避免产生额外的空白节点 对输出的变量自动进行特殊字符的encode123456789101112!!!html head title #&#123;title&#125; meta(charset=&quot;UTF-8&quot;) body div.description #&#123;description&#125; ul - each data in datas li.item(id=&apos;item_&apos;+data.index) span= data.time a.art(href=data.url)= data.title 3.handlebars123456789101112131415&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&#123;&#123;title&#125;&#125; - Page Test&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;description&quot;&gt;&#123;&#123;description&#125;&#125;&lt;/div&gt; &lt;ul&gt;&#123;&#123;#datas&#125;&#125; &lt;li class=&quot;item&quot; id=&quot;item_&#123;&#123;index&#125;&#125;&quot;&gt;&lt;span&gt;&#123;&#123;time&#125;&#125;&lt;/span&gt;&lt;a href=&quot;&#123;&#123;url&#125;&#125;&quot; class=&quot;art&quot;&gt;&#123;&#123;title&#125;&#125;&lt;/a&gt;&lt;/li&gt;&#123;&#123;/datas&#125;&#125; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 总结：Jade 很简洁，表达能力也很强，但不够直观，学习和适应成本不低。Jade 处理模板时计算量大，在没有缓存的情况下性能低是肯定的。Jade 对于一个不擅长前端、喜欢Bootstrap和Ctrl c + v 实在不能提高开发效， 性能瓶颈 Ejs 适用于写JSP/PHP后台的人使用，上手快 Handlebars 更接近前端的模版引擎，使用方便顺手]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac命令大全]]></title>
      <url>%2F2017%2F04%2F07%2FMac%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8%2F</url>
      <content type="text"><![CDATA[1.目录操作 命令名 功能描述 使用举例 mkdir 创建一个目录 mkdir dirname rmdir 删除一个目录 rmdir dirname mvdir 移动或重命名一个目录 mvdir dir1 dir2 cd 改变当前目录 cd dirname pwd 显示当前目录的路径名 pwd ls 显示当前目录的内容 ls -la dircmp 比较两个目录的内容 dircmp dir1 dir2 2.文件操作 命令名 功能描述 使用举例 cat 显示或连接文件 cat filename pg 分页格式化显示文件内容 pg filename more 分屏显示文件内容 more filename od 显示非文本文件的内容 od -c filename cp 复制文件或目录 cp file1 file2 rm 删除文件或目录 rm filename mv 改变文件名或所在目录 mv file1 file2 ln 联接文件 ln -s file1 file2 find 使用匹配表达式查找文件 find . -name “*.c” -print file 显示文件类型 file filename open 使用默认的程序打开文件 open filename 3.选择操作 命令名 功能描述 使用举例 tail 显示文件的最后几行 tail -15 filename cut 显示文件每行中的某些域 cut -f1,7 -d: /etc/passwd colrm 从标准输入中删除若干列 colrm 8 20 file2 paste 横向连接文件 paste file1 file2 diff 比较并显示两个文件的差异 diff file1 file2 sed 非交互方式流编辑器 sed “s/red/green/g” filename grep 在文件中按模式查找 grep “^[a-zA-Z]” filename awk 在文件中查找并处理模式 awk ‘{print $1 $1}’ filename sort 排序或归并文件 sort -d -f -u file1 uniq 去掉文件中的重复行 uniq file1 file2 comm 显示两有序文件的公共和非公共行 comm file1 file2 wc 统计文件的字符数、词数和行数 wc filename nl 给文件加上行号 nl file1 &gt;file2 4.安全操作 命令名 功能描述 使用举例 passwd 修改用户密码 passwd chmod 改变文件或目录的权限 chmod ug+x filename umask 定义创建文件的权限掩码 umask 027 chown 改变文件或目录的属主 chown newowner filename chgrp 改变文件或目录的所属组 chgrp staff filename xlock 给终端上锁 xlock -remote 5.编程操作 命令名 功能描述 使用举例 make 维护可执行程序的最新版本 make touch 更新文件的访问和修改时间 touch -m 05202400 filename dbx 命令行界面调试工具 dbx a.out xde 图形用户界面调试工具 xde a.out 6.进程操作 命令名 功能描述 使用举例 ps 显示进程当前状态 ps u kill 终止进程 kill -9 30142 nice 改变待执行命令的优先级 nice cc -c *.c renice 改变已运行进程的优先级 renice +20 32768 7.时间操作 命令名 功能描述 使用举例 date 显示系统的当前日期和时间 date cal 显示日历 cal 8 1996 time 统计程序的执行时间 time a.out 8.网络与通信操作 命令名 功能描述 使用举例 telnet 远程登录 telnet hpc.sp.net.edu.cn rlogin 远程登录 rlogin hostname -l username rsh 在远程主机执行指定命令 rsh f01n03 date ftp 在本地主机与远程主机之间传输文件 ftp ftp.sp.net.edu.cn rcp 在本地主机与远程主机 之间复制文件 rcp file1 host1:file2 ping 给一个网络主机发送 回应请求 ping hpc.sp.net.edu.cn mail 阅读和发送电子邮件 mail write 给另一用户发送报文 write username pts/1 mesg 允许或拒绝接收报文 mesg n 9.Korn Shell 命令 命令名 功能描述 使用举例 history 列出最近执行过的 几条命令及编号 history r 重复执行最近执行过的 某条命令 r -2 alias 给某个命令定义别名 alias del=rm -i unalias 取消对某个别名的定义 unalias del 10.其它命令 命令名 功能描述 使用举例 uname 显示操作系统的有关信息 uname -a clear 清除屏幕或窗口内容 clear env 显示当前所有设置过的环境变量 env who 列出当前登录的所有用户 who whoami 显示当前正进行操作的用户名 whoami tty 显示终端或伪终端的名称 tty stty 显示或重置控制键定义 stty -a du 查询磁盘使用情况 du -k subdir df 显示文件系统的总空间和可用空间 df /tmp w 显示当前系统活动的总信息 w]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[gogs 自动化部署]]></title>
      <url>%2F2017%2F04%2F07%2Fgogs-%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%2F</url>
      <content type="text"><![CDATA[1.创建仓库 服务器上需要配置两个 git 仓库，一个用于代码版本管理的远程仓库，一个用于用户访问的本地仓库。这里的「远程仓库」并不等同于托管代码的「中央仓库」，这两个仓库都是为了自动同步代码并部署网站而存在。在存放远程仓库的目录中（假设是 /home/ourai/repos）执行 git init –bare bridge.git 会创建一个包含 git 各种配置文件的「裸仓库」。 切换到存放用户所访问文件的目录（假设为 /home/ourai/www，如果不存在则在 /home/ourai 中执行mkdir www）：1234git initgit remote add origin /root/gogs-repositories/seateam/wxoauth.gitgit fetchgit checkout master 2.配置 Git Hook将目录切换至 xx.git/hooks，用cp post-receive.sample post-receive 拷贝并 cd /root/gogs-repositories/seateam/xx.git/hooks 用vim post-receive 修改。其内容大致如下：123456789101112#!/bin/shunset GIT_DIRNowPath=`pwd`DeployPath=&quot;/alidata/www/wxoauth&quot;cd $DeployPathgit pull origin mastercd $NowPathexit 0 使用 chmod +x post-receive 改变一下权限后，服务器端的配置就基本完成了。 3.上线与测试分开1234567891011121314151617181920212223while read oldrev newrev refnamedo if [[ $refname =~ .*/deploy$ ]]; then #!/bin/sh unset GIT_DIR NowPath=&apos;pwd&apos; DeployPath=&quot;/alidata/deploy/wxci&quot; cd $DeployPath git pull origin deploy cd $NowPath exit 0 else #!/bin/sh unset GIT_DIR NowPath=&apos;pwd&apos; DeployPath=&quot;/alidata/www/wxci&quot; cd $DeployPath git pull origin master cd $NowPath exit 0 fidone 4.挂起进程cd /alidata/gogsnohup ./gogs web &amp; 守护进程git hook 钩子，监听操作自动下载资源＝自动部署]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[shell 命令大全]]></title>
      <url>%2F2017%2F04%2F07%2Fshell-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8%2F</url>
      <content type="text"><![CDATA[1.系统信息arch 显示机器的处理器架构(1)uname -m 显示机器的处理器架构(2)uname -r 显示正在使用的内核版本dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI)hdparm -i /dev/hda 罗列一个磁盘的架构特性hdparm -tT /dev/sda 在磁盘上执行测试性读取操作cat /proc/cpuinfo 显示CPU info的信息cat /proc/interrupts 显示中断cat /proc/meminfo 校验内存使用cat /proc/swaps 显示哪些swap被使用cat /proc/version 显示内核的版本cat /proc/net/dev 显示网络适配器及统计cat /proc/mounts 显示已加载的文件系统lspci -tv 罗列 PCI 设备lsusb -tv 显示 USB 设备date 显示系统日期cal 2007 显示2007年的日历表date 041217002007.00 设置日期和时间 - 月日时分年.秒clock -w 将时间修改保存到 BIOS 2.关机 (系统的关机、重启以及登出 )shutdown -h now 关闭系统(1)init 0 关闭系统(2)telinit 0 关闭系统(3)shutdown -h hours:minutes &amp; 按预定时间关闭系统shutdown -c 取消按预定时间关闭系统shutdown -r now 重启(1)reboot 重启(2)logout 注销 3.文件和目录cd /home 进入 ‘/ home’ 目录’cd .. 返回上一级目录cd ../.. 返回上两级目录cd 进入个人的主目录cd ~user1 进入个人的主目录cd - 返回上次所在的目录pwd 显示工作路径ls 查看目录中的文件ls -F 查看目录中的文件ls -l 显示文件和目录的详细资料ls -a 显示隐藏文件ls [0-9] 显示包含数字的文件名和目录名tree 显示文件和目录由根目录开始的树形结构(1)lstree 显示文件和目录由根目录开始的树形结构(2)mkdir dir1 创建一个叫做 ‘dir1’ 的目录’mkdir dir1 dir2 同时创建两个目录mkdir -p /tmp/dir1/dir2 创建一个目录树rm -f file1 删除一个叫做 ‘file1’ 的文件’rmdir dir1 删除一个叫做 ‘dir1’ 的目录’rm -rf dir1 删除一个叫做 ‘dir1’ 的目录并同时删除其内容rm -rf dir1 dir2 同时删除两个目录及它们的内容mv dir1 new_dir 重命名/移动 一个目录cp file1 file2 复制一个文件cp dir/ . 复制一个目录下的所有文件到当前工作目录cp -a /tmp/dir1 . 复制一个目录到当前工作目录cp -a dir1 dir2 复制一个目录ln -s file1 lnk1 创建一个指向文件或目录的软链接ln file1 lnk1 创建一个指向文件或目录的物理链接touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm)file file1 outputs the mime type of the file as texticonv -l 列出已知的编码iconv -f fromEncoding -t toEncoding inputFile &gt; outputFile creates a new from the given input file by assuming it is encoded in fromEncoding and converting it to toEncoding.find . -maxdepth 1 -name .jpg -print -exec convert “{}” -resize 80x60 “thumbs/{}” \; batch resize files in the current directory and send them to a thumbnails directory (requires convert from Imagemagick) 4.文件搜索find / -name file1 从 ‘/‘ 开始进入根文件系统搜索文件和目录find / -user user1 搜索属于用户 ‘user1’ 的文件和目录find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件find / -name *.rpm -exec chmod 755 ‘{}’ \; 搜索以 ‘.rpm’ 结尾的文件并定义其权限find / -xdev -name *.rpm 搜索以 ‘.rpm’ 结尾的文件，忽略光驱、捷盘等可移动设备locate *.ps 寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令whereis halt 显示一个二进制文件、源码或man的位置which halt 显示一个二进制文件或可执行文件的完整路径 5.挂载一个文件系统mount /dev/hda2 /mnt/hda2 挂载一个叫做hda2的盘 - 确定目录 ‘/ mnt/hda2’ 已经存在umount /dev/hda2 卸载一个叫做hda2的盘 - 先从挂载点 ‘/ mnt/hda2’ 退出fuser -km /mnt/hda2 当设备繁忙时强制卸载umount -n /mnt/hda2 运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用mount /dev/fd0 /mnt/floppy 挂载一个软盘mount /dev/cdrom /mnt/cdrom 挂载一个cdrom或dvdrommount /dev/hdc /mnt/cdrecorder 挂载一个cdrw或dvdrommount /dev/hdb /mnt/cdrecorder 挂载一个cdrw或dvdrommount -o loop file.iso /mnt/cdrom 挂载一个文件或ISO镜像文件mount -t vfat /dev/hda5 /mnt/hda5 挂载一个Windows FAT32文件系统mount /dev/sda1 /mnt/usbdisk 挂载一个usb 捷盘或闪存设备mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 挂载一个windows网络共享 6.磁盘空间df -h 显示已经挂载的分区列表ls -lSr |more 以尺寸大小排列文件和目录du -sh dir1 估算目录 ‘dir1’ 已经使用的磁盘空间’du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小rpm -q -a –qf ‘%10{SIZE}t%{NAME}n’ | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统)dpkg-query -W -f=’${Installed-Size;10}t${Package}n’ | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统) 返回顶部索引 ^ 7.用户和群组groupadd group_name 创建一个新用户组groupdel group_name 删除一个用户组groupmod -n new_group_name old_group_name 重命名一个用户组useradd -c “Name Surname “ -g admin -d /home/user1 -s /bin/bash user1 创建一个属于 “admin” 用户组的用户useradd user1 创建一个新用户userdel -r user1 删除一个用户 ( ‘-r’ 排除主目录)usermod -c “User FTP” -g system -d /ftp/user1 -s /bin/nologin user1 修改用户属性passwd 修改口令passwd user1 修改一个用户的口令 (只允许root执行)chage -E 2005-12-31 user1 设置用户口令的失效期限pwck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的用户grpck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的群组newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组 8.文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消ls -lh 显示权限ls /tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限chown user1 file1 改变一个文件的所有人属性chown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性chgrp group1 file1 改变文件的群组chown user1:group1 file1 改变一个文件的所有人和群组属性find / -perm -u+s 罗列一个系统中所有使用了SUID控制的文件chmod u+s /bin/file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限chmod u-s /bin/file1 禁用一个二进制文件的 SUID位chmod g+s /home/public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的chmod g-s /home/public 禁用一个目录的 SGID 位chmod o+t /home/public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件chmod o-t /home/public 禁用一个目录的 STIKY 位 9.文件的特殊属性 - 使用 “+” 设置权限，使用 “-“ 用于取消chattr +a file1 只允许以追加方式读写文件chattr +c file1 允许这个文件能被内核自动压缩/解压chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接chattr +s file1 允许一个文件被安全地删除chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件lsattr 显示特殊的属性 10.打包和压缩文件bunzip2 file1.bz2 解压一个叫做 ‘file1.bz2’的文件bzip2 file1 压缩一个叫做 ‘file1’ 的文件gunzip file1.gz 解压一个叫做 ‘file1.gz’的文件gzip file1 压缩一个叫做 ‘file1’的文件gzip -9 file1 最大程度压缩rar a file1.rar test_file 创建一个叫做 ‘file1.rar’ 的包rar a file1.rar file1 file2 dir1 同时压缩 ‘file1’, ‘file2’ 以及目录 ‘dir1’rar x file1.rar 解压rar包unrar x file1.rar 解压rar包tar -cvf archive.tar file1 创建一个非压缩的 tarballtar -cvf archive.tar file1 file2 dir1 创建一个包含了 ‘file1’, ‘file2’ 以及 ‘dir1’的档案文件tar -tf archive.tar 显示一个包中的内容tar -xvf archive.tar 释放一个包tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包tar -xvfj archive.tar.bz2 解压一个bzip2格式的压缩包tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包tar -xvfz archive.tar.gz 解压一个gzip格式的压缩包zip file1.zip file1 创建一个zip格式的压缩包zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包unzip file1.zip 解压一个zip格式压缩包 11.RPM 包 - （Fedora, Redhat及类似系统）rpm -ivh package.rpm 安装一个rpm包rpm -ivh –nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告rpm -U package.rpm 更新一个rpm包但不改变其配置文件rpm -F package.rpm 更新一个确定已经安装的rpm包rpm -e package_name.rpm 删除一个rpm包rpm -qa 显示系统中所有已经安装的rpm包rpm -qa | grep httpd 显示所有名称中包含 “httpd” 字样的rpm包rpm -qi package_name 获取一个已安装包的特殊信息rpm -qg “System Environment/Daemons” 显示一个组件的rpm包rpm -ql package_name 显示一个已经安装的rpm包提供的文件列表rpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表rpm -q package_name –whatrequires 显示与一个rpm包存在依赖关系的列表rpm -q package_name –whatprovides 显示一个rpm包所占的体积rpm -q package_name –scripts 显示在安装/删除期间所执行的脚本lrpm -q package_name –changelog 显示一个rpm包的修改历史rpm -qf /etc/httpd/conf/httpd.conf 确认所给的文件由哪个rpm包所提供rpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表rpm –import /media/cdrom/RPM-GPG-KEY 导入公钥数字证书rpm –checksig package.rpm 确认一个rpm包的完整性rpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性rpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间rpm -Va 检查系统中所有已安装的rpm包- 小心使用rpm -Vp package.rpm 确认一个rpm包还未安装rpm2cpio package.rpm | cpio –extract –make-directories bin 从一个rpm包运行可执行文件rpm -ivh /usr/src/redhat/RPMS/arch/package.rpm 从一个rpm源码安装一个构建好的包rpmbuild –rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包 12.YUM 软件包升级器 - （Fedora, RedHat及类似系统）yum install package_name 下载并安装一个rpm包yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系yum update package_name.rpm 更新当前系统中所有安装的rpm包yum update package_name 更新一个rpm包yum remove package_name 删除一个rpm包yum list 列出当前系统中安装的所有包yum search package_name 在rpm仓库中搜寻软件包yum clean packages 清理rpm缓存删除下载的包yum clean headers 删除所有头文件yum clean all 删除所有缓存的包和头文件 13.DEB 包 (Debian, Ubuntu 以及类似系统)dpkg -i package.deb 安装/更新一个 deb 包dpkg -r package_name 从系统删除一个 deb 包dpkg -l 显示系统中所有已经安装的 deb 包dpkg -l | grep httpd 显示所有名称中包含 “httpd” 字样的deb包dpkg -s package_name 获得已经安装在系统中一个特殊包的信息dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表dpkg –contents package.deb 显示尚未安装的一个包所提供的文件列表dpkg -S /bin/ping 确认所给的文件由哪个deb包提供 14.APT 软件工具 (Debian, Ubuntu 以及类似系统)apt-get install package_name 安装/更新一个 deb 包apt-cdrom install package_name 从光盘安装/更新一个 deb 包apt-get update 升级列表中的软件包apt-get upgrade 升级所有已安装的软件apt-get remove package_name 从系统删除一个deb包apt-get check 确认依赖的软件仓库正确apt-get clean 从下载的软件包中清理缓存apt-cache search searched-package 返回包含所要搜索字符串的软件包名称 15.查看文件内容cat file1 从第一个字节开始正向查看文件的内容tac file1 从最后一行开始反向查看一个文件的内容more file1 查看一个长文件的内容less file1 类似于 ‘more’ 命令，但是它允许在文件中和正向操作一样的反向操作head -2 file1 查看一个文件的前两行tail -2 file1 查看一个文件的最后两行tail -f /var/log/messages 实时查看被添加到一个文件中的内容 16.文本处理cat file1 file2 … | command &lt;&gt; file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUTcat file1 | command( sed, grep, awk, grep, etc…) &gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中cat file1 | command( sed, grep, awk, grep, etc…) &gt;&gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中grep Aug /var/log/messages 在文件 ‘/var/log/messages’中查找关键词”Aug”grep ^Aug /var/log/messages 在文件 ‘/var/log/messages’中查找以”Aug”开始的词汇grep [0-9] /var/log/messages 选择 ‘/var/log/messages’ 文件中所有包含数字的行grep Aug -R /var/log/ 在目录 ‘/var/log’ 及随后的目录中搜索字符串”Aug”sed ‘s/stringa1/stringa2/g’ example.txt 将example.txt文件中的 “string1” 替换成 “string2”sed ‘/^$/d’ example.txt 从example.txt文件中删除所有空白行sed ‘/ #/d; /^$/d’ example.txt 从example.txt文件中删除所有注释和空白行echo ‘esempio’ | tr ‘[:lower:]’ ‘[:upper:]’ 合并上下单元格内容sed -e ‘1d’ result.txt 从文件example.txt 中排除第一行sed -n ‘/stringa1/p’ 查看只包含词汇 “string1”的行sed -e ‘s/ $//‘ example.txt 删除每一行最后的空白字符sed -e ‘s/stringa1//g’ example.txt 从文档中只删除词汇 “string1” 并保留剩余全部sed -n ‘1,5p;5q’ example.txt 查看从第一行到第5行内容sed -n ‘5p;5q’ example.txt 查看第5行sed -e ‘s/00/0/g’ example.txt 用单个零替换多个零cat -n file1 标示文件的行数cat example.txt | awk ‘NR%2==1’ 删除example.txt文件中的所有偶数行echo a b c | awk ‘{print $1}’ 查看一行第一栏echo a b c | awk ‘{print $1,$3}’ 查看一行的第一和第三栏paste file1 file2 合并两个文件或两栏的内容paste -d ‘+’ file1 file2 合并两个文件或两栏的内容，中间用”+”区分sort file1 file2 排序两个文件的内容sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份)sort file1 file2 | uniq -u 删除交集，留下其他的行sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件)comm -1 file1 file2 比较两个文件的内容只删除 ‘file1’ 所包含的内容comm -2 file1 file2 比较两个文件的内容只删除 ‘file2’ 所包含的内容comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分 17.字符设置和文件格式转换dos2unix filedos.txt fileunix.txt 将一个文本文件的格式从MSDOS转换成UNIXunix2dos fileunix.txt filedos.txt 将一个文本文件的格式从UNIX转换成MSDOSrecode ..HTML &lt; page.txt &gt; page.html 将一个文本文件转换成htmlrecode -l | more 显示所有允许的转换格式 18.文件系统分析badblocks -v /dev/hda1 检查磁盘hda1上的坏磁块fsck /dev/hda1 修复/检查hda1磁盘上linux文件系统的完整性fsck.ext2 /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性e2fsck /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性e2fsck -j /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性fsck.ext3 /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性fsck.vfat /dev/hda1 修复/检查hda1磁盘上fat文件系统的完整性fsck.msdos /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性dosfsck /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性 19.初始化一个文件系统mkfs /dev/hda1 在hda1分区创建一个文件系统mke2fs /dev/hda1 在hda1分区创建一个linux ext2的文件系统mke2fs -j /dev/hda1 在hda1分区创建一个linux ext3(日志型)的文件系统mkfs -t vfat 32 -F /dev/hda1 创建一个 FAT32 文件系统fdformat -n /dev/fd0 格式化一个软盘mkswap /dev/hda3 创建一个swap文件系统 20.SWAP文件系统mkswap /dev/hda3 创建一个swap文件系统swapon /dev/hda3 启用一个新的swap文件系统swapon /dev/hda2 /dev/hdb3 启用两个swap分区 21.备份dump -0aj -f /tmp/home0.bak /home 制作一个 ‘/home’ 目录的完整备份dump -1aj -f /tmp/home0.bak /home 制作一个 ‘/home’ 目录的交互式备份restore -if /tmp/home0.bak 还原一个交互式备份rsync -rogpav –delete /home /tmp 同步两边的目录rsync -rogpav -e ssh –delete /home ip_address:/tmp 通过SSH通道rsyncrsync -az -e ssh –delete ip_addr:/home/public /home/local 通过ssh和压缩将一个远程目录同步到本地目录rsync -az -e ssh –delete /home/local ip_addr:/home/public 通过ssh和压缩将本地目录同步到远程目录dd bs=1M if=/dev/hda | gzip | ssh user@ip_addr ‘dd of=hda.gz’ 通过ssh在远程主机上执行一次备份本地磁盘的操作dd if=/dev/sda of=/tmp/file1 备份磁盘内容到一个文件tar -Puf backup.tar /home/user 执行一次对 ‘/home/user’ 目录的交互式备份操作( cd /tmp/local/ &amp;&amp; tar c . ) | ssh -C user@ip_addr ‘cd /home/share/ &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个目录内容( tar c /home ) | ssh -C user@ip_addr ‘cd /home/backup-home &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个本地目录tar cf - . | (cd /tmp/backup ; tar xf - ) 本地将一个目录复制到另一个地方，保留原有权限及链接find /home/user1 -name ‘.txt’ | xargs cp -av –target-directory=/home/backup/ –parents 从一个目录查找并复制所有以 ‘.txt’ 结尾的文件到另一个目录find /var/log -name ‘.log’ | tar cv –files-from=- | bzip2 &gt; log.tar.bz2 查找所有以 ‘.log’ 结尾的文件并做成一个bzip包dd if=/dev/hda of=/dev/fd0 bs=512 count=1 做一个将 MBR (Master Boot Record)内容复制到软盘的动作dd if=/dev/fd0 of=/dev/hda bs=512 count=1 从已经保存到软盘的备份中恢复MBR内容 22.光盘cdrecord -v gracetime=2 dev=/dev/cdrom -eject blank=fast -force 清空一个可复写的光盘内容mkisofs /dev/cdrom &gt; cd.iso 在磁盘上创建一个光盘的iso镜像文件mkisofs /dev/cdrom | gzip &gt; cd_iso.gz 在磁盘上创建一个压缩了的光盘iso镜像文件mkisofs -J -allow-leading-dots -R -V “Label CD” -iso-level 4 -o ./cd.iso data_cd 创建一个目录的iso镜像文件cdrecord -v dev=/dev/cdrom cd.iso 刻录一个ISO镜像文件gzip -dc cd_iso.gz | cdrecord dev=/dev/cdrom - 刻录一个压缩了的ISO镜像文件mount -o loop cd.iso /mnt/iso 挂载一个ISO镜像文件cd-paranoia -B 从一个CD光盘转录音轨到 wav 文件中cd-paranoia – “-3” 从一个CD光盘转录音轨到 wav 文件中（参数-3）cdrecord –scanbus 扫描总线以识别scsi通道dd if=/dev/hdc | md5sum 校验一个设备的md5sum编码，例如一张 CD 23.网络 - （以太网和WIFI无线）ifconfig eth0 显示一个以太网卡的配置ifup eth0 启用一个 ‘eth0’ 网络设备ifdown eth0 禁用一个 ‘eth0’ 网络设备ifconfig eth0 192.168.1.1 netmask 255.255.255.0 控制IP地址ifconfig eth0 promisc 设置 ‘eth0’ 成混杂模式以嗅探数据包 (sniffing)dhclient eth0 以dhcp模式启用 ‘eth0’route -n show routing tableroute add -net 0/0 gw IP_Gateway configura default gatewayroute add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1 configure static route to reach network ‘192.168.0.0/16’route del 0/0 gw IP_gateway remove static routeecho “1” &gt; /proc/sys/net/ipv4/ip_forward activate ip routinghostname show hostname of systemhost www.example.com lookup hostname to resolve name to ip address and viceversa(1)nslookup www.example.com lookup hostname to resolve name to ip address and viceversa(2)ip link show show link status of all interfacesmii-tool eth0 show link status of ‘eth0’ethtool eth0 show statistics of network card ‘eth0’netstat -tup show all active network connections and their PIDnetstat -tupl show all network services listening on the system and their PIDtcpdump tcp port 80 show all HTTP trafficiwlist scan show wireless networksiwconfig eth1 show configuration of a wireless network cardhostname show hostnamehost www.example.com lookup hostname to resolve name to ip address and viceversanslookup www.example.com lookup hostname to resolve name to ip address and viceversawhois www.example.com lookup on Whois database Microsoft Windows networks (SAMBA)nbtscan ip_addr netbios name resolutionnmblookup -A ip_addr netbios name resolutionsmbclient -L ip_addr/hostname show remote shares of a windows hostsmbget -Rr smb://ip_addr/share like wget can download files from a host windows via smbmount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share mount a windows network share]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CI常用函数]]></title>
      <url>%2F2017%2F04%2F07%2FCI%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%2F</url>
      <content type="text"><![CDATA[选择数据$this-&gt;db-&gt;select();允许你在SQL查询中写 SELECT 部分。$this-&gt;db-&gt;where();$this-&gt;db-&gt;or_where();$this-&gt;db-&gt;where_in();允许你在SQL查询中写 WHERE部分，其余各种where语句请看手册。$this-&gt;db-&gt;get();运行选择查询语句并且返回结果集。可以获取一个表的全部数据。$this-&gt;db-&gt;like();$this-&gt;db-&gt;or_like();$this-&gt;db-&gt;not_like();本函数允许你生成 LIKE 子句，在做查询时非常有用，其余语法请看手册。$this-&gt;db-&gt;order_by();帮助你设置一个 ORDER BY 子句。$this-&gt;db-&gt;group_by();允许你编写查询语句中的 GROUP BY 部分:$this-&gt;db-&gt;distinct();为查询语句添加 “DISTINCT” 关键字:$this-&gt;db-&gt;having();允许你为你的查询语句编写 HAVING 部分。$this-&gt;db-&gt;limit();限制查询所返回的结果数量:$this-&gt;db-&gt;select_max();为你的查询编写一个 “SELECT MAX(field)”。$this-&gt;db-&gt;select_min();为你的查询编写一个 “SELECT MIN(field)” 。$this-&gt;db-&gt;select_avg();为你的查询编写一个 “SELECT AVG(field)” 。$this-&gt;db-&gt;select_sum();为你的查询编写一个 “SELECT SUM(field)” 。$this-&gt;db-&gt;join();允许你编写查询中的JOIN部分。$this-&gt;db-&gt;count_all_results();允许你获得某个特定的Active Record查询所返回的结果数量。可以使用Active Record限制函数，例如 where(), or_where(), like(), or_like() 等等。 插入数据$this-&gt;db-&gt;insert();生成一条基于你所提供的数据的SQL插入字符串并执行查询。你可以向函数传递 数组 或一个 对象。$this-&gt;db-&gt;insert_batch();一次插入多条数据，生成一条基于你所提供的数据的SQL插入字符串并执行查询。你可以向函数传递 数组 或一个 对象。$this-&gt;db-&gt;set();本函数使您能够设置inserts(插入)或updates(更新)值。它可以用来代替那种直接传递数组给插入和更新函数的方式。 更新数据$this-&gt;db-&gt;update();根据你提供的数据生成并执行一条update(更新)语句。你可以将一个数组或者对象传递给本函数。$this-&gt;db-&gt;update_batch();Generates an update string based on the data you supply, and runs the query. You can either pass an array or an object to the function. Here is an example using an array: 删除数据$this-&gt;db-&gt;delete();生成并执行一条DELETE(删除)语句。$this-&gt;db-&gt;empty_table();生成并执行一条DELETE(删除)语句。$this-&gt;db-&gt;truncate();生成并执行一条TRUNCATE(截断)语句。 链式方法 链式方法允许你以连接多个函数的方式简化你的语法。考虑一下这个范例:$this-&gt;db-&gt;select(‘title’)-&gt;from(‘mytable’)-&gt;where(‘id’, $id)-&gt;limit(10, 20);$query = $this-&gt;db-&gt;get();说明: 链式方法只能在PHP 5下面运行。 查询 $this-&gt;db-&gt;query();要提交一个查询，用以下函数：$this-&gt;db-&gt;query(‘YOUR QUERY HERE’);query() 函数以object(对象)的形式返回一个数据库结果集。 当使用 “read” 模式来运行查询时, 你可以使用“显示你的结果集”来显示查询结果; 当使用 “write” 模式来运行查询时, 将会仅根据执行的成功或失败来返回 TRUE 或 FALSE. 转义查询$this-&gt;db-&gt;escape()这个函数将会确定数据类型，以便仅对字符串类型数据进行转义。并且，它也会自动把数据用单引号括起来，所以你不必手动添加单引号，用法如下： $sql = “INSERT INTO table (title) VALUES(“.$this-&gt;db-&gt;escape($title).”)”; 查询辅助函数$this-&gt;db-&gt;insert_id()这个ID号是执行数据插入时的ID。$this-&gt;db-&gt;affected_rows()当执行写入操作（insert,update等）的查询后，显示被影响的行数。$this-&gt;db-&gt;count_all();计算出指定表的总行数并返回。在第一个参数中写入被提交的表名。 生成查询记录集result()该方法执行成功返回一个object 数组，失败则返回一个空数组。result_array()该方法执行成功时将记录集作为关联数组返回。失败时返回空数组。row()该函数将当前请求的第一行数据作为 object 返回。 你可以传递参数(参数是行的索引)以便获得某一行的数据。比如我们要获得第 5 行的数据： $row = $query-&gt;row(4); row_array()功能与 row() 一样, 区别在于该函数返回的是一个数组。除此以外, 我们还可以使用下面的方法通过游标的方式获取记录：$row = $query-&gt;first_row()$row = $query-&gt;last_row()$row = $query-&gt;next_row()$row = $query-&gt;previous_row()默认情况下他们将返回一个 object，同时你也可以传递参数 “array” 以便使用 array 的方式获取数据 $row = $query-&gt;first_row(‘array’)$row = $query-&gt;last_row(‘array’)$row = $query-&gt;next_row(‘array’)$row = $query-&gt;previous_row(‘array’) 结果集辅助函数$query-&gt;num_rows()该函数将会返回当前请求的行数。$query-&gt;num_fields()该函数返回当前请求的字段数（列数）：$query-&gt;free_result()该函数将会释放当前查询所占用的内存并删除其关联的资源标识。 自动连接 “自动连接” 功能将在每个一页面加载时被自动实例化数据库类。要启用“自动连接”，可在application/config/autoload.php中的 library 数组里添加 database：$autoload[‘libraries’] = array(‘database’); 手动连接 如果仅仅是一部分页面要求数据库连接，你可以在你有需要的函数里手工添加如下代码或者在你的类里手工添加以供该类使用。$this-&gt;load-&gt;database(); 连接多数据库 如果你需要同时连接多于一个的数据库，你可以用以下方式来实现：$DB1 = $this-&gt;load-&gt;database(‘group_one’, TRUE);$DB2 = $this-&gt;load-&gt;database(‘group_two’, TRUE); 表数据 $this-&gt;db-&gt;list_tables();返回一个包含当前连接数据库中所有表名称的数组。$this-&gt;db-&gt;table_exists();有时，在对某个表执行操作之前，使用该函数判断指定表是否存在很有用。返回一个布尔值。 数据库工具类 重要提示： 初始化数据库工具类之前，你的数据库驱动必须已经运行,因为工具类依赖于此。加载工具类： $this-&gt;load-&gt;dbutil()一旦初始化完毕，你可以通过 $this-&gt;dbutil 对象来访问成员函数：$this-&gt;dbutil-&gt;list_databases()$this-&gt;dbutil-&gt;database_exists();$this-&gt;dbutil-&gt;xml_from_result($db_result)$this-&gt;dbutil-&gt;backup() 数据库缓存类 激活缓存需要三步：1、在服务器上创建一个可写的目录以便保存缓存文件。2、在文件 application/config/database.php 中$db[‘xxxx’][‘cachedir’]设置其目录。3、激活缓存特性，可以在文件 application/config/database.php 中设置全局选项$db[‘xxxx’][‘cache_on’]=’TRUE’，也可以用以本页下面的方法手动设置。一旦被激活，每一次含有数据库查询的页面被加载时缓存就会自动发生。 当有数据库更新，我们需要删除缓存文件$this-&gt;db-&gt;cache_delete()删除缓存文件与特定网页。如果你需要清除缓存后，更新您的数据库$this-&gt;db-&gt;cache_delete(‘/blog’, ‘comments’);注意，手册上写的是 $this-&gt;db-&gt;cache_delete(‘blog’, ‘comments’);但根据实际测试应该在控制器名字前加斜杠’/‘才能正确执行。$this-&gt;db-&gt;cache_delete_all()清除所有所有的缓存文件。 数据库维护类 注意: 欲初始化数据库维护类，请确保你的数据库驱动已经运行，因为该类依赖于数据库驱动。使用如下方法载入数据库维护类:$this-&gt;load-&gt;dbforge()一旦初始化，就可以使用$this-&gt;dbforge 对象访问类中函数:$this-&gt;dbforge-&gt;create_database(‘db_name’)允许你创建由第一个参数指定的数据库。$this-&gt;dbforge-&gt;drop_database(‘db_name’)允许你删除由第一个参数指定的数据库。$this-&gt;dbforge-&gt;create_table(‘table_name’);声明了字段和键之后，你就可以创建一个表。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端知识点2]]></title>
      <url>%2F2017%2F04%2F07%2F%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B92%2F</url>
      <content type="text"><![CDATA[1,将url的查询参数解析成字典对象这个题目不约而同的出现在了多家公司的面试题中，当然也是因为太过于典型，解决方案无非就是拆字符或者用正则匹配来解决，我个人强烈建议用正则匹配，因为url允许用户随意输入，如果用拆字符的方式，有任何一处没有考虑到容错，就会导致整个js都报错。而正则就没有这个问题，他只匹配出正确的配对，非法的全部过滤掉，简单，方便。实现代码：123456789101112131415function getQueryObject(url) &#123; url = url == null ? window.location.href : url; var search = url.substring(url.lastIndexOf(&quot;?&quot;) + 1); var obj = &#123;&#125;; var reg = /([^?&amp;=]+)=([^?&amp;=]*)/g; search.replace(reg, function (rs, $1, $2) &#123; var name = decodeURIComponent($1); var val = decodeURIComponent($2); val = String(val); obj[name] = val; return rs; &#125;); return obj;&#125;getQueryObject(&quot;http://www.cnblogs.com/leee/p/4456840.html?name=1&amp;dd=ddd**&quot;) Object {name: &quot;1&quot;, dd: &quot;ddd**&quot;} 2.console.log(1+ +”2”);输出的是3等同于: 1+(+’2’)：+’2’ 的 + 是一元操作符，对 ‘2’ 进行Number()操作，转为数字的2，所以等于312console.log(&quot;A&quot;-&quot;B&quot;+&quot;2&quot;) NaN2console.log(&quot;A&quot;-&quot;B&quot;+2) NaN 3. 算法12345678910function test(a,b)&#123; console.log(b); return&#123; test:function(x)&#123; return test(x,a); &#125; &#125; &#125; var a=test(0);a.test(1);a.test(2);a.test(3); // underfined 0 0 0 4. 三次握手第一次第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。 第二次第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。完成三次握手，客户端与服务器开始传送数据，在上述过程中，还有一些重要的概念： 5. http 状态码一、HTTP状态码如果某项请求发送到您的服务器要求显示您网站上的某个网页（例如，用户通过浏览器访问您的网页或 Googlebot 抓取网页时），服务器将会返回 HTTP 状态代码以响应请求。 此状态代码提供关于请求状态的信息， 告诉 Googlebot 关于您的网站和请求的网页的信息。一些常见的状态代码包括：200 – 服务器成功返回网页404 – 请求的网页不存在503 – 服务器暂时不可用 下面提供 HTTP 状态代码的完整列表。 点击链接可了解详情。 您也可以访问有关 HTTP 状态代码的 W3C 网页以获得更多信息 。 1xx：请求收到，继续处理2xx：操作成功收到，分析、接受3xx：完成此请求必须进一步处理4xx：请求包含一个错误语法或不能完成5xx：服务器执行一个完全有效请求失败1xx （临时响应）表示临时响应并需要请求者继续执行操作的状态代码。 代码 说明100（继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。101（切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。 2xx （成功）表示服务器成功处理了请求的状态代码。 代码 说明200（成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。 如果针对您的 robots.txt 文件显示此状态，则表示 Googlebot 已成功检索到该文件。201（已创建） 请求成功并且服务器创建了新的资源。202（已接受） 服务器已接受请求，但尚未处理。203（非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。204（无内容） 服务器成功处理了请求，但没有返回任何内容。205（重置内容） 服务器成功处理了请求，但没有返回任何内容。 与 204 响应不同，此响应要求请求者重置文档视图（例如，清除表单内容以输入新内容）。206（部分内容） 服务器成功处理了部分 GET 请求。 3xx （重定向）要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。 Google 建议您在每次请求中使用重定向不要超过 5 次。 您可以使用网站管理员工具查看一下 Googlebot 在抓取重定向网页时是否遇到问题。 诊断 下的网 络抓取 页面列出了由于重定向错误而导致 Googlebot 无法抓取的网址。 代码 说明300（多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者（用户代理）选择一项操作，或提供操作列表供请求者选择。301（永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。 您应使用此代码告诉 Googlebot 某个网页或网站已永久移动到新位置。302（暂时移动） 服 务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 此代码与响应 GET 或 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个网页或网站已经移动，因为 Googlebot 会继续抓取原有位置并编入索引。303（查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。 对于除 HEAD 之外的所有请求，服务器会自动转到其他位置。304（未修改） 自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。如果网页自请求者上次请求后再也没有更改 过，您应当将服务器配置为返回此响应（称为 If-Modified-Since HTTP 标头）。 由于服务器可以告诉 Googlebot 自从上次抓取后网页没有更改过，因此可节省带宽和开销。305（使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。307（暂时重定向） 服 务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个页面或网站已经移动，因为 Googlebot 会继续抓取原有位置并编入索引。 4xx（请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。 代码 说明400（错误请求） 服务器不理解请求的语法。401（未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。403（禁止） 服务器拒绝请求。 如果您看到 Googlebot 在尝试抓取您网站上的有效网页时收到此状态代码（可以在 Google 网站管理员工具诊 断 下的网络抓取 页面上看到此信息），可能是您的服务器或主机拒绝 Googlebot 访问。404（未找到） 服务器找不到请求的网页。 例如，如果请求服务器上不存在的网页，服务器通常会返回此代码。如果您的网站上没有 robots.txt 文件，而您在 Google 网站管理员工具”诊断”标签的 robots.txt 页 上看到此状态，那么这是正确的状态。 但是，如果您有 robots.txt 文件而又看到此状态，则说明您的 robots.txt 文件可能命名错误或位于错误的位置 （该文件应当位于顶级域名，名为 robots.txt）。如果您看到有关 Googlebot 尝试抓取的网址的此状态（在”诊断”标签的 HTTP 错误页上），则表示 Googlebot 追踪的可能是另一个页面的无效链接（是旧链接或输入有误的链接）。405（禁用的方法） 禁用请求中指定的方法。406（不可接受） 无法使用请求的内容特性响应请求的网页。407（需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。 如果服务器返回此响应，还会指明请求者应当使用的代理。408（请求超时） 服务器等候请求时发生超时。409（冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 服务器在响应与前一个请求相冲突的 PUT 请求时可能会返回此代码，同时会附上两个请求的差异列表。410（已删除） 如果请求的资源已永久删除，服务器就会返回此响应。 该代码与 404（未找到）代码相似，但在资源以前存在而现在不存在的情况下，有时会用来替代 404 代码。 如果资源已永久删除，您应当使用 301 指定资源的新位置。411（需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。412（未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。413（请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。414（请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。415（不支持的媒体类型） 请求的格式不受请求页面的支持。416（请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。417（未满足期望要求） 服务器未满足”期望”请求标头字段的要求。 5xx （服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。 代码 说明500（服务器内部错误） 服务器遇到错误，无法完成请求。501（尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。502（错误网关） 服务器充当网关或代理，从上游服务器收到无效响应。503（服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。504（网关超时） 服务器充当网关或代理，但没有及时从上游服务器收到请求。505（HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。 HTML+CSS1.对WEB标准以及W3C的理解与认识标签闭合、标签小写、不乱嵌套、提高搜索机器人搜索几率、使用外 链css和js脚本、结构行为表现的分离、文件下载与页面速度更快、内容能被更多的用户所访问、内容能被更广泛的设备所访问、更少的代码和组件，容易维 护、改版方便，不需要变动页面内容、提供打印版本而不需要复制内容、提高网站易用性； 2.xhtml和html有什么区别HTML是一种基本的WEB网页设计语言，XHTML是一个基于XML的置标语言最主要的不同：XHTML 元素必须被正确地嵌套。XHTML 元素必须被关闭。标签名必须用小写字母。XHTML 文档必须拥有根元素。 3.Doctype? 严格模式与混杂模式-如何触发这两种模式，区分它们有何意义?用于声明文档使用那种规范（html/Xhtml）一般为 严格 过度 基于框架的html文档加入XMl声明可触发，解析方式更改为IE5.5 拥有IE5.5的bug 4.行内元素有哪些?块级元素有哪些?CSS的盒模型?块级元素：div p h1 h2 h3 h4 form ul行内元素: a b br i span input selectCss盒模型:内容，border ,margin，padding 5.CSS引入的方式有哪些? link和@import的区别是?内联 内嵌 外链 导入区别 ：同时加载前者无兼容性，后者CSS2.1以下浏览器不支持Link 支持使用javascript改变样式，后者不可 6.CSS选择符有哪些?哪些属性可以继承?优先级算法如何计算?内联和important哪个优先级高?标签选择符 类选择符 id选择符继承不如指定 Id&gt;class&gt;标签选择后者优先级高 7.前端页面有哪三层构成，分别是什么?作用是什么?结构层 Html 表示层 CSS 行为层 js 8.css的基本语句构成是?选择器{属性1:值1;属性2:值2;……} 9.你做的页面在哪些流览器测试过?这些浏览器的内核分别是什么?Ie(Ie内核) 火狐（Gecko） 谷歌（webkit） opear(Presto) 10.写出几种IE6 BUG的解决方法1.双边距BUG float引起的 使用display2.3像素问题 使用float引起的 使用dislpay:inline -3px3.超链接hover 点击后失效 使用正确的书写顺序 link visited hover active4.Ie z-index问题 给父级添加position:relative5.Png 透明 使用js代码 改6.Min-height 最小高度 ！Important 解决’7.select 在ie6下遮盖 使用iframe嵌套8.为什么没有办法定义1px左右的宽度容器（IE6默认的行高造成的，使用over:hidden,zoom:0.08 line-height:1px） 11.标签上title与alt属性的区别是什么?Alt 当图片不显示是 用文字代表。Title 为该属性提供信息 12.描述css reset的作用和用途。Reset重置浏览器的css默认属性 浏览器的品种不同，样式不同，然后重置，让他们统一 13.解释css sprites，如何使用。Css 精灵 把一堆小的图片整合到一张大的图片上，减轻服务器对图片的请求数量 14.浏览器标准模式和怪异模式之间的区别是什么?盒子模型 渲染模式的不同使用 window.top.document.compatMode 可显示为什么模式 15.你如何对网站的文件和资源进行优化?期待的解决方案包括：文件合并文件最小化/文件压缩使用CDN托管缓存的使用 16.什么是语义化的HTML?直观的认识标签 对于搜索引擎的抓取有好处 17.清除浮动的几种方式，各自的优缺点1.使用空标签清除浮动 clear:both（理论上能清楚任何标签，，，增加无意义的标签）2.使用overflow:auto（空标签元素清除浮动而不得不增加无意代码的弊端,,使用zoom:1用于兼容IE）3.是用afert伪元素清除浮动(用于非IE浏览器) Javascript1.javascript的typeof返回哪些数据类型Object number function boolean underfind 2.例举3种强制类型转换和2种隐式类型转换?强制（parseInt,parseFloat,number）隐式（== – ===） 3.split() join() 的区别前者是切割成数组的形式，后者是将数组转换成字符串 4.数组方法pop() push() unshift() shift()Push()尾部添加 pop()尾部删除Unshift()头部添加 shift()头部删除 5.事件绑定和普通事件有什么区别6.IE和DOM事件流的区别1.执行顺序不一样、2.参数不一样3.事件加不加on4.this指向问题 7.IE和标准下有哪些兼容性的写法Var ev = ev || window.eventdocument.documentElement.clientWidth || document.body.clientWidthVar target = ev.srcElement||ev.target 8.ajax请求的时候get 和post方式的区别一个在url后面 一个放在虚拟载体里面有大小限制安全问题应用不同 一个是论坛等只需要请求的，一个是类似修改密码的 9.call和apply的区别Object.call(this,obj1,obj2,obj3)Object.apply(this,arguments)obj.call(thisObj, arg1, arg2, …);obj.apply(thisObj, [arg1, arg2, …]);两者作用一致，都是把obj(即this)绑定到thisObj，这时候thisObj具备了obj的属性和方法。或者说thisObj『继承』了obj的属性和方法。唯一区别是apply接受的是数组参数，call接受的是连续参数。1234567function add(j, k)&#123; return j+k;&#125;function sub(j, k)&#123; return j-k;&#125; 我们在控制台运行：1234567add(5,3); //8add.call(sub, 5, 3); //8add.apply(sub, [5, 3]); //8sub(5, 3); //2sub.call(add, 5, 3); //2sub.apply(add, [5, 3]); //2 10.ajax请求时，如何解释json数据使用eval parse 鉴于安全性考虑 使用parse更靠谱11.b继承a的方法 12.写一个获取非行间样式的函数123456789101112131415161718function getStyle(obj,attr,value)&#123;if(!value)&#123;if(obj.currentStyle)&#123;return obj.currentStyle(attr)&#125;else&#123;obj.getComputedStyle(attr,false)&#125;&#125;else&#123;obj.style[attr]=value&#125;&#125; 13.事件委托是什么让利用事件冒泡的原理，让自己的所触发的事件，让他的父元素代替执行！http://www.webasily.com/?p=78 例子可见此链接 14.闭包是什么，有什么特性，对页面有什么影响闭包就是能够读取其他函数内部变量的函数。http://blog.csdn.net/gaoshanwudi/article/details/7355794 此链接可查看（问这个问题的不是一个公司） 15.如何阻止事件冒泡和默认事件canceBubble return false 16.添加 删除 替换 插入到某个接点的方法obj.appendChidl()obj.innersetBeforeobj.replaceChildobj.removeChild 17.解释jsonp的原理，以及为什么不是真正的ajax动态创建script标签，回调函数Ajax是页面无刷新请求数据操作 18.javascript的本地对象，内置对象和宿主对象本地对象为array obj regexp等可以new实例化内置对象为gload Math 等不可以实例化的宿主为浏览器自带的document,window 等 19.document load 和document ready的区别Document.onload 是在结构和样式加载完才执行jsDocument.ready原生种没有这个方法，jquery中有 $().ready(function) 20.”==”和“===”的不同前者会自动转换类型后者不会 21.javascript的同源策略一段脚本只能读取来自于同一来源的窗口和文档的属性，这里的同一来源指的是主机名、协议和端口号的组合 22.编写一个数组去重的方法function oSort(arr){ var result ={}; var newArr=[];for(var i=0;i&lt;arr.length;i++){ if(!result[arr]) { newArr.push(arr) result[arr]=1 }}return newArr} 23.cookie sessionstorage localstoragecookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。Web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者。Web Storage 的 api 接口使用更方便。24.split var str=”How are you doing today?” document.write(str.split(“ “) + ““)document.write(str.split(“”) + ““)document.write(str.split(“ “,3)) 输出：How,are,you,doing,today?H,o,w, ,a,r,e, ,y,o,u, ,d,o,i,n,g, ,t,o,d,a,y,?How,are,you 25. 对象创建过程1.分配空间。要注意的是，分配空间不光是分配子类的空间，子类对象中包含的父类对象所需要的空间，一样在这一步统一分配。在分配的空间的时候，会把所有的属性设置为默认值。 2.递归的构造父类对象。 3.初始化本类属性。 4.调用本类的构造方法。 总结一下，创建B类对象的步骤一共有5步 1.分配空间 2.初始化A类属性。 3.调用A类的构造方法. 4.初始化B的属性。 5.调用B的构造方法。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[跨域]]></title>
      <url>%2F2017%2F04%2F06%2F%E8%B7%A8%E5%9F%9F%2F</url>
      <content type="text"><![CDATA[什么是跨域JavaScript出于安全方面的考虑，不允许跨域调用其他页面的对象。但在安全限制的同时也给注入iframe或是ajax应用上带来了不少麻烦。这里把涉及到跨域的一些问题简单地整理一下：首先什么是跨域，简单地理解就是因为JavaScript同源策略的限制，a.com 域名下的js无法操作b.com或是c.a.com域名下的对象。更详细的说明可以看下表： 特别注意两点： 第一，如果是协议和端口造成的跨域问题“前台”是无能为力的，第二：在跨域问题上，域仅仅是通过“URL的首部”来识别而不会去尝试判断相同的ip地址对应着两个域或两个域是否在同一个ip上。“URL的首部”指window.location.protocol +window.location.host，也可以理解为“Domains, protocols and ports must match”。接下来简单地总结一下在“前台”一般处理跨域的办法，后台proxy这种方案牵涉到后台配置，这里就不阐述了，有兴趣的可以看看yahoo的这篇文章：《JavaScript: Use a Web Proxy for Cross-Domain XMLHttpRequest Calls》 1、document.domain+iframe的设置对于主域相同而子域不同的例子，可以通过设置document.domain的办法来解决。 具体的做法是可以在http://www.a.com/a.html和http://script.a.com/b.html两个文件中分别加上 document.domain = ‘a.com’；然后通过a.html文件中创建一个iframe，去控制iframe的contentDocument，这样两个js文件之间就可以 “交互”了。当然这种办法只能解决主域相同而二级域名不同的情况，如果你异想天开的把script.a.com的domian设为alibaba.com 那显然是会报错地！代码如下： www.a.com上的a.html12345678910document.domain = &apos;a.com&apos;;var ifr = document.createElement(&apos;iframe&apos;);ifr.src = &apos;http://script.a.com/b.html&apos;;ifr.style.display = &apos;none&apos;;document.body.appendChild(ifr);ifr.onload = function()&#123; var doc = ifr.contentDocument || ifr.contentWindow.document; // 在这里操纵b.html alert(doc.getElementsByTagName(&quot;h1&quot;)[0].childNodes[0].nodeValue);&#125;; script.a.com上的b.htmldocument.domain = ‘a.com’; 这种方式适用于{www.kuqin.com, kuqin.com, script.kuqin.com, css.kuqin.com}中的任何页面相互通信。 备注：某一页面的domain默认等于window.location.hostname。主域名是不带www的域名，例如a.com，主域名前面带前缀的通常都为二级域名或多级域名，例如www.a.com其实是二级域名。 domain只能设置为主域名，不可以在b.a.com中将domain设置为c.a.com。 问题： 1、安全性，当一个站点（b.a.com）被攻击后，另一个站点（c.a.com）会引起安全漏洞。2、如果一个页面中引入多个iframe，要想能够操作所有iframe，必须都得设置相同domain。 2、动态创建script虽然浏览器默认禁止了跨域访问，但并不禁止在页面中引用其他域的JS文件，并可以自由执行引入的JS文件中的function（包括操作cookie、Dom等等）。根据这一点，可以方便地通过创建script节点的方法来实现完全跨域的通信。具体的做法可以参考YUI的Get Utility 这里判断script节点加载完毕还是蛮有意思的：ie只能通过script的readystatechange属性，其它浏览器是script的load事件。以下是部分判断script加载完毕的方法。123456js.onload = js.onreadystatechange = function() &#123; if (!this.readyState || this.readyState === &apos;loaded&apos; || this.readyState === &apos;complete&apos;) &#123; // callback在此处执行 js.onload = js.onreadystatechange = null; &#125;&#125;; 3、利用iframe和location.hash这个办法比较绕，但是可以解决完全跨域情况下的脚步置换问题。原理是利用location.hash来进行传值。在url： http://a.com#helloword中的‘#helloworld’就是location.hash，改变hash并不会导致页面刷新，所以可 以利用hash值来进行数据传递，当然数据容量是有限的。假设域名a.com下的文件cs1.html要和cnblogs.com域名下的 cs2.html传递信息，cs1.html首先创建自动创建一个隐藏的iframe，iframe的src指向cnblogs.com域名下的 cs2.html页面，这时的hash值可以做参数传递用。cs2.html响应请求后再将通过修改cs1.html的hash值来传递数据（由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于a.com域名下的一个代理iframe；Firefox可以修改）。同时在cs1.html上加一个定时器，隔一段时间来判断location.hash的值有没有变化，一点有变化则获取获取hash值。代码如下： 先是a.com下的文件cs1.html文件：12345678910111213141516function startRequest()&#123; var ifr = document.createElement(&apos;iframe&apos;); ifr.style.display = &apos;none&apos;; ifr.src = &apos;http://www.cnblogs.com/lab/cscript/cs2.html#paramdo&apos;; document.body.appendChild(ifr);&#125;function checkHash() &#123; try &#123; var data = location.hash ? location.hash.substring(1) : &apos;&apos;; if (console.log) &#123; console.log(&apos;Now the data is &apos;+data); &#125; &#125; catch(e) &#123;&#125;;&#125;setInterval(checkHash, 2000); cnblogs.com域名下的cs2.html:12345678910111213141516171819202122//模拟一个简单的参数处理操作switch(location.hash)&#123; case &apos;#paramdo&apos;: callBack(); break; case &apos;#paramset&apos;: //do something…… break;&#125;function callBack()&#123; try &#123; parent.location.hash = &apos;somedata&apos;; &#125; catch (e) &#123; // ie、chrome的安全机制无法修改parent.location.hash， // 所以要利用一个中间的cnblogs域下的代理iframe var ifrproxy = document.createElement(&apos;iframe&apos;); ifrproxy.style.display = &apos;none&apos;; ifrproxy.src = &apos;http://a.com/test/cscript/cs3.html#somedata&apos;; // 注意该文件在&quot;a.com&quot;域下 document.body.appendChild(ifrproxy); &#125;&#125; a.com下的域名cs3.html //因为parent.parent和自身属于同一个域，所以可以改变其location.hash的值parent.parent.location.hash = self.location.hash.substring(1); 当然这样做也存在很多缺点，诸如数据直接暴露在了url中，数据容量和类型都有限等…… 4、window.name实现的跨域数据传输文章较长列在此处不便于阅读，详细请看 window.name实现的跨域数据传输（http://www.cnblogs.com/rainman/archive/2011/02/21/1960044.html）。 5、使用HTML5 postMessageHTML5中最酷的新功能之一就是 跨文档消息传输Cross Document Messaging。 下一代浏览器都将支持这个功能：Chrome 2.0+、Internet Explorer 8.0+, Firefox 3.0+, Opera 9.6+, 和 Safari 4.0+ 。 Facebook已经使用了这个功能，用postMessage支持基于web的实时消息传递。 otherWindow.postMessage(message, targetOrigin);otherWindow: 对接收信息页面的window的引用。可以是页面中iframe的contentWindow属性；window.open的返回值；通过name或下标从window.frames取到的值。message: 所要发送的数据，string类型。targetOrigin: 用于限制otherWindow，“*”表示不作限制a.com/index.html中的代码：1234567891011&lt;iframe id=&quot;ifr&quot; src=&quot;b.com/index.html&quot;&gt;&lt;/iframe&gt;&lt;script type=&quot;text/javascript&quot;&gt;window.onload = function() &#123; var ifr = document.getElementById(&apos;ifr&apos;); var targetOrigin = &apos;http://b.com&apos;; // 若写成&apos;http://b.com/c/proxy.html&apos;效果一样 // 若写成&apos;http://c.com&apos;就不会执行postMessage了 ifr.contentWindow.postMessage(&apos;I was there!&apos;, targetOrigin);&#125;;&lt;/script&gt;b.co```m/index.html中的代码： 12345678910&lt;script type=&quot;text/javascript&quot;&gt; window.addEventListener(&apos;message&apos;, function(event)&#123; // 通过origin属性判断消息来源地址 if (event.origin == &apos;http://a.com&apos;) &#123; alert(event.data); // 弹出&quot;I was there!&quot; alert(event.source); // 对a.com、index.html中window对象的引用 // 但由于同源策略，这里event.source不可以访问window对象 &#125; &#125;, false);&lt;/script&gt; 参考文章：《精通HTML5编程》第五章——跨文档消息机制、https://developer.mozilla.org/en/dom/window.postmessage 6、利用flash这是从YUI3的IO组件中看到的办法，具体可见http://developer.yahoo.com/yui/3/io/。可以看在Adobe Developer Connection看到更多的跨域代理文件规范：ross-Domain Policy File Specifications、HTTP Headers Blacklist。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端知识点1]]></title>
      <url>%2F2017%2F04%2F06%2F%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B91%2F</url>
      <content type="text"><![CDATA[1. 常用那几种浏览器测试？有哪些内核(Layout Engine)?(Q1) 浏览器：IE，Chrome，FireFox，Safari，Opera。(Q2) 内核：Trident，Gecko，Presto，Webkit。 2. 说下行内元素和块级元素的区别？行内块元素的兼容性使用？（IE8 以下）(Q1) 行内元素：会在水平方向排列，不能包含块级元素，设置width无效，height无效(可以设置line-height)，margin上下无效，padding上下无效。 块级元素：各占据一行，垂直方向排列。从新行开始结束接着一个断行。 (Q2)兼容性：display:inline-block;display:inline;zoom:1; 3. 清除浮动有哪些方式？比较好的方式是哪一种？(Q1)（1）父级div定义height。（2）结尾处加空div标签clear:both。（3）父级div定义伪类:after和zoom。（4）父级div定义overflow:hidden。（5）父级div定义overflow:auto。（6）父级div也浮动，需要定义宽度。（7）父级div定义display:table。（8）结尾处加br标签clear:both。 (Q2) 比较好的是第3种方式，好多网站都这么用。 4. box-sizing常用的属性有哪些？分别有什么作用？(Q1)box-sizing: content-box|border-box|inherit; (Q2)content-box:宽度和高度分别应用到元素的内容框。在宽度和高度之外绘制元素的内边距和边框(元素默认效果)。border-box:元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。 5. Doctype作用？标准模式与兼容模式各有什么区别?(Q1) &lt;!DOCTYPE&gt;告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。 (Q2) 标准模式的排版和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。 6. HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;？HTML5不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）。 而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。 7. 页面导入样式时，使用link和@import有什么区别？（1）link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS;（2）页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;（3）import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题。 8. 介绍一下你对浏览器内核的理解？主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。 渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、我们组建一大牛裙前面是4七一，整理讯息（例如加入CSS等），中间是零2七，以及计算网页的显示方式，后面是壹武四，是学习的就加，不是学习的请勿打扰。然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。 JS引擎则：解析和执行javascript来实现网页的动态效果。 最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。 9. html5有哪些新特性？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？(Q1)HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。(1)绘画 canvas;(2)用于媒介回放的 video 和 audio 元素;(3)本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;(4)sessionStorage 的数据在浏览器关闭后自动删除;(5)语意化更好的内容元素，比如 article、footer、header、nav、section;(6)表单控件，calendar、date、time、email、url、search;(7)新的技术webworker, websocket, Geolocation; (Q2)IE8/IE7/IE6支持通过document.createElement方法产生的标签，可以利用这一特性让这些浏览器支持HTML5新标签，浏览器支持新标签后，还需要添加标签默认的样式。当然也可以直接使用成熟的框架、比如html5shim， &lt; !–[if lt IE 9]&gt;&lt; ![endif]–&gt; 10. 简述一下你对HTML语义化的理解？用正确的标签做正确的事情。 html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的;搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO;使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。 JavaScript1. 介绍js的基本数据类型Undefined、Null、Boolean、Number、String 2. js有哪些内置对象？数据封装类对象：Object、Array、Boolean、Number 和 String其他对象：Function、Arguments、Math、Date、RegExp、Error 3. this对象的理解this总是指向函数的直接调用者（而非间接调用者）；如果有new关键字，this指向new出来的那个对象；在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window。 4. eval是做什么的？它的功能是把对应的字符串解析成JS代码并运行；应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval(‘(‘+ str +’)’)。 5. DOM怎样添加、移除、移动、复制、创建和查找节点// 创建新节点123createDocumentFragment() //创建一个DOM片段createElement() //创建一个具体的元素createTextNode() //创建一个文本节点 // 添加、移除、替换、插入1234appendChild()removeChild()replaceChild()insertBefore() //在已有的子节点前插入一个新的子节点 // 查找123getElementsByTagName() //通过标签名称getElementsByName() //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)getElementById() //通过元素Id，唯一性 6. null和undefined的区别？null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。undefined：（1）变量被声明了，但没有赋值时，就等于undefined。（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。（3）对象没有赋值的属性，该属性的值为undefined。（4）函数没有返回值时，默认返回undefined。null：（1） 作为函数的参数，表示该函数的参数不是对象。（2） 作为对象原型链的终点。 7. new操作符具体干了什么呢?（1）创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。（2）属性和方法被加入到 this 引用的对象中。（3）新创建的对象由 this 所引用，并且最后隐式的返回 this 。 8. JSON 的了解？JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小。格式：采用键值对，例如：{‘age’:’12’, ‘name’:’back’} 9. call() 和 apply() 的区别和作用？apply()函数有两个参数：第一个参数是上下文，第二个参数是参数组成的数组。如果上下文是null，则使用全局对象代替。如：function.apply(this,[1,2,3]);call()的第一个参数是上下文，后续是实例传入的参数序列。如：function.call(this,1,2,3); 10. 如何获取UA？123456function whatBrowser() &#123; document.Browser.Name.value=navigator.appName; document.Browser.Version.value=navigator.appVersion; document.Browser.Code.value=navigator.appCodeName; document.Browser.Agent.value=navigator.userAgent; &#125; 其他1. HTTP状态码知道哪些？100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息200 OK 正常返回信息201 Created 请求成功并且服务器创建了新的资源202 Accepted 服务器已接受请求，但尚未处理301 Moved Permanently 请求的网页已永久移动到新位置。302 Found 临时性重定向。303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。304 Not Modified 自从上次请求后，请求的网页未修改过。400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。401 Unauthorized 请求未授权。403 Forbidden 禁止访问。404 Not Found 找不到如何与 URI 相匹配的资源。500 Internal Server Error 最常见的服务器端错误。503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。 2. 你有哪些性能优化的方法？（1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。（2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数（3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。（4） 当需要设置的样式很多时设置className而不是直接操作style。（5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。（6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。（7） 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。 3. 什么叫优雅降级和渐进增强？优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了,为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效。渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能,向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。 4. 哪些常见操作会造成内存泄漏？内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）。 5. 线程与进程的区别一个程序至少有一个进程,一个进程至少有一个线程。线程的划分尺度小于进程，使得多线程程序的并发性高。另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML5 标签列表]]></title>
      <url>%2F2017%2F04%2F05%2F%E6%A0%87%E7%AD%BE%E5%88%97%E8%A1%A8%2F</url>
      <content type="text"><![CDATA[HTML5 &lt;article&gt; 标签article 标签是 HTML 5 的新标签, article 标签的内容独立于文档的其余部分。HTML5 &lt;canvas&gt; 标签html5 canvas 标签定义图形，比如图表和其他图像。canvas 标签只是图形容器，您必须使用脚本来绘制图形。HTML5 &lt;!--...--&gt; 标签comment 注释标签用于在源文档中插入注释。注释内容不会被浏览器显示。为代码编写注释的好处是，有助于增强代码的可读性。HTML5 &lt;!DOCTYPE&gt; 标签!DOCTYPE 文档声明必须位于 HTML5 文档中的第一行，也就是位于 html 标签之前。该标签告知浏览器文档所使用的 HTML 规范。HTML5 &lt;a&gt; 标签html5 a 标签定义超链接，用于从一个页面链接到另一个页面。a 标签最重要的属性是 href 属性，它指定链接的目标 url 。HTML5 &lt;abbr&gt; 标签abbr 标签最初是在 HTML 4.0 中引入的，表示它所包含的文本是一个更长的单词或短语的缩写形式。HTML5 &lt;address&gt; 标签address 标签定义文档作者或拥有者的联系信息。通常的做法是将 address 元素添加到网页的头部或底部。HTML5 &lt;applet&gt; 标签定义和用法 applet 定义嵌入的 applet。 HTML 5 中不支持 applet 标签 请使用 object 标签代替它。HTML5 &lt;acronym&gt; 标签定义和用法 HTML 5 不支持 acronym 标签。 请使用 abbr 标签代替它。 在 HTML 4.01 中，acronym 标签定义首字母缩略词。 如果首字母缩略词是一个单词，则可以被读出来，例如 NATO、NASA、ASAP、GUI。HTML5 &lt;area&gt; 标签area 元素始终嵌套在 map 标签内部。area 标签定义图像映射内部的区域（图像映射指的是带有可点击区域的图像）。HTML5 &lt;aside&gt; 标签html5 aside 标签定义其所处内容之外的内容。aside 标签的内容应该与附近的内容相关。HTML5 &lt;audio&gt; 标签audio 标签是 HTML 5 的新标签, audio 标签想网页中插入声音，比如音乐或其他音频流。HTML5 &lt;b&gt; 标签html5 b 标签定义粗体的文本。b 标签用于强调某些文本。如果您希望把文本标记为相比其他文本更为重要，应该使用 strong 标签。HTML5 &lt;base&gt; 标签base 标签为页面上的所有链接规定默认地址或默认目标。base 标签必须位于 head 元素内部。HTML5 &lt;basefont&gt; 标签HTML5 中不支持 basefont 标签。请用 CSS 代替。HTML5 &lt;bdi&gt; 标签bdi 标签是 HTML5 中的新标签。bdi 标签允许您设置一段文本，使其脱离其父元素的文本方向设置。HTML5 &lt;bdo&gt; 标签bdo 标签覆盖默认的文本方向。通过设置 dir 属性来设置文本的显示方向。HTML5 &lt;big&gt; 标签HTML5 中不支持 big 标签。请用 CSS 代替HTML5 &lt;blockquote&gt; 标签blockquote 标签之间的所有文本都会从常规文本中分离出来，经常会在左、右两边进行缩进，而且有时会使用斜体。HTML5 &lt;body&gt; 标签body 标签定义文档的主体。 body 标签包含文档的所有内容，比如文本、超链接、图像、表格、列表等。在 HTML 5 中，删除了所有 的特殊属性。HTML5 &lt;br&gt; 标签br 标签插入简单的换行符。br 标签是一个空标签，意味着它没有结束标签。br 标签常用来输出空行HTML5 &lt;button&gt; 标签button 标签定义按钮。您可以在 button 标签内放置内容，比如文本或图像。但是在 form 中通常使用 input 标签创建按钮。HTML5 &lt;caption&gt; 标签caption 标签定义表格的标题。caption 标签必须直接放置到 table 标签之后。通常标题会居中显示在表格上方。HTML5 &lt;center&gt; 标签HTML5 中不支持该 center 标签。请使用 CSS 代替。HTML5 &lt;cite&gt; 标签cite 标签定义作品（比如书籍、歌曲、电影、电视节目、绘画、雕塑等等）的标题，通常斜体显示。HTML5 &lt;code&gt; 标签em,strong,dfn,code,samp,kbd,var,cite 标签常用来格式话文本，使用 css 样式表可以显示更丰富的效果。HTML5 &lt;col&gt; 标签col 标签为表格中的一个或多个列定义属性值。通过使用 col 标签，可以向整个列应用样式，而不需要重复为每个单元格或每一行设置样式。HTML5 &lt;colgroup&gt; 标签通过使用 colgroup 标签，可以向整个列应用样式，而不需要重复为每个单元格或每一行设置样式。只能在 table 元素内使用 colgroup 标签。HTML5 &lt;command&gt; 标签command 元素表示用户能够调用的命令。可以用它规定键盘快捷键。只有当 command 元素位于 menu 元素内时，该元素才是可见的。HTML5 &lt;datalist&gt; 标签datalist 标签定义选项列表。请与 input 元素配合使用该元素，来定义 input 可能的值。HTML5 &lt;dd&gt; 标签dd 标签定义一个定义列表中对项目的描述。dt 标签定义列表中的项目，而 dd&gt; 标签描述这些项目。HTML5 &lt;del&gt; 标签del 标签定义文档中已删除的文本。与 ins 标签一起使用，描述文档中的更新和修正。HTML5 &lt;details&gt; 标签details 标签是 HTML 5 中的新标签。details 标签用于描述文档或文档某个部分的细节。目前只有 Chrome 支持 details 标签。HTML5 &lt;dfn&gt; 标签HTML5 &lt;dir&gt; 标签HTML5 中不支持 dir 标签。请用 CSS 代替。HTML5 &lt;div&gt; 标签div 标签常用于组合块级元素，以便通过样式表来对这些元素进行格式化。通常使用 div + css 对网页进行布局。HTML5 &lt;dl&gt; 标签dl 标签定义一个定义列表。dl 标签内部使用 dd 和 dt 定义列表中的项目。HTML5 &lt;dt&gt; 标签dt 标签定义一个定义列表中的一个项目。dd 标签描述这些项目。HTML5 &lt;em&gt; 标签HTML5 &lt;embed&gt; 标签embed 标签是 HTML 5 中的新标签。embed 标签定义嵌入的内容，比如插件。HTML5 &lt;fieldset&gt; 标签fieldset 标签会在相关表单元素周围绘制边框。fieldset 标签会在相关表单元素周围绘制边框。HTML5 &lt;figcaption&gt; 标签figcaption 标签是 HTML 5 中的新标签。figcaption 标签定义 figure 元素的标题（caption）。HTML5 &lt;figure&gt; 标签figure 标签是 HTML 5 中的新标签。figure 标签规定独立的流内容（图像、图表、照片、代码等等）。HTML5 &lt;font&gt; 标签定义和用法 在 HTML 5 中，不支持 font 标签。请用 CSS 代替它。 font 标签规定文本的字体、大小和颜色。HTML5 &lt;footer&gt; 标签footer 标签是 HTML 5 中的新标签。footer 标签定义 section 或 document 的页脚。HTML5 &lt;form&gt; 标签form 标签标签用于创建供用户输入的 HTML 表单。form 标签包含多个表单元素，如：button,input,keygen,object,output,select,textareaHTML5 &lt;frame&gt; 标签定义和用法 在 HTML 5 中不支持 frame 标签。 frame 标签定义框架集中的子窗口（框架）。 由于该标签对网页可用性的负面影响，在 HTML 5 中 frame 和 frameset 标签没有得到支持。HTML5 &lt;frameset&gt; 标签定义和用法 在 HTML 5 中不支持 frameset 标签。 frameset 标签定义框架集。它用于组织多个窗口（框架）。 由于该标签对网页可用性的负面影响，在 HTML 5 中 frame 和 frameset 标签没有得到支持。HTML5 &lt;h1 - h6&gt; 标签h1,h2,h3,h4,h5,h6 标签用来定义文档中的标题。h1 定义最大的标题。h6 定义最小的标题。HTML5 &lt;head&gt; 标签head 标签是所有头部元素的容器。位于 head 内部的元素可以包含 title,base,link,meta,script,style等。HTML5 &lt;header&gt; 标签header 标签是 HTML 5 中的新标签。header 标签定义文档的页眉（介绍信息）。HTML5 &lt;hgroup&gt; 标签hgroup 标签是 HTML 5 中的新标签。hgroup 标签用于对网页或区段（section）的标题进行组合。HTML5 &lt;hr&gt; 标签在 HTML 5 中，hr 标签定义内容中的主题变化，并显示为一条水平线。在 HTML 4.01 中，hr 标签仅仅显示为一条水平线。HTML5 &lt;html&gt; 标签html 标签告知浏览器这是一个 HTML 文档。html 元素是 HTML 文档中最外层的根元素。HTML5 &lt;i&gt; 标签i 标签定义的文本在 html 文档中呈现为斜体，以便与文档中其余部分区别开来。HTML5 &lt;iframe&gt; 标签iframe 标签创建包含另一个文档的行内框架。在 HTML 5 中，仅仅支持 src 属性。HTML5 &lt;img&gt; 标签img 标签定义 HTML 页面中的图像。img 标签定义 HTML 页面中的图像。img 标签定义 HTML 页面中的图像。HTML5 &lt;input&gt; 标签input 标签规定 form 表单中用户可输入数据的输入字段。根据不同的 type 属性，输入字段可以是文本字段、复选框、密码字段、单选按钮、按钮等。HTML5 &lt;ins&gt; 标签ins 标签定义文档的其余部分之外的插入文本。通常能够与 del 标签一起使用，来描述对文档的更新和修正。HTML5 &lt;keygen&gt; 标签keygen 是 HTML5 中的新元素。keygen 标签规定用于表单的密钥对生成器字段。当提交表单时，私钥存储在本地，公钥发送到服务器。HTML5 &lt;kbd&gt; 标签HTML5 &lt;label&gt; 标签label 标签为 input 元素定义文字标识，label 标签的 for 属性应该等于相关元素的 id 元素，以便将它们捆绑起来。HTML5 &lt;legend&gt; 标签legend 元素为以下元素定义标题（caption）：fieldset、figure、details 。 legend 元素为以下元素定义标题（caption）：fieldset、figure&gt;、details。HTML5 &lt;li&gt; 标签li 标签定义列表项，有序列表 ol 和无序列表 ul 中都使用 li 标签。 HTML 5 中，li 标签不再支持 type 属性。HTML5 &lt;link&gt; 标签link 标签定义文档与外部资源之间的关系。link 标签大多数时候都用来连接 css 样式表。link 标签只能位于head 标签中。HTML5 &lt;map&gt; 标签map 标签用于定义图像中可点击的热点区域。map 标签的 name 属性与 img 标签的 usemap 属性相关联，以创建图像与映射之间的关系HTML5 &lt;mark&gt; 标签mark 标签是 HTML 5 中的新标签。mark 标签定义带有记号的文本。请在需要突出显示文本时使用 mark 标签。HTML5 &lt;menu&gt; 标签menu 标签定义菜单列表。当希望列出表单控件时使用该标签。在 HTML 5 中，重新定义了 menu 元素，且使用用于排列表单控件。HTML5 &lt;meta&gt; 标签meta 标签位于文档的头部 head 标签中，meta 标签的属性用来定义有关页面的元信息，比如 字符集，关键词，描述，重定向等。HTML5 &lt;meter&gt; 标签meter 标签是 HTML 5 中的新标签。meter 标签定义度量的范围，既可以在元素的文本中，也可以在 min/max 属性中定义。HTML5 &lt;nav&gt; 标签nav 标签是 HTML 5 中的新标签。nav 标签定义导航链接的部分。HTML5 &lt;noframes&gt; 标签定义和用法 在 HTML 5 中不支持 noframes 标签。 noframes 标签向浏览器显示无法处理框架的提示文本。HTML5 标签noscript 元素用来定义在脚本未被执行时的替代内容（文本）。此标签用于可识别 script 标签但无法支持其中脚本的浏览器。HTML5 &lt;object&gt; 标签object 定义一个嵌入的对象。请使用此元素向您的 HTML5 页面添加多媒体。HTML5 &lt;ol&gt; 标签ol 标签定义有序列表。在 HTML 5 中，不再支持 compact 和 type 这两个属性HTML5 &lt;optgroup&gt; 标签optgroup 标签定义选项组。此元素允许您组合选项。当您使用一个长的选项列表时，对相关的选项进行组合会使处理更加容易。HTML5 &lt;option&gt; 标签option 标签定义下拉列表中的一个选项。在 HTML 5 中，option 标签也用于新元素 datalist 中。HTML5 &lt;output&gt; 标签output 标签是 HTML 5 中的新标签。output 标签定义不同类型的输出，比如脚本的输出。HTML5 &lt;p&gt; 标签p 标签定义段落。在 HTML 5 中不再支持 p 标签的 align 属性。HTML5 &lt;param&gt; 标签param 标签允许您为插入 XHTML 文档的对象规定 run-time 设置，也就是说，此标签可为包含它的 object 标签提供参数。HTML5 &lt;pre&gt; 标签pre 标签可定义预格式化的文本。pre 标签的一个常见应用就是用来表示计算机的源代码。HTML5 &lt;progress&gt; 标签progress 标签是 HTML 5 中的新标签。progress 标签定义运行中的进度（进程）。HTML5 &lt;q&gt; 标签q 标签定义一个短的引用。浏览器经常会在这种引用的周围插入引号。HTML5 &lt;rp&gt; 标签rp 标签是 HTML 5 的新标签。rp 标签在 ruby 注释中使用，以定义不支持 ruby 元素的浏览器所显示的内容。HTML5 &lt;ruby&gt; 标签ruby 标签是 HTML 5 的新标签。ruby 标签定义 ruby 注释（中文注音或字符）。HTML5 &lt;s&gt; 标签s 标签定义加删除线的文本。HTML 5 中不再支持 s 标签。HTML5 &lt;samp&gt; 标签HTML5 &lt;script&gt; 标签script 标签用于定义客户端脚本，比如 JavaScript。script 元素既可包含脚本语句，也可以通过 src 属性指向外部脚本文件。HTML5 &lt;select&gt; 标签select 标签创建下拉列表。请在 form 元素中使用此标签来接受用户的输入HTML5 &lt;small&gt; 标签在 HTML5 中，small 元素定义旁注信息，并显示为更小的文本。对于由 em 元素强调过的或由 strong 元素标记为重要的文本，small 元素不会取消对文本的强调，也不会降低这些文本的重要性。HTML5 &lt;source&gt; 标签source 标签是 HTML 5 中的新标签。source 标签为媒介元素（比如 video 和 audio）定义媒介资源。HTML5 &lt;span&gt; 标签span 标签用于对文档中的行内元素进行组合,以便通过样式表 css 对它们进行格式化。HTML5 &lt;strike&gt; 标签定义和用法 在 HTML 5 中不支持 strike 标签。请使用 CSS 代替。 strike 标签定义加删除线的文本。请使用 del 标签代替。HTML5 &lt;strong&gt; 标签HTML5 &lt;style&gt; 标签style 标签定义 HTML 文档的样式信息。scoped 属性是 HTML 5 中的新属性，它允许我们为文档的指定部分定义样式，而不是整个文档。HTML5 &lt;sub&gt; 标签sub 标签可定义下标文本。sup 可定义上标文本。HTML5 &lt;summary&gt; 标签summary 标签是 HTML 5 中的新标签。是 details 元素的第一个子元素，定义 details 元素的标题。HTML5 &lt;sup&gt; 标签HTML5 &lt;table&gt; 标签table 标签定义 HTML 表格。一个简单的 HTML 表格包括 table 元素，一个或多个 tr、th 以及 td 元素。HTML5 &lt;tbody&gt; 标签使用 tbody 标签，可以将表格分为一个单独的部分。tbody 标签可将表格中的一行或几行合成一组。在 HTML 5 中，不支持 tbody 标签的任何属性。HTML5 &lt;td&gt; 标签td 标签定义 HTML 表格中的标准单元格。thead 元素中只能使用 th 标签按，不允许使用 td 标签。HTML5 &lt;textarea&gt; 标签textarea 定义一个多行的文本输入区域。文本区中的默认字体是等宽字体 (fixed pitch)。HTML5 &lt;tfoot&gt; 标签tfoot 定义表格的页脚（脚注），tfoot 内部必须拥有 tr 标签！tfoot 表亲必须位于 table 标签内。HTML5 &lt;th&gt; 标签th 标签定义 HTML 表格中的表头单元格。th 元素中的文本呈现为粗体并且居中。th 标签在 tr 标签中定义。HTML5 &lt;thead&gt; 标签thead 标签在 table 标签中使用，定义表格的表头。thead 内部必须拥有 tr 标签！HTML5 &lt;time&gt; 标签time 标签是 HTML 5 中的新标签。time 标签定义公历的时间（24 小时制）或日期，时间和时区偏移是可选的。HTML5 &lt;title&gt; 标签title 位于 head 部分，用来定义文档的标题。title 元素在所有 HTML 文档中是必需且唯一的。HTML5 &lt;tr&gt; 标签tr 标签定义表格中的行，一个 tr 元素包含一个或多个 td 或 th 标签。HTML5 &lt;track&gt; 标签track 标签是 HTML 5 中的新标签。track 标签为诸如 video 元素之类的媒介规定外部字幕文件或其他包含的文版文件。HTML5 &lt;tt&gt; 标签定义和用法 在 HTML 5 中不支持 tt 标签。 tt 标签定义打字机文本。HTML5 &lt;u&gt; 标签在 HTML 5 中不支持 u 标签HTML5 &lt;ul&gt; 标签ul 标签定义无序列表。请使用 CSS 来定义列表的显示样式。HTML5 &lt;var&gt; 标签HTML5 &lt;video&gt; 标签video 标签是 HTML 5 的新标签。video 标签定义视频，比如电影片段或其他视频流。HTML5 &lt;wbr&gt; 标签wbr 标签是 HTML 5 中的新标签。wbr 规定在文本中的何处适合添加换行符。HTML5 &lt;rt&gt; 标签定义和用法 rt 标签定义字符（中文注音或字符）的解释或发音。 ruby 注释是中文注音或字符。 在东亚使用，显示的是东亚字符的发音。 与 ruby 以及 rt 标签一同使用： ruby 元素由一个或多个字符（需要一个解释/发音）和一个提供该信息的 rt 元素组成，还包括可选的 rp 元素，定义当浏览器不支持 ruby 元素时显示的内容。 实例 一个 ruby 注释： ruby漢 rt ㄏㄢˋ /rt/ruby HTML 4.01 与 HTML 5 之间的差异 rt 标签是 HTML 5 的新标HTML5 &lt;section&gt; 标签section 标签是 HTML 5 中的新标签。section 标签定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F03%2F09%2Fhello-world%2F</url>
      <content type="text"><![CDATA[环境准备需要git,Node.js环境 安装hexo利用 npm 命令即可安装。（在任意位置点击鼠标右键，选择Git bash） 1npm install -g hexo 创建hexo文件夹选择存放hexo文件的位置,执行以下指令(Git bash终端下)，Hexo即会自动在目标文件夹建立网站所需要的所有文件。 1hexo init 安装依赖包1npm install 本地查看现在我们已经搭建起本地的hexo博客了，执行以下命令(在hexo文件下)，然后到浏览器输入localhost:4000看看。 12hexo generate #此命令是生成静态页面，不执行该命令也可以hexo server 到此，本地服务以及搭建好了。 打包上传到github如果没有github账户，则需要注册 创建仓库，配置ssh秘钥 注意：Repository name命名规则：你的github账号.github.io (这个一定要这么命名，具体我也不清楚) hexo使用目录结构12345678910├── .deploy #需要部署的文件├── node_modules #Hexo插件├── public #生成的静态网页文件├── scaffolds #模板├── source #博客正文和其他源文件，404、favicon、CNAME├── _drafts #草稿├── _posts #文章,可以用子文件来存放文章├── themes #主题├── _config.yml #全局配置文件└── package.json 配置文件的冒号“:”后面有一个空格repo: 刚刚github创库地址.githexo命令行使用12345678hexo help #查看帮助hexo init #初始化一个目录hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成网页，可以在 public 目录查看整个网站的文件hexo server #本地预览，&apos;Ctrl+C&apos;关闭hexo deploy #部署.deploy目录hexo clean #清除缓存，**强烈建议每次执行命令前先清理缓存，每次部署前先删除 .deploy 文件夹** 简写 1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 编辑文章新建文章1hexo new &quot;标题&quot; 在 _posts 目录下会生成文件 标题.md12345678910title: Hello Worlddate: 2015-07-30 07:56:29 #发表日期，一般不改动categories: hexo #文章文类tags: [hexo,github] #文章标签，多于一项时用这种格式---正文，使用Markdown语法书写编辑完后保存，hexo server 预览hexo部署执行下列指令即可完成部署。 123hexo generatehexo deployhexo deploy问题：Deployer not found: git 1npm install hexo-deployer-git --save 重新deploy即可 图片我这里是使用本地的图片 安装 1npm install hexo-asset-image --save 安装该插件后，每次hexo new 新建博文后，会在该文件同级目录下生成一个和文件同名的文件夹，该文件夹就是用来存放图片的确保你的_config.yml 配置 post_asset_folder: true然后使用1![logo](logo.jpg) 在博文中插入logo.jpg. 来源：http://wuxiaolong.me/2015/07/31/build-blog-by-hexo/http://www.tuicool.com/articles/umEBVfI]]></content>
    </entry>

    
  
  
</search>
