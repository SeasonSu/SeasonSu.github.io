<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[前端样式代码块]]></title>
      <url>%2F2017%2F07%2F18%2F%E5%89%8D%E7%AB%AF%E6%A0%B7%E5%BC%8F%E4%BB%A3%E7%A0%81%E5%9D%97%2F</url>
      <content type="text"><![CDATA[瀑布流布局123456789101112131415161718192021222324252627282930313233343536373839404142434445464748.masonry &#123; -webkit-column-count: 2; -moz-column-count: 2; column-count: 2; -webkit-column-gap: 0; -moz-column-gap: 0; column-gap: 0; counter-reset: item-counter; padding:10rpx;&#125;.item &#123; box-sizing: border-box; -webkit-column-break-inside: avoid; page-break-inside: avoid; break-inside: avoid; counter-increment: item-counter; padding:10rpx;&#125;.item__content &#123; position: relative; display: flex; -webkit-box-orient: vertical; -webkit-box-direction: normal; -ms-flex-direction: column; flex-direction: column; -webkit-box-pack: center; -ms-flex-pack: center; justify-content: center; -webkit-box-align: center; -ms-flex-align: center; align-items: center; min-height: 100rpx; font-size: 24rpx; box-sizing: border-box; white-space: normal; word-break: break-all; padding:15rpx;&#125;&lt;view class=&quot;masonry &quot;&gt; &lt;view class=&quot;item&quot; wx:for=&quot;&#123;&#123;list&#125;&#125;&quot; wx:key=&quot;id&quot; wx:for-item=&quot;item&quot;&gt; &lt;view class=&quot;item__content&quot;&gt; &#123;&#123;item.content&#125;&#125; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浏览器缓存机制]]></title>
      <url>%2F2017%2F07%2F04%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%2F</url>
      <content type="text"><![CDATA[浏览器缓存机制浏览器缓存的知识是前端工程师必须要掌握的，因为这些知识直接影响到你的页面的用户体验，影响到你的页面的加载策略。接下来将要详细的讲述浏览器缓存的概 念和原理，新人要仔细阅读，甚至要多次反刍，缓存的知识除了和浏览器有关，还涉及到HTTP协议，所以这也是比较难于掌握的内容。一般在硬件中，缓存在硬件中分一级缓存，二级缓存。但在软件中的缓存却不一样。狭义上讲缓存就叫高速缓存，严格讲就是将数据暂时存放到某个地方。先要声明下，我的定义可能不严格，但这是我的理解，通俗易懂。至于存到什么地方就有很多方式，可放到文件，内存中（如session），还有cache（高速缓存），还有 cookie，session，viewstate，这些是我们经常用到的，但可以认为他们是缓存数据。其实cache跟session有相似功能，但 cache可在代码中设置过期时间，依赖项。所谓依赖项（例如：微软的类cachedependcy sqlCacheDependency）当依赖项变动了，系统会通知cache过期，无效。以上只是说缓存，缓存可是有服务器缓存，客户端缓存啊。近些天研究了下客户端缓存（即浏览器缓存），我想跟大家分享，有什么不同意见可评论。估计大多数人很少说客户端缓存，包括我在内。那是因为我们编程时基本不考虑客户端缓存，书上也写得少。其实浏览器自动会管理缓存，但了解它至少知道有这么回事，有事编程还要控制客户端缓存。浏览器缓存就是当你打开一个网页，浏览器会自动下载副本到你电脑上，就相当于你另存为网页到某个地方而已，只不过这里是自动而已。当然不是浏览器能把各种 网页都能下载到本地电脑上，它是有特殊情况。一般html，后者request是get请求，而post一般不缓存。（这个后面会说到）当然客户端缓存是否需要是可以在服务端代码上控制的。那就是响应头。响应头告诉缓存器不要保留缓存，缓存器就不会缓存相应内容；如果请求信息是需要认证或者安全加密的，相应内容也不会被缓存；校验参数非常重要，如果回应中1个参数都不存在，并且没有任何信息说明保鲜期（Expires或Cache-Control）的情况下，缓存将不会存储任何副本； 最常见的校验参数是文档的最后修改时间，通过最后Last-Modified头信息可以，当一份缓存包含Last-Modified信息，他基于此信息，通过添加一个If-Modified-Since请求参数，向服务器查询：这个副本从上次查看后是否被修改了。&nbsp;HTTP&nbsp;1.1介绍了另外一个校验参数： ETag，服务器是服务器生成的唯一标识符ETag，每次副本的标签都会变化。由于服务器控制了ETag如何生成，缓存服务器可以通过If-None-Match请求的返回没变则当前副本和原件完全一致。 所有的缓存服务器都使用Last-Modified时间来确定副本是否够新，而ETag校验正变得越来越流行。响应头如果是POST模式递交数据，则返回的页面大部分不会被浏览器缓存，如果你发送内容通过URL和查询（通过GET模式），则返回的内容可以缓存下来供以后使用。HTTP协议中关于缓存的信息头关键字包括Cache-Control(HTTP1.1)，Pragma(HTTP1.0)，last-Modified，Expires等。缓存控制头 Cache-ControlCache-Control 是最重要的规则。这个字段用于指定所有缓存机制在整个请求/响应链中必须服从的指令。这些指令指定用于阻止缓存对请求或响应造成不利干扰的行为。这些指令 通常覆盖默认缓存算法。缓存指令是单向的，即请求中存在一个指令并不意味着响应中将存在同一个指令。cache-control 定义是：Cache-Control = “Cache-Control” “:” cache-directive。表 1 展示了适用的值。表 1. 常用 cache-directive 值Cache-directive说明public所有内容都将被缓存private内容只缓存到私有缓存中no-cache所有内容都不会被缓存no-store所有内容都不会被缓存到缓存或 Internet 临时文件中must-revalidation/proxy-revalidation如果缓存的内容失效，请求必须发送到服务器/代理以进行重新验证max-age=xxx (xxx is numeric)缓存的内容将在 xxx 秒后失效, 这个选项只在HTTP 1.1可用, 并如果和Last-Modified一起使用时, 优先级较高表 2 表明在不同的情形下，浏览器是将请求重新发送到服务器还是使用缓存的内容。表 2. 对 cache-directive 值的浏览器响应Cache-directive打开一个新的浏览器窗口在原窗口中单击 Enter 按钮刷新单击 Back 按钮public浏览器呈现来自缓存的页面浏览器呈现来自缓存的页面浏览器重新发送请求到服务器浏览器呈现来自缓存的页面private浏览器重新发送请求到服务器第一次，浏览器重新发送请求到服务器；此后，浏览器呈现来自缓存的页面浏览器重新发送请求到服务器浏览器呈现来自缓存的页面no-cache/no-store浏览器重新发送请求到服务器浏览器重新发送请求到服务器浏览器重新发送请求到服务器浏览器重新发送请求到服务器must-revalidation/proxy-revalidation浏览器重新发送请求到服务器第一次，浏览器重新发送请求到服务器；此后，浏览器呈现来自缓存的页面浏览器重新发送请求到服务器浏览器呈现来自缓存的页面max-age=xxx (xxx is numeric)在 xxx 秒后，浏览器重新发送请求到服务器在 xxx 秒后，浏览器重新发送请求到服务器浏览器重新发送请求到服务器在 xxx 秒后，浏览器重新发送请求到服务器Cache-Control是关于浏览器缓存的最重要的设置，因为它覆盖其他设置，比如 Expires 和 Last-Modified。另外，由于浏览器的行为基本相同，这个属性是处理跨浏览器缓存问题的最有效的方法。过期头 (Expires)Expires 头部字段提供一个日期和时间，响应在该日期和时间后被认为失效。失效的缓存条目通常不会被缓存（无论是代理缓存还是用户代理缓存）返回，除非首先通过原始 服务器（或者拥有该实体的最新副本的中介缓存）验证。（注意：cache-control max-age 和 s-maxage 将覆盖 Expires 头部。）Expires 字段接收以下格式的值：“Expires: Sun, 08 Nov 2009 03:37:26 GMT”。如果查看内容时的日期在给定的日期之前，则认为该内容没有失效并从缓存中提取出来。反之，则认为该内容失效，缓存将采取一些措施。表 3-6 表明针对不同用户操作的不同浏览器的行为。表 3. 当用户打开一个新的浏览器窗口时的失效操作&nbsp;Firefox 3.5IE&nbsp;8Chrome 3Safari 4内容没有失效浏览器呈现来自缓存的页面浏览器重新发送请求到服务器。返回代码是 200浏览器呈现来自缓存的页面浏览器呈现来自缓存的页面内容失效浏览器重新发送请求到服务器。返回代码是 200浏览器重新发送请求到服务器。返回代码是 200浏览器重新发送请求到服务器。返回代码是 200浏览器重新发送请求到服务器。返回代码是 200表 4. 当用户在原始浏览器窗口中单击 Enter 按钮时的失效操作&nbsp;Firefox 3.5IE&nbsp;8Chrome 3Safari 4内容没有失效浏览器呈现来自缓存的页面浏览器呈现来自缓存的页面浏览器重新发送请求到服务器。返回代码是 304浏览器重新发送请求到服务器。返回代码是 304内容失效浏览器重新发送请求到服务器。返回代码是 200浏览器呈现来自缓存的页面浏览器重新发送请求到服务器。返回代码是 200浏览器重新发送请求到服务器。返回代码是 200表 5. 当用户按 F5 键刷新页面时的失效操作&nbsp;Firefox 3.5IE&nbsp;8Chrome 3Safari 4内容没有失效浏览器重新发送请求到服务器。返回代码是 304浏览器重新发送请求到服务器。返回代码是 304浏览器重新发送请求到服务器。返回代码是 304浏览器重新发送请求到服务器。返回代码是 304内容失效浏览器重新发送请求到服务器。返回代码是 200浏览器重新发送请求到服务器。返回代码是 200浏览器重新发送请求到服务器。返回代码是 200浏览器重新发送请求到服务器。返回代码是 200表 6. 当用户单击 Back 或 Forward 按钮时的失效操作&nbsp;Firefox 3.5IE&nbsp;8Chrome 3Safari 4内容没有失效浏览器呈现来自缓存的页面浏览器呈现来自缓存的页面浏览器呈现来自缓存的页面浏览器呈现来自缓存的页面内容失效浏览器呈现来自缓存的页面浏览器呈现来自缓存的页面浏览器呈现来自缓存的页面浏览器重新发送请求到服务器。返回代码是 200注意：所有浏览器都假定为使用默认设置运行。控制文件是否有修改 Last-Modified/E-TagLast-Modified 实体头部字段值通常用作一个缓存验证器。简单来说，如果实体值在 Last-Modified 值之后没有被更改，则认为该缓存条目有效。ETag 响应头部字段值是一个实体标记，它提供一个 “不透明” 的缓存验证器。这可能在以下几种情况下提供更可靠的验证：不方便存储修改日期；HTTP 日期值的 one-second 解决方案不够用；或者原始服务器希望避免由于使用修改日期而导致的某些冲突。不同的浏览器有不同的配置行为。表 7-10 表明针对不同用户操作的不同浏览器的行为。表 7. 当用户打开一个新的浏览器窗口时的 Last-Modified E-Tag 操作&nbsp;Firefox 3.5IE&nbsp;8Chrome 3Safari 4内容自上次访问以来没有被修改浏览器重新发送请求到服务器。返回代码是 304浏览器重新发送请求到服务器。返回代码是 200浏览器重新发送请求到服务器。返回代码是 304浏览器重新发送请求到服务器。返回代码是 304内容自上次访问以来已经被修改浏览器重新发送请求到服务器。返回代码是 200浏览器重新发送请求到服务器。返回代码是 200浏览器重新发送请求到服务器。返回代码是 200浏览器重新发送请求到服务器。返回代码是 200表 8. 当用户在原始浏览器窗口中单击 Enter 按钮时的 Last-Modified E-Tag 操作&nbsp;Firefox 3.5IE&nbsp;8Chrome 3Safari 4内容自上次访问以来没有被修改浏览器呈现来自缓存的页面浏览器呈现来自缓存的页面浏览器重新发送请求到服务器。返回代码是 304浏览器重新发送请求到服务器。返回代码是 304内容自上次访问以来已经被修改浏览器重新发送请求到服务器。返回代码是 200浏览器呈现来自缓存的页面浏览器重新发送请求到服务器。返回代码是 200浏览器重新发送请求到服务器。返回代码是 200表 9. 当用户按 F5 键刷新页面时的 Last-Modified E-Tag 操作&nbsp;Firefox 3.5IE&nbsp;8Chrome 3Safari 4内容自上次访问以来没有被修改浏览器重新发送请求到服务器。返回代码是 304浏览器重新发送请求到服务器。返回代码是 304浏览器重新发送请求到服务器。返回代码是 304浏览器重新发送请求到服务器。返回代码是 304内容自上次访问以来已经被修改浏览器重新发送请求到服务器。返回代码是 200浏览器重新发送请求到服务器。返回代码是 200浏览器重新发送请求到服务器。返回代码是 200浏览器重新发送请求到服务器。返回代码是 200表 10. 没有缓存设置且用户单击 Back 或 Forward 按钮&nbsp;Firefox 3.5IE&nbsp;8Chrome 3Safari 4内容自上次访问以来没有被修改浏览器呈现来自缓存的页面浏览器呈现来自缓存的页面浏览器呈现来自缓存的页面浏览器呈现来自缓存的页面内容自上次访问以来已经被修改浏览器呈现来自缓存的页面浏览器呈现来自缓存的页面浏览器呈现来自缓存的页面浏览器重新发送请求到服务器。返回代码是 200注意：所有浏览器都假定使用默认设置运行。不进行任何缓存相关设置如果您不定义任何缓存相关设置，则不同的浏览器有不同的行为。有时，同一个浏览器在相同的情形下每次运行时的行为都是不同的。情况可能很复杂。另外，有些不该缓存的内容如果被缓存，将会导致安全问题。 不同的浏览器有不同的行为。表 11 展示了不同的浏览器行为。表 11. 没有缓存设置且用户打开一个新的浏览器窗口&nbsp;Firefox 3.5IE&nbsp;8Chrome 3Safari 4打开一个新页面浏览器重新发送请求到服务器。返回代码是 200浏览器重新发送请求到服务器。返回代码是 200浏览器重新发送请求到服务器。返回代码是 200浏览器重新发送请求到服务器。返回代码是 200在原始窗口中单击 Enter 按钮浏览器重新发送请求到服务器。返回代码是 200浏览器呈现来自缓存的页面。浏览器重新发送请求到服务器。返回代码是 200浏览器重新发送请求到服务器。返回代码是 200按 F5 键刷新浏览器重新发送请求到服务器。返回代码是 200浏览器重新发送请求到服务器。返回代码是 200浏览器重新发送请求到服务器。返回代码是 200浏览器重新发送请求到服务器。返回代码是 200单击 Back 或 Forward 按钮浏览器呈现来自缓存的页面。浏览器呈现来自缓存的页面。浏览器重新发送请求到服务器。返回代码是 200浏览器重新发送请求到服务器。返回代码是 200注意：所有浏览器都假定使用默认设置运行。关键结论最后, 概括下关键的结论操作行为打开新窗口如果指定cache- control的值为private、no-cache、must-revalidate,那么打开新窗口访问时都会重新访问服务器。而如果指定了 max-age值,那么在此值内的时间里就不会重新访问服务器,例如：Cache-control: max-age=5 表示当访问此网页后的5秒内再次访问不会去服务器.在地址栏回车如果值为private或must-revalidate,则只有第一次访问时会访问服务器,以后就不再访问。如果值为no-cache,那么每次都会访问。如果值为max-age,则在过期之前不会重复访问。按后退按扭如果值为private、must-revalidate、max-age,则不会重访问,而如果为no-cache,则每次都重复访问.按刷新按扭无论为何值,都会重复访问. br{ display:none; }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[canvas代码块]]></title>
      <url>%2F2017%2F06%2F26%2Fcanvas%E4%BB%A3%E7%A0%81%E5%9D%97%2F</url>
      <content type="text"><![CDATA[在画布中获取特定颜色的像素数量下面的函数将返回画布上颜色（RGB格式）为r、g、b的像素数量。如果用户希望像这篇博客文章中在另一个区域绘画，那么这将非常有用。1234567891011121314function getpixelamount(canvas, r, g, b) &#123; var cx = canvas.getContext(&apos;2d&apos;); var pixels = cx.getImageData(0, 0, canvas.width, canvas.height); var all = pixels.data.length; var amount = 0; for (i = 0; i &lt; all; i += 4) &#123; if (pixels.data[i] === r &amp;&amp; pixels.data[i + 1] === g &amp;&amp; pixels.data[i + 2] === b) &#123; amount++; &#125; &#125; return amount;&#125;; 在画布中获取某一个像素的颜色下面的代码片段返回一个对象，该对象在画布的x和y的位置上具有RGBA值。这可以用来确定鼠标光标是否在一个特定的形状中。12345678910function getpixelcolour(canvas, x, y) &#123; var cx = canvas.getContext(&apos;2d&apos;); var pixel = cx.getImageData(x, y, 1, 1); return &#123; r: pixel.data[0], g: pixel.data[1], b: pixel.data[2], a: pixel.data[3] &#125;;&#125; 链接方法这个类提供的jQuery风格的链接访问2D背景的方法和属性。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667function Canvas2DContext(canvas) &#123; if (typeof canvas === &apos;string&apos;) &#123; canvas = document.getElementById(canvas); &#125; if (!(this instanceof Canvas2DContext)) &#123; return new Canvas2DContext(canvas); &#125; this.context = this.ctx = canvas.getContext(&apos;2d&apos;); if (!Canvas2DContext.prototype.arc) &#123; Canvas2DContext.setup.call(this, this.ctx); &#125;&#125;Canvas2DContext.setup = function() &#123; var methods = [&apos;arc&apos;, &apos;arcTo&apos;, &apos;beginPath&apos;, &apos;bezierCurveTo&apos;, &apos;clearRect&apos;, &apos;clip&apos;, &apos;closePath&apos;, &apos;drawImage&apos;, &apos;fill&apos;, &apos;fillRect&apos;, &apos;fillText&apos;, &apos;lineTo&apos;, &apos;moveTo&apos;, &apos;quadraticCurveTo&apos;, &apos;rect&apos;, &apos;restore&apos;, &apos;rotate&apos;, &apos;save&apos;, &apos;scale&apos;, &apos;setTransform&apos;, &apos;stroke&apos;, &apos;strokeRect&apos;, &apos;strokeText&apos;, &apos;transform&apos;, &apos;translate&apos;]; var getterMethods = [&apos;createPattern&apos;, &apos;drawFocusRing&apos;, &apos;isPointInPath&apos;, &apos;measureText&apos;, // drawFocusRing not currently supported // The following might instead be wrapped to be able to chain their child objects &apos;createImageData&apos;, &apos;createLinearGradient&apos;, &apos;createRadialGradient&apos;, &apos;getImageData&apos;, &apos;putImageData&apos; ]; var props = [&apos;canvas&apos;, &apos;fillStyle&apos;, &apos;font&apos;, &apos;globalAlpha&apos;, &apos;globalCompositeOperation&apos;, &apos;lineCap&apos;, &apos;lineJoin&apos;, &apos;lineWidth&apos;, &apos;miterLimit&apos;, &apos;shadowOffsetX&apos;, &apos;shadowOffsetY&apos;, &apos;shadowBlur&apos;, &apos;shadowColor&apos;, &apos;strokeStyle&apos;, &apos;textAlign&apos;, &apos;textBaseline&apos;]; for (let m of methods) &#123; let method = m; Canvas2DContext.prototype[method] = function() &#123; this.ctx[method].apply(this.ctx, arguments); return this; &#125;; &#125; for (let m of getterMethods) &#123; let method = m; Canvas2DContext.prototype[method] = function() &#123; return this.ctx[method].apply(this.ctx, arguments); &#125;; &#125; for (let p of props) &#123; let prop = p; Canvas2DContext.prototype[prop] = function(value) &#123; if (value === undefined) return this.ctx[prop]; this.ctx[prop] = value; return this; &#125;; &#125;&#125;;var canvas = document.getElementById(&apos;canvas&apos;);// Use context to get access to underlying contextvar ctx = Canvas2DContext(canvas) .strokeStyle(&apos;rgb(30, 110, 210)&apos;) .transform(10, 3, 4, 5, 1, 0) .strokeRect(2, 10, 15, 20) .context;// Use property name as a function (but without arguments) to get the valuevar strokeStyle = Canvas2DContext(canvas) .strokeStyle(&apos;rgb(50, 110, 210)&apos;) .strokeStyle(); 代码只有特权代码的可使用这些片段是从特权代码仅是有用的，例如扩展或特权的应用程序。 保存画布图像文件下面的函数接受一个画布对象和目标文件路径串。画布被转换成PNG文件并保存到指定的位置。该函数返回时，该文件已被完全保存它解决的承诺。123456789101112function saveCanvas(canvas, path, type, options) &#123; return Task.spawn(function *() &#123; var reader = new FileReader; var blob = yield new Promise(accept =&gt; canvas.toBlob(accept, type, options)); reader.readAsArrayBuffer(blob); yield new Promise(accept =&gt; &#123; reader.onloadend = accept &#125;); return yield OS.File.writeAtomic(path, new Uint8Array(reader.result), &#123; tmpPath: path + &apos;.tmp&apos; &#125;); &#125;);&#125; 将一个远程页面加载到画布元素上下面的类首先创建隐藏的iframe元件并附加一个监听到所述框架的加载事件。一旦远程页面加载时，remotePageLoaded方法火灾。这种方法获取到iframe的窗口的引用，并提请该窗口的画布对象。 需要注意的是，如果你正在运行的Chrome页面这仅适用。如果您尝试运行代码作为普通的网页，你会得到一个“安全错误‘代码’1000’ 的错误。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253RemoteCanvas = function() &#123; this.url = &apos;http://developer.mozilla.org&apos;;&#125;;RemoteCanvas.CANVAS_WIDTH = 300;RemoteCanvas.CANVAS_HEIGHT = 300;RemoteCanvas.prototype.load = function() &#123; var windowWidth = window.innerWidth - 25; var iframe; iframe = document.createElement(&apos;iframe&apos;); iframe.id = &apos;test-iframe&apos;; iframe.height = &apos;10px&apos;; iframe.width = windowWidth + &apos;px&apos;; iframe.style.visibility = &apos;hidden&apos;; iframe.src = this.url; // Here is where the magic happens... add a listener to the // frame&apos;s onload event iframe.addEventListener(&apos;load&apos;, this.remotePageLoaded, true); //append to the end of the page window.document.body.appendChild(iframe); return; &#125;;RemoteCanvas.prototype.remotePageLoaded = function() &#123; // Look back up the iframe by id var ldrFrame = document.getElementById(&apos;test-iframe&apos;); // Get a reference to the window object you need for the canvas // drawWindow method var remoteWindow = ldrFrame.contentWindow; //Draw canvas var canvas = document.createElement(&apos;canvas&apos;); canvas.style.width = RemoteCanvas.CANVAS_WIDTH + &apos;px&apos;; canvas.style.height = RemoteCanvas.CANVAS_HEIGHT + &apos;px&apos;; canvas.width = RemoteCanvas.CANVAS_WIDTH; canvas.height = RemoteCanvas.CANVAS_HEIGHT; var windowWidth = window.innerWidth - 25; var windowHeight = window.innerHeight; var ctx = canvas.getContext(&apos;2d&apos;); ctx.clearRect(0, 0, RemoteCanvas.CANVAS_WIDTH, RemoteCanvas.CANVAS_HEIGHT); ctx.save(); ctx.scale(RemoteCanvas.CANVAS_WIDTH / windowWidth, RemoteCanvas.CANVAS_HEIGHT / windowHeight); ctx.drawWindow(remoteWindow, 0, 0, windowWidth, windowHeight, &apos;rgb(255, 255, 255)&apos;); ctx.restore();&#125;; 用法：12var remoteCanvas = new RemoteCanvas();remoteCanvas.load(); 将图像文件转换为base64字符串下面的代码获取远程图像，并转换其内容Data URI scheme。12345678910111213141516var canvas = document.createElement(&apos;canvas&apos;);var ctxt = canvas.getContext(&apos;2d&apos;);function loadImageFile(url, callback) &#123; var image = new Image(); image.src = url; return new Promise((accept, reject) =&gt; &#123; image.onload = accept; image.onerror = reject; &#125;).then(accept =&gt; &#123; canvas.width = this.width; canvas.height = this.height; ctxt.clearRect(0, 0, this.width, this.height); ctxt.drawImage(this, 0, 0); accept(canvas.toDataURL()); &#125;);&#125; 用法：1loadImageFile(&apos;myimage.jpg&apos;).then(string64 =&gt; &#123; alert(string64); &#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端知识点3]]></title>
      <url>%2F2017%2F06%2F07%2F%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B93%2F</url>
      <content type="text"><![CDATA[一、HTML和CSS1、你做的页面在哪些流览器测试过？这些浏览器的内核分别是什么?IE: trident内核Firefox：gecko内核Safari:webkit内核Opera:以前是presto内核，Opera现已改用Google Chrome的Blink内核Chrome:Blink(基于webkit，Google与Opera Software共同开发)2、每个HTML文件里开头都有个很重要的东西，Doctype，知道这是干什么的吗？&lt;!DOCTYPE&gt; 声明位于文档中的最前面的位置，处于 标签之前。此标签可告知浏览器文档使用哪种 HTML 或 XHTML 规范。（重点：告诉浏览器按照何种规范解析页面）3、Quirks模式是什么？它和Standards模式有什么区别从IE6开始，引入了Standards模式，标准模式中，浏览器尝试给符合标准的文档在规范上的正确处理达到在指定浏览器中的程度。在IE6之前CSS还不够成熟，所以IE5等之前的浏览器对CSS的支持很差， IE6将对CSS提供更好的支持，然而这时的问题就来了，因为有很多页面是基于旧的布局方式写的，而如果IE6 支持CSS则将令这些页面显示不正常，如何在即保证不破坏现有页面，又提供新的渲染机制呢？在写程序时我们也会经常遇到这样的问题，如何保证原来的接口不变，又提供更强大的功能，尤其是新功能不兼容旧功能时。遇到这种问题时的一个常见做法是增加参数和分支，即当某个参数为真时，我们就使用新功能，而如果这个参数 不为真时，就使用旧功能，这样就能不破坏原有的程序，又提供新功能。IE6也是类似这样做的，它将DTD当成了这个“参数”，因为以前的页面大家都不会去写DTD，所以IE6就假定 如果写了DTD，就意味着这个页面将采用对CSS支持更好的布局，而如果没有，则采用兼容之前的布局方式。这就是Quirks模式（怪癖模式，诡异模式，怪异模式）。区别：总体会有布局、样式解析和脚本执行三个方面的区别。盒模型：在W3C标准中，如果设置一个元素的宽度和高度，指的是元素内容的宽度和高度，而在Quirks 模式下，IE的宽度和高度还包含了padding和border。设置行内元素的高宽：在Standards模式下，给等行内元素设置wdith和height都不会生效，而在quirks模式下，则会生效。设置百分比的高度：在standards模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置百分比的高度，子元素设置一个百分比的高度是无效的用margin:0 auto设置水平居中：使用margin:0 auto在standards模式下可以使元素水平居中，但在quirks模式下却会失效。（还有很多，答出什么不重要，关键是看他答出的这些是不是自己经验遇到的，还是说都是看文章看的，甚至完全不知道。）4、div+css的布局较table布局有什么优点？改版的时候更方便 只要改css文件。页面加载速度更快、结构化清晰、页面显示简洁。表现与结构相分离。易于优化（seo）搜索引擎更友好，排名更容易靠前。5、 img的alt与title有何异同？ strong与em的异同？a:alt(alt text):为不能显示图像、窗体或applets的用户代理（UA），alt属性用来指定替换文字。替换文字的语言由lang属性指定。(在IE浏览器下会在没有title时把alt当成 tool tip显示)title(tool tip):该属性为设置该属性的元素提供建议性的信息。strong:粗体强调标签，强调，表示内容的重要性em:斜体强调标签，更强烈强调，表示内容的强调点6、你能描述一下渐进增强和优雅降级之间的不同吗?渐进增强 progressive enhancement：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。优雅降级 graceful degradation：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。“优雅降级”观点“优雅降级”观点认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器（如 IE、Mozilla 等）的前一个版本。在这种设计范例下，旧版的浏览器被认为仅能提供“简陋却无妨 (poor, but passable)” 的浏览体验。你可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注的焦点，因此除了修复较大的错误之外，其它的差异将被直接忽略。“渐进增强”观点“渐进增强”观点则认为应关注于内容本身。内容是我们建立网站的诱因。有的网站展示它，有的则收集它，有的寻求，有的操作，还有的网站甚至会包含以上的种种，但相同点是它们全都涉及到内容。这使得“渐进增强”成为一种更为合理的设计范例。这也是它立即被 Yahoo! 所采纳并用以构建其“分级式浏览器支持 (Graded Browser Support)”策略的原因所在。那么问题来了。现在产品经理看到IE6,7,8网页效果相对高版本现代浏览器少了很多圆角，阴影（CSS3），要求兼容（使用图片背景，放弃CSS3），你会如何说服他？7、为什么利用多个域名来存储网站资源会更有效？CDN缓存更方便突破浏览器并发限制节约cookie带宽节约主域名的连接数，优化页面响应速度防止不必要的安全问题8、请谈一下你对网页标准和标准制定机构重要性的理解。网页标准和标准制定机构都是为了能让web发展的更‘健康’，开发者遵循统一的标准，降低开发难度，开发成本，SEO也会更好做，也不会因为滥用代码导致各种BUG、安全问题，最终提高网站易用性。9、请描述一下cookies，sessionStorage和localStorage的区别？sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。web storage和cookie的区别Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。但是Cookie也是不可以或缺的：Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生。10、简述一下src与href的区别。src用于替换当前元素，href用于在当前文档和引用资源之间确立联系。src是source的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求src资源时会将其指向的资源下载并应用到文档内，例如js脚本，img图片和frame等元素。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部。href是Hypertext Reference的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，如果我们在文档中添加那么浏览器会识别该文档为css文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用link方式来加载css，而不是使用@import方式。11、知道的网页制作会用到的图片格式有哪些？png-8，png-24，jpeg，gif，svg。但是上面的那些都不是面试官想要的最后答案。面试官希望听到是Webp。（是否有关注新技术，新鲜事物）科普一下Webp：WebP格式，谷歌（google）开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有JPEG的2/3，并能节省大量的服务器带宽资源和数据空间。Facebook Ebay等知名网站已经开始测试并使用WebP格式。在质量相同的情况下，WebP格式图像的体积要比JPEG格式图像小40%12、知道什么是微格式吗？谈谈理解。在前端构建中应该考虑微格式吗？微格式（Microformats）是一种让机器可读的语义化XHTML词汇的集合，是结构化数据的开放标准。是为特殊应用而制定的特殊格式。优点：将智能数据添加到网页上，让网站内容在搜索引擎结果界面可以显示额外的提示。（应用范例：豆瓣，有兴趣自行google）13、在css/js代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次js请求一般情况下有哪些地方会有缓存处理？答案：dns缓存，cdn缓存，浏览器缓存，服务器缓存。14、一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。图片懒加载，在页面上的未可视区域可以添加一个滚动条事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。如果图片为css图片，可以使用CSSsprite，SVGsprite，Iconfont、Base64等技术。如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。如果图片展示区域小于图片的真实大小，则因在服务器端根据业务需要先行进行图片压缩，图片压缩后大小与展示一致。15、你如何理解HTML结构的语义化？ 去掉或样式丢失的时候能让页面呈现清晰的结构：html本身是没有表现的，我们看到例如&lt;h1&gt;是粗体，字体大小2em，加粗；&lt;strong&gt;是加粗的，不要认为这是html的表现，这些其实html默认的css样式在起作用，所以去掉或样式丢失的时候能让页面呈现清晰的结构不是语义化的HTML结构的优点，但是浏览器都有有默认样式，默认样式的目的也是为了更好的表达html的语义，可以说浏览器的默认样式和语义化的HTML结构是不可分割的。屏幕阅读器（如果访客有视障）会完全根据你的标记来“读”你的网页.例如,如果你使用的含语义的标记,屏幕阅读器就会“逐个拼出”你的单词,而不是试着去对它完整发音.PDA、手机等设备可能无法像普通电脑的浏览器一样来渲染网页（通常是因为这些设备对CSS的支持较弱）使用语义标记可以确保这些设备以一种有意义的方式来渲染网页.理想情况下,观看设备的任务是符合设备本身的条件来渲染网页.语义标记为设备提供了所需的相关信息,就省去了你自己去考虑所有可能的显示情况（包括现有的或者将来新的设备）.例如,一部手机可以选择使一段标记了标题的文字以粗体显示.而掌上电脑可能会以比较大的字体来显示.无论哪种方式一旦你对文本标记为标题,您就可以确信读取设备将根据其自身的条件来合适地显示页面.搜索引擎的爬虫也依赖于标记来确定上下文和各个关键字的权重过去你可能还没有考虑搜索引擎的爬虫也是网站的“访客”,但现在它们他们实际上是极其宝贵的用户.没有他们的话,搜索引擎将无法索引你的网站,然后一般用户将很难过来访问.你的页面是否对爬虫容易理解非常重要,因为爬虫很大程度上会忽略用于表现的标记,而只注重语义标记.因此,如果页面文件的标题被标记,而不是,那么这个页面在搜索结果的位置可能会比较靠后.除了提升易用性外,语义标记有利于正确使用CSS和JavaScript,因为其本身提供了许多“钩钩”来应用页面的样式与行为.SEO主要还是靠你网站的内容和外部链接的。便于团队开发和维护W3C给我们定了一个很好的标准，在团队中大家都遵循这个标准，可以减少很多差异化的东西，方便开发和维护，提高开发效率，甚至实现模块化开发。16、谈谈以前端角度出发做好SEO需要考虑什么？了解搜索引擎如何抓取网页和如何索引网页你需要知道一些搜索引擎的基本工作原理，各个搜索引擎之间的区别，搜索机器人（SE robot 或叫 web crawler）如何进行工作，搜索引擎如何对搜索结果进行排序等等。Meta标签优化主要包括主题（Title)，网站描述(Description)，和关键词（Keywords）。还有一些其它的隐藏文字比如Author（作者），Category（目录），Language（编码语种）等。如何选取关键词并在网页中放置关键词搜索就得用关键词。关键词分析和选择是SEO最重要的工作之一。首先要给网站确定主关键词（一般在5个上下），然后针对这些关键词进行优化，包括关键词密度（Density），相关度（Relavancy），突出性（Prominency）等等。了解主要的搜索引擎虽然搜索引擎有很多，但是对网站流量起决定作用的就那么几个。比如英文的主要有Google，Yahoo，Bing等；中文的有百度，搜狗，有道等。不同的搜索引擎对页面的抓取和索引、排序的规则都不一样。还要了解各搜索门户和搜索引擎之间的关系，比如AOL网页搜索用的是Google的搜索技术，MSN用的是Bing的技术。主要的互联网目录Open Directory自身不是搜索引擎，而是一个大型的网站目录，他和搜索引擎的主要区别是网站内容的收集方式不同。目录是人工编辑的，主要收录网站主页；搜索引擎是自动收集的，除了主页外还抓取大量的内容页面。按点击付费的搜索引擎搜索引擎也需要生存，随着互联网商务的越来越成熟，收费的搜索引擎也开始大行其道。最典型的有Overture和百度，当然也包括Google的广告项目Google Adwords。越来越多的人通过搜索引擎的点击广告来定位商业网站，这里面也大有优化和排名的学问，你得学会用最少的广告投入获得最多的点击。搜索引擎登录网站做完了以后，别躺在那里等着客人从天而降。要让别人找到你，最简单的办法就是将网站提交（submit）到搜索引擎。如果你的是商业网站，主要的搜索引擎和目录都会要求你付费来获得收录（比如Yahoo要299美元），但是好消息是（至少到目前为止）最大的搜索引擎Google目前还是免费，而且它主宰着60％以上的搜索市场。链接交换和链接广泛度（Link Popularity）网页内容都是以超文本（Hypertext）的方式来互相链接的，网站之间也是如此。除了搜索引擎以外，人们也每天通过不同网站之间的链接来Surfing（“冲浪”）。其它网站到你的网站的链接越多，你也就会获得更多的访问量。更重要的是，你的网站的外部链接数越多，会被搜索引擎认为它的重要性越大，从而给你更高的排名。合理的标签使用17、有哪项方式可以对一个DOM设置它的CSS样式？ 外部样式表，引入一个外部css文件内部样式表，将css代码放在 标签内部内联样式，将css样式直接定义在 HTML 元素内部18、CSS都有哪些选择器？派生选择器（用HTML标签申明）id选择器（用DOM的ID申明）类选择器（用一个样式类名申明）属性选择器（用DOM的属性申明，属于CSS2，IE6不支持，不常用，不知道就算了）除了前3种基本选择器，还有一些扩展选择器，包括后代选择器（利用空格间隔，比如div .a{ }）群组选择器（利用逗号间隔，比如p,div,#a{ }）那么问题来了，CSS选择器的优先级是怎么样定义的？基本原则：一般而言，选择器越特殊，它的优先级越高。也就是选择器指向的越准确，它的优先级就越高。复杂的计算方法：用1表示派生选择器的优先级用10表示类选择器的优先级用100标示ID选择器的优先级div.test1 .span var 优先级 1+10 +10 +1span#xxx .songs li 优先级1+100 + 10 + 1#xxx li 优先级 100 +1那么问题来了，看下列代码，标签内的文字是什么颜色的？.classA{ color:blue;}.classB{ color:red;} 123 答案：red。与样式定义在文件中的先后顺序有关，即是后面的覆盖前面的，与在中的先后关系无关。19、CSS中可以通过哪些属性定义，使得一个DOM元素不显示在浏览器可视范围内？最基本的：设置display属性为none，或者设置visibility属性为hidden技巧性：设置宽高为0，设置透明度为0，设置z-index位置在-100020、超链接访问过后hover样式就不出现的问题是什么？如何解决？答案：被点击访问过的超链接样式不在具有hover和active了,解决方法是改变CSS属性的排列顺序: L-V-H-A（link,visited,hover,active）21、什么是Css Hack？ie6,7,8的hack分别是什么？答案：针对不同的浏览器写不同的CSS code的过程，就是CSS hack。12345678910111213141516171819202122#test &#123; width:300px; height:300px; background-color:blue; /*firefox*/ background-color:red\9; /*all ie*/ background-color:yellow; /*ie8*/ +background-color:pink; /*ie7*/ _background-color:orange; /*ie6*/ &#125; :root #test &#123; background-color:purple\9; &#125; /*ie9*/ @media all and (min-width:0px)&#123; #test &#123;background-color:black;&#125; &#125; /*opera*/ @media screen and (-webkit-min-device-pixel-ratio:0)&#123; #test &#123;background-color:gray;&#125; &#125; /*chrome and safari*/22、请用Css写一个简单的幻灯片效果页面答案：知道是要用css3。使用animation动画实现一个简单的幻灯片效果。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061div.ani/**css**/.ani&#123; width:480px; height:320px; margin:50px auto; overflow: hidden; box-shadow:0 0 5px rgba(0,0,0,1); background-size: cover; background-position: center; -webkit-animation-name: &quot;loops&quot;; -webkit-animation-duration: 20s; -webkit-animation-iteration-count: infinite;&#125;@-webkit-keyframes &quot;loops&quot; &#123; 0% &#123; background:url(http://d.h、d3.jpg) no-repeat; &#125; 25% &#123; background:url(http://b.hiphotos.baidu.com/image/w%3D400/sig、f76094b364d72bceba1cc7cd98c109dd0.jpg) no-repeat; &#125; 50% &#123; background:url(http://b.hiphotos.baidu.com/image/w%3D400/sign=937dace2552c11dfded1be、58e7、bb5b912.jpg) no-repeat; &#125; 75% &#123; background:url(http://g.hiphotos.baidu.com/image/w%3D400/sign=7d37500b8544095d61f0972cdda3cc7cd99e4b.jpg) no-repeat; &#125; 100% &#123; background:url(http://c.hiphotos.baidu.com/image/2b21192138ad1.jpg) no-repeat; &#125;&#125;24、行内元素和块级元素的具体区别是什么？行内元素的padding和margin可设置吗？块级元素(block)特性：总是独占一行，表现为另起一行开始，而且其后的元素也必须另起一行显示;宽度(width)、高度(height)、内边距(padding)和外边距(margin)都可控制;内联元素(inline)特性：和相邻的内联元素在同一行;宽度(width)、高度(height)、内边距的top/bottom(padding-top/padding-bottom)和外边距的top/bottom(margin-top/margin-bottom)都不可改变（也就是padding和margin的left和right是可以设置的），就是里面文字或图片的大小。那么问题来了，浏览器还有默认的天生inline-block元素（拥有内在尺寸，可设置高宽，但不会自动换行），有哪些？答案：&lt;input&gt; 、&lt;img&gt; 、&lt;button&gt; 、&lt;texterea&gt; 、&lt;label&gt;。25、什么是外边距重叠？重叠的结果是什么？外边距重叠就是margin-collapse。在CSS当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。折叠结果遵循下列计算规则：两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。两个外边距一正一负时，折叠结果是两者的相加的和。26、rgba()和opacity的透明效果有什么不同？rgba()和opacity都能实现透明效果，但最大的不同是opacity作用于元素，以及元素内的所有内容的透明度，而rgba()只作用于元素的颜色或其背景色。（设置rgba透明的元素的子元素不会继承透明效果！）27、css中可以让文字在垂直和水平方向上重叠的两个属性是什么？垂直方向：line-height水平方向：letter-spacing那么问题来了，关于letter-spacing的妙用知道有哪些么？答案:可以用于消除inline-block元素间的换行符空格间隙问题。28、如何垂直居中一个浮动元素？123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 方法一：已知元素的高宽#div1&#123; background-color:#6699FF; width:200px; height:200px; position: absolute; //父元素需要相对定位 top: 50%; left: 50%; margin-top:-100px ; //二分之一的height，width margin-left: -100px; &#125;//方法二:未知元素的高宽 #div1&#123; width: 200px; height: 200px; background-color: #6699FF; margin:auto; position: absolute; //父元素需要相对定位 left: 0; top: 0; right: 0; bottom: 0; &#125;那么问题来了，如何垂直居中一个?（用更简便的方法。）123456789101112#Container //&lt;img&gt;的容器设置如下&#123; display:table-cell; text-align:center; vertical-align:middle;&#125;29、px和em的区别。px和em都是长度单位，区别是，px的值是固定的，指定是多少就是多少，计算比较容易。em得值不是固定的，并且em会继承父级元素的字体大小。浏览器的默认字体高都是16px。所以未经调整的浏览器都符合: 1em=16px。那么12px=0.75em, 10px=0.625em。30、描述一个”reset”的CSS文件并如何使用它。知道normalize.css吗？你了解他们的不同之处？重置样式非常多，凡是一个前端开发人员肯定有一个常用的重置CSS文件并知道如何使用它们。他们是盲目的在做还是知道为什么这么做呢？原因是不同的浏览器对一些元素有不同的默认样式，如果你不处理，在不同的浏览器下会存在必要的风险，或者更有戏剧性的性发生。你可能会用Normalize来代替你的重置样式文件。它没有重置所有的样式风格，但仅提供了一套合理的默认样式值。既能让众多浏览器达到一致和合理，但又不扰乱其他的东西（如粗体的标题）。在这一方面，无法做每一个复位重置。它也确实有些超过一个重置，它处理了你永远都不用考虑的怪癖，像HTML的audio元素不一致或line-height不一致。31、Sass、LESS是什么？大家为什么要使用他们？他们是CSS预处理器。他是CSS上的一种抽象层。他们是一种特殊的语法/语言编译成CSS。例如Less是一种动态样式语言. 将CSS赋予了动态语言的特性，如变量，继承，运算， 函数. LESS 既可以在客户端上运行 (支持IE 6+, Webkit, Firefox)，也可一在服务端运行 (借助 Node.js)。为什么要使用它们？结构清晰，便于扩展。可以方便地屏蔽浏览器私有语法差异。这个不用多说，封装对浏览器语法差异的重复处理，减少无意义的机械劳动。可以轻松实现多重继承。完全兼容 CSS 代码，可以方便地应用到老项目中。LESS 只是在 CSS 语法上做了扩展，所以老的 CSS 代码也可以与 LESS 代码一同编译。32、display:none与visibility:hidden的区别是什么？display : 隐藏对应的元素但不挤占该元素原来的空间。visibility: 隐藏对应的元素并且挤占该元素原来的空间。即是，使用CSS display:none属性后，HTML元素（对象）的宽度、高度等各种属性值都将“丢失”;而使用visibility:hidden属性后，HTML元素（对象）仅仅是在视觉上看不见（完全透明），而它所占据的空间位置仍然存在。34、CSS中link和@import的区别是：Link属于html标签，而@import是CSS中提供的在页面加载的时候，link会同时被加载，而@import引用的CSS会在页面加载完成后才会加载引用的CSS@import只有在ie5以上才可以被识别，而link是html标签，不存在浏览器兼容性问题Link引入样式的权重大于@import的引用（@import是将引用的样式导入到当前的页面中）35、简介盒子模型：CSS的盒子模型有两种：IE盒子模型、标准的W3C盒子模型模型盒模型：内容、内边距、外边距（一般不计入盒子实际宽度）、边框36、为什么要初始化样式？由于浏览器兼容的问题，不同的浏览器对标签的默认样式值不同，若不初始化会造成不同浏览器之间的显示差异但是初始化CSS会对搜索引擎优化造成小影响37、BFC是什么?BFC（块级格式化上下文），一个创建了新的BFC的盒子是独立布局的，盒子内元素的布局不会影响盒子外面的元素。在同一个BFC中的两个相邻的盒子在垂直方向发生margin重叠的问题BFC是指浏览器中创建了一个独立的渲染区域，该区域内所有元素的布局不会影响到区域外元素的布局，这个渲染区域只对块级元素起作用38、html语义化是什么？当页面样式加载失败的时候能够让页面呈现出清晰的结构有利于seo优化，利于被搜索引擎收录（更便于搜索引擎的爬虫程序来识别）便于项目的开发及维护，使html代码更具有可读性，便于其他设备解析。39、Doctype的作用？严格模式与混杂模式的区别？&lt;!DOCTYPE&gt;用于告知浏览器该以何种模式来渲染文档严格模式下：页面排版及JS解析是以该浏览器支持的最高标准来执行混杂模式：不严格按照标准执行，主要用来兼容旧的浏览器，向后兼容40、IE的双边距BUG：块级元素float后设置横向margin，ie6显示的margin比设置的较大。解决：加入_display：inline41、HTML与XHTML——二者有什么区别？1. 所有的标记都必须要有一个相应的结束标记2. 所有标签的元素和属性的名字都必须使用小写3. 所有的 XML 标记都必须合理嵌套4. 所有的属性必须用引号 “” 括起来5. 把所有 &lt; 和 &amp; 特殊符号用编码表示6. 给所有属性赋一个值7. 不要在注释内容中使用 “–”8. 图片必须有说明文字42、html常见兼容性问题？1.双边距BUG float引起的 使用display2.3像素问题 使用float引起的 使用dislpay:inline -3px3.超链接hover 点击后失效 使用正确的书写顺序 link visited hover active4.Ie z-index问题 给父级添加position:relative5.Png 透明 使用js代码 改6.Min-height 最小高度 ！Important 解决’7.select 在ie6下遮盖 使用iframe嵌套8.为什么没有办法定义1px左右的宽度容器（IE6默认的行高造成的，使用over:hidden,zoom:0.08 line-height:1px）9.IE5-8不支持opacity，解决办法：123456789.opacity &#123; opacity: 0.4 filter: alpha(opacity=60); /* for IE5-7 */ -ms-filter: &quot;progid:DXImageTransform.Microsoft.Alpha(Opacity=60)&quot;; /* for IE 8*/&#125;10. IE6不支持PNG透明背景，解决办法: IE6下使用gif图片43、对WEB标准以及W3C的理解与认识答：标签闭合、标签小写、不乱嵌套、提高搜索机器人搜索几率、使用外 链css和js脚本、结构行为表现的分离、文件下载与页面速度更快、内容能被更多的用户所访问、内容能被更广泛的设备所访问、更少的代码和组件，容易维 护、改版方便，不需要变动页面内容、提供打印版本而不需要复制内容、提高网站易用性。44、行内元素有哪些?块级元素有哪些?CSS的盒模型?答：块级元素：div p h1 h2 h3 h4 form ul行内元素: a b br i span input selectCss盒模型:内容，border ,margin，padding45、前端页面有哪三层构成，分别是什么?作用是什么?答：结构层 Html 表示层 CSS 行为层 js。46、Doctype作用? 严格模式与混杂模式-如何触发这两种模式，区分它们有何意义? （1）、&lt;!DOCTYPE&gt; 声明位于文档中的最前面，处于 标签之前。告知浏览器的解析器，用什么文档类型 规范来解析这个文档。 （2）、严格模式的排版和 JS 运作模式是 以该浏览器支持的最高标准运行。 （3）、在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。 （4）、DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。47、行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？（1）CSS规范规定，每个元素都有display属性，确定该元素的类型，每个元素都有默认的display值，比如div默认display属性值为“block”，成为“块级”元素；span默认display属性值为“inline”，是“行内”元素。（2）行内元素有：a b span img input select strong（强调的语气） 块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p（3）知名的空元素：&lt;br&gt;&lt;hr&gt;&lt;img&gt;&lt;input&gt;&lt;link&gt;&lt;meta&gt;鲜为人知的是： &lt;area&gt;&lt;base&gt;&lt;col&gt;&lt;command&gt; &lt;embed&gt;&lt;keygen&gt;&lt;param&gt;&lt;source&gt;&lt;track&gt;&lt;wbr&gt;48、CSS的盒子模型？（1）两种， IE 盒子模型、标准 W3C 盒子模型；IE 的content部分包含了 border 和 pading;（2）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border).49、CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？ 1.id选择器（ # myid） 2.类选择器（.myclassname） 3.标签选择器（div, h1, p） 4.相邻选择器（h1 + p） 5.子选择器（ul &lt; li） 6.后代选择器（li a） 7.通配符选择器（ ） 8.属性选择器（a[rel = “external”]） 9.伪类选择器（a: hover, li: nth - child） 可继承： font-size font-family color, UL LI DL DD DT; 不可继承 ：border padding margin width height ; 优先级就近原则，样式定义最近者为准; 载入样式以最后载入的定位为准;优先级为: !important &gt; id &gt; class &gt; tag important 比 内联优先级高CSS3新增伪类举例： p:first-of-type 选择属于其父元素的首个 元素的每个 元素。 p:last-of-type 选择属于其父元素的最后 元素的每个 元素。 p:only-of-type 选择属于其父元素唯一的 元素的每个 元素。 p:only-child 选择属于其父元素的唯一子元素的每个 元素。 p:nth-child(2) 选择属于其父元素的第二个子元素的每个 元素。 :enabled、:disabled 控制表单控件的禁用状态。 :checked，单选框或复选框被选中。50、如何居中div,如何居中一个浮动元素?给div设置一个宽度，然后添加margin:0 auto属性1234567div&#123; width:200px; margin:0 auto; &#125;居中一个浮动元素 确定容器的宽高 宽500 高 300 的层 设置层的外边距123456789101112131415 .div &#123; Width:500px ; height:300px;//高度可以不设 Margin: -150px 0 0 -250px; position:relative;相对定位 background-color:pink;//方便看效果 left:50%; top:50%;&#125;51、浏览器的内核分别是什么?经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？ IE浏览器的内核Trident、 Mozilla的Gecko、google的WebKit、Opera内核Presto； png24为的图片在iE6浏览器上出现背景，解决方案是做成PNG8. 浏览器默认的margin和padding不同。解决方案是加一个全局的{margin:0;padding:0;}来统一。 IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。 浮动ie产生的双倍距离 #box{ float:left; width:10px; margin:0 0 0 100px;} 这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 —— _display:inline;将其转化为行内属性。(_这个符号只有ie6会识别) 渐进识别的方式，从总体中逐渐排除局部。 首先，巧妙的使用“\9”这一标记，将IE游览器从所有情况中分离出来。 接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。 css1234567891011.bb&#123; background-color:#f1ee18;/*所有识别*/.background-color:#00deff\9; /*IE6、7、8识别*/+background-color:#a200ff;/*IE6、7识别*/_background-color:#1e0bd1;/*IE6识别*/&#125; IE下,可以使用获取常规属性的方法来获取自定义属性, 也可以使用getAttribute()获取自定义属性; Firefox下,只能使用getAttribute()获取自定义属性. 解决方法:统一通过getAttribute()获取自定义属性. IE下,even对象有x,y属性,但是没有pageX,pageY属性; Firefox下,event对象有pageX,pageY属性,但是没有x,y属性. （条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。 Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示, 可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决. 超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序: L-V-H-A : a:link {} a:visited {} a:hover {} a:active {}52、列出display的值，说明他们的作用。position的值， relative和absolute定位原点是？ 1. block 象块类型元素一样显示。 none 缺省值。向行内元素类型一样显示。 inline-block 象行内元素一样显示，但其内容象块类型元素一样显示。 list-item 象块类型元素一样显示，并添加样式列表标记。 2. position的值 absolute 生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。 fixed （老IE不支持） 生成绝对定位的元素，相对于浏览器窗口进行定位。 relative 生成相对定位的元素，相对于其正常位置进行定位。 static 默认值。没有定位，元素出现在正常的流中 （忽略 top, bottom, left, right z-index 声明）。 inherit 规定从父元素继承 position 属性的值。53、absolute的containing block计算方式跟正常流有什么不同？54、position跟display、margin collapse、overflow、float这些特性相互叠加后会怎么样？55、对WEB标准以及W3C的理解与认识标签闭合、标签小写、不乱嵌套、提高搜索机器人搜索几率、使用外 链css和js脚本、结构行为表现的分离、文件下载与页面速度更快、内容能被更多的用户所访问、内容能被更广泛的设备所访问、更少的代码和组件，容易维 护、改版方便，不需要变动页面内容、提供打印版本而不需要复制内容、提高网站易用性；56、css的基本语句构成是?选择器{属性1:值1;属性2:值2;……}57、浏览器标准模式和怪异模式之间的区别是什么?盒子模型 渲染模式的不同使用 window.top.document.compatMode 可显示为什么模式58、CSS中可以通过哪些属性定义，使得一个DOM元素不显示在浏览器可视范围内？ 最基本的： 设置display属性为none，或者设置visibility属性为hidden 技巧性： 设置宽高为0，设置透明度为0，设置z-index位置在-100059、超链接访问过后hover样式就不出现的问题是什么？如何解决？ 答案：被点击访问过的超链接样式不在具有hover和active了,解决方法是改变CSS属性的排列顺序: L-V-H-A（link,visited,hover,active）60、什么是Css Hack？ie6,7,8的hack分别是什么？ 答案：针对不同的浏览器写不同的CSS code的过程，就是CSS hack。 示例如下：1234567891011121314151617181920212223#test &#123; width:300px; height:300px; background-color:blue; /firefox*/ background-color:red\9; /all ie*/ background-color:yellow\0; /ie8*/ +background-color:pink; /ie7*/ _background-color:orange; /ie6/ &#125; :root #test &#123; background-color:purple\9; &#125; /ie9*/ @media all and (min-width:0px)&#123; #test &#123;background-color:black\0;&#125; &#125; /opera/ @media screen and (-webkit-min-device-pixel-ratio:0)&#123; #test &#123;background-color:gray;&#125; &#125; /chrome and safari*/62、请用Css写一个简单的幻灯片效果页面 答案：知道是要用css3。使用animation动画实现一个简单的幻灯片效果。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/**HTML**/ div.ani /**css**/ .ani&#123; width:480px; height:320px; margin:50px auto; overflow: hidden; box-shadow:0 0 5px rgba(0,0,0,1); background-size: cover; background-position: center; -webkit-animation-name: &quot;loops&quot;; -webkit-animation-duration: 20s; -webkit-animation-iteration-count: infinite; &#125; @-webkit-keyframes &quot;loops&quot; &#123; 0% &#123; background:url(http://d.hiphotos.baidu.com/image/w%3D400/sign=c01e6adca964034f0fcdc3069fc27980/e824b899a9014c08e5e38ca4087b02087af4f4d3.jpg) no-repeat; &#125; 25% &#123; background:url(http://b.hiphotos.baidu.com/image/w%3D400/sign=edee1572e9f81a4c2632edc9e72b6029/30adcbef76094b364d72bceba1cc7cd98c109dd0.jpg) no-repeat; &#125; 50% &#123; background:url(http://b.hiphotos.baidu.com/image/w%3D400/sign=937dace2552c11dfded1be2353266255/d8f9d72a6059252d258e7605369b033b5bb5b912.jpg) no-repeat; &#125; 75% &#123; background:url(http://g.hiphotos.baidu.com/image/w%3D400/sign=7d37500b8544ebf86d71653fe9f9d736/0df431adcbef76095d61f0972cdda3cc7cd99e4b.jpg) no-repeat; &#125; 100% &#123; background:url(http://c.hiphotos.baidu.com/image/w%3D400/sign=cfb239ceb0fb43161a1f7b7a10a54642/3b87e950352ac65ce2e73f76f9f2b21192138ad1.jpg) no-repeat; &#125; &#125;63、行内元素和块级元素的具体区别是什么？行内元素的padding和margin可设置吗？ 块级元素(block)特性：总是独占一行，表现为另起一行开始，而且其后的元素也必须另起一行显示;宽度(width)、高度(height)、内边距(padding)和外边距(margin)都可控制; 内联元素(inline)特性：和相邻的内联元素在同一行;宽度(width)、高度(height)、内边距的top/bottom(padding-top/padding-bottom)和外边距的top/bottom(margin-top/margin-bottom)都不可改变（也就是padding和margin的left和right是可以设置的），就是里面文字或图片的大小。 那么问题来了，浏览器还有默认的天生inline-block元素（拥有内在尺寸，可设置高宽，但不会自动换行），有哪些？ 答案：&lt;input&gt; 、&lt;img&gt; 、&lt;button&gt; 、&lt;textarea&gt; 、&lt;label&gt;64、什么是外边距重叠？重叠的结果是什么？ 答案： 外边距重叠就是margin-collapse。 在CSS当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。 折叠结果遵循下列计算规则：两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。两个外边距一正一负时，折叠结果是两者的相加的和。 65、rgba()和opacity的透明效果有什么不同？ rgba()和opacity都能实现透明效果，但最大的不同是opacity作用于元素，以及元素内的所有内容的透明度， 而rgba()只作用于元素的颜色或其背景色。（设置rgba透明的元素的子元素不会继承透明效果！）66、css中可以让文字在垂直和水平方向上重叠的两个属性是什么？ 垂直方向：line-height 水平方向：letter-spacing 那么问题来了，关于letter-spacing的妙用知道有哪些么？ 答案:可以用于消除inline-block元素间的换行符空格间隙问题。67、如何垂直居中一个浮动元素？// 方法一：已知元素的高宽12345678910111213141516171819202122232425262728293031323334353637383940414243#div1&#123; background-color:#6699FF; width:200px; height:200px; position: absolute; //父元素需要相对定位 top: 50%; left: 50%; margin-top:-100px ; //二分之一的height，width margin-left: -100px; &#125;//方法二:未知元素的高宽 #div1&#123; width: 200px; height: 200px; background-color: #6699FF; margin:auto; position: absolute; //父元素需要相对定位 left: 0; top: 0; right: 0; bottom: 0; &#125;那么问题来了，如何垂直居中一个?（用更简便的方法。）1234567891011#container //&lt;img&gt;的容器设置如下&#123; display:table-cell; text-align:center; vertical-align:middle;&#125;68、描述一个”reset”的CSS文件并如何使用它。知道normalize.css吗？你了解他们的不同之处？ 重置样式非常多，凡是一个前端开发人员肯定有一个常用的重置CSS文件并知道如何使用它们。他们是盲目的在做还是知道为什么这么做呢？原因是不同的浏览器对一些元素有不同的默认样式，如果你不处理，在不同的浏览器下会存在必要的风险，或者更有戏剧性的性发生。 你可能会用Normalize来代替你的重置样式文件。它没有重置所有的样式风格，但仅提供了一套合理的默认样式值。既能让众多浏览器达到一致和合理，但又不扰乱其他的东西（如粗体的标题）。 在这一方面，无法做每一个复位重置。它也确实有些超过一个重置，它处理了你永远都不用考虑的怪癖，像HTML的audio元素不一致或line-height不一致。69、说display属性有哪些？可以做什么？display:block行内元素转换为块级元素 display:inline块级元素转换为行内元素 display:inline-block转为内联元素70、哪些css属性可以继承？可继承： font-size font-family color, ul li dl dd dt; 不可继承 ：border padding margin width height ;71、css优先级算法如何计算？!important &gt; id &gt; class &gt; 标签 !important 比 内联优先级高 优先级就近原则，样式定义最近者为准; 以最后载入的样式为准;72、b标签和strong标签,i标签和em标签的区别？后者有语义，前者则无。73、有那些行内元素、有哪些块级元素、盒模型？1.内联元素(inline element)a – 锚点abbr – 缩写acronym – 首字b – 粗体(不推荐)big – 大字体br – 换行em – 强调font – 字体设定(不推荐)i – 斜体img – 图片input – 输入框label – 表格标签s – 中划线(不推荐)select – 项目选择small – 小字体文本span – 常用内联容器，定义文本内区块strike – 中划线strong – 粗体强调sub – 下标sup – 上标textarea – 多行文本输入框tt – 电传文本u – 下划线var – 定义变量2、块级元素address – 地址blockquote – 块引用center – 举中对齐块dir – 目录列表div – 常用块级容易，也是css layout的主要标签dl – 定义列表fieldset – form控制组form – 交互表单h1 – 大标题h2 – 副标题h3 – 3级标题h4 – 4级标题h5 – 5级标题h6 – 6级标题hr – 水平分隔线isindex – input promptmenu – 菜单列表noframes – frames可选内容，（对于不支持frame的浏览器显示此区块内容）noscript – ）可选脚本内容（对于不支持script的浏览器显示此内容）ol – 排序表单p – 段落pre – 格式化文本table – 表格ul – 非排序列表3.CSS盒子模型包含四个部分组成：内容、填充（padding）、边框（border）、外边界（margin）。74、有哪些选择符，优先级的计算公式是什么？行内样式和！important哪个优先级高？#ID &gt; .class &gt; 标签选择符 !important优先级高75.我想让行内元素跟上面的元素距离10px，加margin-top和padding-top可以吗？ margin-top,padding-top无效76.CSS的盒模型由什么组成？ 内容，border ,margin，padding77、.说说display属性有哪些？可以做什么？ display:block行内元素转换为块级元素 display:inline块级元素转换为行内元素 display:inline-block转为内联元素78、哪些css属性可以继承？ 可继承： font-size font-family color, ul li dl dd dt; 不可继承 ：border padding margin width height ;79、css优先级算法如何计算？ !important &gt; id &gt; class &gt; 标签 !important 比 内联优先级高 优先级就近原则，样式定义最近者为准; * 以最后载入的样式为准;80、text-align:center和line-height有什么区别？ text-align是水平对齐，line-height是行间。81、前端页面由哪三层构成，分别是什么？作用是什么？ 结构层 Html 表示层 CSS 行为层 js82、写一个表格以及对应的CSS,使表格奇数行为白色背景，偶数行为灰色，鼠标一上去为黄色背景。二、JS基础1、javascript的typeof返回哪些数据类型Object number function boolean underfind2、例举3种强制类型转换和2种隐式类型转换?强制（parseInt,parseFloat,number）隐式（== – ===）3、split() join() 的区别前者是切割成数组的形式，后者是将数组转换成字符串4、数组方法pop() push() unshift() shift()Push()尾部添加 pop()尾部删除Unshift()头部添加 shift()头部删除5、事件绑定和普通事件有什么区别事件绑定是指把事件注册到具体的元素之上，普通事件指的是可以用来注册的事件6、IE和DOM事件流的区别1.执行顺序不一样、2.参数不一样3.事件加不加on4.this指向问题7、IE和标准下有哪些兼容性的写法Var ev = ev || window.eventdocument.documentElement.clientWidth || document.body.clientWidthVar target = ev.srcElement||ev.target8、call和apply的区别Object.call(this,obj1,obj2,obj3)Object.apply(this,arguments)9、b继承a的方法10、JavaScript this指针、闭包、作用域11、事件委托是什么让利用事件冒泡的原理，让自己的所触发的事件，让他的父元素代替执行！12、闭包是什么，有什么特性，对页面有什么影响闭包就是能够读取其他函数内部变量的函数。13、如何阻止事件冒泡和默认事件canceBubble return false14、添加 删除 替换 插入到某个接点的方法obj.appendChidl()obj.innersetBeforeobj.replaceChildobj.removeChild15、javascript的本地对象，内置对象和宿主对象本地对象为array obj regexp等可以new实例化内置对象为gload Math 等不可以实例化的宿主为浏览器自带的document,window 等16、document load 和document ready的区别Document.onload 是在结构和样式加载完才执行jsDocument.ready原生种没有这个方法，jQuery中有 $().ready(function)17、”==”和“===”的不同前者会自动转换类型后者不会18、javascript的同源策略一段脚本只能读取来自于同一来源的窗口和文档的属性，这里的同一来源指的是主机名、议和端口号的组合19、编写一个数组去重的方法1234567891011function oSort(arr) &#123; var result =&#123;&#125;;var newArr=[];for(var i=0;i&lt;arr.length;i++)&#123;if(!result[arr]) &#123;newArr.push(arr)result[arr]=1&#125;&#125;return newArr&#125;&lt;/arr.length;i++)20、JavaScript是一门什么样的语言，它有哪些特点？没有标准答案。21、JavaScript的数据类型都有什么？基本数据类型：String,boolean,Number,Undefined, Null引用数据类型：Object(Array,Date,RegExp,Function)那么问题来了，如何判断某变量是否为数组数据类型？方法一.判断其是否具有“数组性质”，如slice()方法。可自己给该变量定义slice方法，故有时会失效方法二.obj instanceof Array 在某些IE版本中不正确方法三.方法一二皆有漏洞，在ECMA Script5中定义了新方法Array.isArray(), 保证其兼容性，最好的方法如下：123456789if(typeof Array.isArray===&quot;undefined&quot;)&#123; Array.isArray = function(arg)&#123; return Object.prototype.toString.call(arg)===&quot;[object Array]&quot; &#125;;&#125;22、已知ID的Input输入框，希望获取这个输入框的输入值，怎么做？(不使用第三方框架)document.getElementById(“ID”).value23、希望获取到页面中所有的checkbox怎么做？(不使用第三方框架)123456789101112131415var domList = document.getElementsByTagName(‘input’)var checkBoxList = [];var len = domList.length; //缓存到局部变量while (len--) &#123; //使用while的效率会比for循环更高 if (domList[len].type == ‘checkbox’) &#123; checkBoxList.push(domList[len]); &#125;&#125;24、设置一个已知ID的DIV的html内容为xxxx，字体颜色设置为黑色(不使用第三方框架)12345var dom = document.getElementById(“ID”);dom.innerHTML = “xxxx”dom.style.color = “#000”25、当一个DOM节点被点击时候，我们希望能够执行一个函数，应该怎么做？直接在DOM里绑定事件： 在JS里通过onclick绑定：xxx.onclick = test 通过事件添加进行绑定：addEventListener(xxx, ‘click’, test) 那么问题来了，Javascript的事件流模型都有什么？ “事件冒泡”：事件开始由最具体的元素接受，然后逐级向上传播 “事件捕捉”：事件由最不具体的节点先接收，然后逐级向下，一直到最具体的 “DOM事件流”：三个阶段：事件捕捉，目标阶段，事件冒泡 26、看下列代码输出为何？解释原因。 var a; alert(typeof a); // undefined alert(b); // 报错 解释：Undefined是一个只有一个值的数据类型，这个值就是“undefined”，在使用var声明变量但并未对其赋值进行初始化时，这个变量的值就是undefined。而b由于未声明将报错。注意未申明的变量和声明了未赋值的是不一样的。 27、看下列代码,输出什么？解释原因。 var a = null; alert(typeof a); //object 解释：null是一个只有一个值的数据类型，这个值就是null。表示一个空指针对象，所以用typeof检测会返回”object”。 28、看下列代码,输出什么？解释原因。 1234567891011121314151617var undefined;undefined == null; // true1 == true; // true2 == true; // false0 == false; // true0 == &apos;&apos;; // trueNaN == NaN; // false[] == false; // true[] == ![]; // true undefined与null相等，但不恒等（===）一个是number一个是string时，会尝试将string转换为number 尝试将boolean转换为number，0或1 尝试将Object转换成number或string，取决于另外一个对比量的类型 所以，对于0、空字符串的判断，建议使用 “===” 。“===”会先判断两边的值类型，类型不匹配时为false。 那么问题来了，看下面的代码，输出什么，foo的值为什么？12345var foo = &quot;11&quot;+2-&quot;1&quot;;console.log(foo);console.log(typeof foo); 执行完后foo的值为111，foo的类型为String。 29、看代码给答案。12345678910var a = new Object();a.value = 1;b = a;b.value = 2;alert(a.value); 答案：2（考察引用数据类型细节） 30、已知数组var stringArray = [“This”, “is”, “Baidu”, “Campus”]，Alert出”This is Baidu Campus”。答案：alert(stringArray.join(“”)) 已知有字符串foo=”get-element-by-id”,写一个function将其转化成驼峰表示法”getElementById”。123456789101112131415function combo(msg)&#123; var arr=msg.split(&quot;-&quot;); for(var i=1;i&lt;arr.length;i++)&#123; arr[i]=arr[i].charAt(0).toUpperCase()+arr[i].substr(1,arr[i].length-1); &#125; msg=arr.join(&quot;&quot;); return msg;&#125; (考察基础API) 31、var numberArray = [3,6,2,4,1,5]; （考察基础API）1) 实现对该数组的倒排，输出[5,1,4,2,6,3] 2) 实现对该数组的降序排列，输出[6,5,4,3,2,1] function combo(msg){ var arr=msg.split(&quot;-&quot;); for(var i=1;i&lt;arr.length;i++){ arr[i]=arr[i].charAt(0).toUpperCase()+arr[i].substr(1,arr[i].length-1); } msg=arr.join(&quot;&quot;); return msg; } 32、输出今天的日期，以YYYY-MM-DD的方式，比如今天是2014年9月26日，则输出2014-09-26 var d = new Date(); // 获取年，getFullYear()返回4位的数字 var year = d.getFullYear(); // 获取月，月份比较特殊，0是1月，11是12月 var month = d.getMonth() + 1; // 变成两位 month = month &lt; 10 ? ‘0’ + month : month; // 获取日 var day = d.getDate(); day = day &lt; 10 ? ‘0’ + day : day; alert(year + ‘-‘ + month + ‘-‘ + day); 33、将字符串”{$id}{$name}”中的{$id}替换成10，{$name}替换成Tony （使用正则表达式）答案：”{$id}{$id}_{$name}”.replace(/{\$id}/g, ’10′).replace(/{\$name}/g, ‘Tony’); 34、为了保证页面输出安全，我们经常需要对一些特殊的字符进行转义，请写一个函数escapeHtml，将&lt;, &gt;, &amp;, “进行转义 123456789101112131415161718192021222324252627function escapeHtml(str) &#123;return str.replace(/[&lt;&gt;”&amp;]/g, function(match) &#123; switch (match) &#123; case “&lt;”: return “&amp;lt;”; case “&gt;”: return “&amp;gt;”; case “&amp;”: return “&amp;amp;”; case “\””: return “&amp;quot;”; &#125; &#125;);&#125; 35、foo = foo||bar ，这行代码是什么意思？为什么要这样写？答案：if(!foo) foo = bar; //如果foo存在，值不变，否则把bar的值赋给foo。 短路表达式：作为”&amp;&amp;”和”||”操作符的操作数表达式，这些表达式在进行求值时，只要最终的结果已经可以确定是真或假，求值过程便告终止，这称之为短路求值。 36、看下列代码，将会输出什么?(变量声明提升) 1234567891011var foo = 1;function()&#123; console.log(foo); var foo = 2; console.log(foo);&#125; 答案：输出undefined 和 2。上面代码相当于： 12345678910111213var foo = 1;function()&#123; var foo; console.log(foo); //undefined foo = 2; console.log(foo); // 2; &#125; 函数声明与变量声明会被JavaScript引擎隐式地提升到当前作用域的顶部，但是只提升名称不会提升赋值部分。 37、用js实现随机选取10–100之间的10个数字，存入一个数组，并排序。123456789101112131415161718var iArray = [];funtion getRandom(istart, iend)&#123; var iChoice = iend - istart +1; return Math.floor(Math.random() * iChoice + istart;&#125;for(var i=0; i&lt;10; i++)&#123; iArray.push(getRandom(10,100));&#125;iArray.sort(); 38、把两个数组合并，并删除第二个元素。1234567var array1 = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];var bArray = [&apos;d&apos;,&apos;e&apos;,&apos;f&apos;];var cArray = array1.concat(bArray);cArray.splice(1,1); 39、怎样添加、移除、移动、复制、创建和查找节点（原生JS，实在基础，没细写每一步）1）创建新节点123456789101112131415createDocumentFragment() //创建一个DOM片段createElement() //创建一个具体的元素createTextNode() //创建一个文本节点2）添加、移除、替换、插入appendChild() //添加removeChild() //移除replaceChild() //替换insertBefore() //插入 3）查找12345getElementsByTagName() //通过标签名称getElementsByName() //通过元素的Name属性的值getElementById() //通过元素Id，唯一性 40、有这样一个URL：http://item.taobao.com/item.htm?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e，请写一段JS程序提取URL中的各个GET参数(参数名和参数个数不确定)，将其按key-value形式返回到一个json结构中，如{a:’1′, b:’2′, c:”, d:’xxx’, e:undefined}。答案：1234567891011121314151617function serilizeUrl(url) &#123; var result = &#123;&#125;; url = url.split(&quot;?&quot;)[1]; var map = url.split(&quot;&amp;&quot;); for(var i = 0, len = map.length; i &lt; len; i++) &#123; result&lt;script&gt;jQuery(function($) &#123;$(&quot;#google-maps-1&quot;).gMap(&#123;controls: false,scrollwheel: false,markers: [&#123;address: &quot;&quot;,icon: &#123;image: &quot;http://blog.jobbole.com/wp-content/themes/jobboleblogv3/_assets/img/_colors/red/pin.png&quot;,iconsize: [32, 32],iconanchor: [16,27],infowindowanchor: [16, 27]&#125;&#125;],address: &quot;&quot;,zoom: 15,icon: &#123;image: &quot;http://blog.jobbole.com/wp-content/themes/jobboleblogv3/_assets/img/_colors/red/pin.png&quot;,iconsize: [32, 32],iconanchor: [16,27],infowindowanchor: [16, 27]&#125;&#125;);&#125;);&lt;/script&gt;&lt;div id=&quot;google-maps-1&quot; class=&quot;google-maps&quot; style=&quot;width: 100%; height: 200px;&quot;&gt;&lt;/div&gt;.split(&quot;=&quot;)[0]] = map[i].split(&quot;=&quot;)[1]; &#125; return result;&#125; 41、正则表达式构造函数var reg=new RegExp(“xxx”)与正则表达字面量var reg=//有什么不同？匹配邮箱的正则表达式？答案：当使用RegExp()构造函数的时候，不仅需要转义引号（即\”表示”），并且还需要双反斜杠（即\表示一个\）。使用正则表达字面量的效率更高。 邮箱的正则匹配： var regMail = /^([a-zA-Z0-9-])+@([a-zA-Z0-9-])+((.[a-zA-Z0-9_-]{2,3}){1,2})$/; 24.看下面代码，给出输出结果。 1234567891011for(var i=1;i&lt;=3;i++)&#123; setTimeout(function()&#123; console.log(i); &#125;,0);&#125;;答案：4 4 4。 原因：Javascript事件处理器在线程空闲之前不会运行。追问，如何让上述代码输出1 2 3？123456789for(var i=1;i&lt;=3;i++)&#123; setTimeout((function(a)&#123; //改成立即执行函数 console.log(a); &#125;)(i),0);&#125;; 1 //输出 2 3 42、写一个function，清除字符串前后的空格。（兼容所有浏览器）使用自带接口trim()，考虑兼容性：123456789101112131415if (!String.prototype.trim) &#123; String.prototype.trim = function() &#123; return this.replace(/^\s+/, &quot;&quot;).replace(/\s+$/,&quot;&quot;); &#125;&#125; // test the functionvar str = &quot; \t\n test string &quot;.trim();alert(str == &quot;test string&quot;); // alerts &quot;true&quot; 43、Javascript中callee和caller的作用？caller是返回一个对函数的引用，该函数调用了当前函数； callee是返回正在被执行的function函数，也就是所指定的function对象的正文。 那么问题来了？如果一对兔子每月生一对兔子；一对新生兔，从第二个月起就开始生兔子；假定每对兔子都是一雌一雄，试问一对兔子，第n个月能繁殖成多少对兔子？（使用callee完成）12345678910111213141516171819202122232425262728293031var result=[];function fn(n)&#123; //典型的斐波那契数列 if(n==1)&#123; return 1; &#125;else if(n==2)&#123; return 1; &#125;else&#123; if(result[n])&#123; return result[n]; &#125;else&#123; //argument.callee()表示fn() result[n]=arguments.callee(n-1)+arguments.callee(n-2); return result[n]; &#125; &#125;&#125; 44、Javascript中, 以下哪条语句一定会产生运行错误？ 答案( B )A、 var _变量=NaN;B、var 0bj = [];C、var obj = //; D、var obj = {}; 45、以下两个变量a和b，a+b的哪个结果是NaN？ 答案( C )A、var a=undefind; b=NaN B、var a=‘123’; b=NaN C、var a =undefined , b =NaN D、var a=NaN , b=’undefined’ 46、var a=10; b=20; c=4; ++b+c+a++ 以下哪个结果是正确的？答案( B )A、 34 B、35 C、36 D、37 47、下面的JavaScript语句中，（ D ）实现检索当前页面中的表单元素中的所有文本框，并将它们全部清空A. for(vari=0;i&lt; form1.elements.length;i++) { if(form1.elements.type==”text”) form1.elements.value=””;} B. for(vari=0;i&lt;document.forms.length;i++) { if(forms[0].elements.type==”text”) forms[0].elements.value=””; } C. if(document.form.elements.type==”text”) form.elements.value=””; D. for(vari=0;i&lt;document.forms.length; i++){ for(var j=0;j&lt;document.forms.elements.length; j++){ if(document.forms.elements[j].type==”text”) document.forms.elements[j].value=””; } } 48、要将页面的状态栏中显示“已经选中该文本框”，下列JavaScript语句正确的是（ A ） A. window.status=”已经选中该文本框” B. document.status=”已经选中该文本框” C. window.screen=”已经选中该文本框” D. document.screen=”已经选中该文本框” 49、以下哪条语句会产生运行错误：（A）A.var obj = ();B.var obj = [];C.var obj = {};D.var obj = //;50、以下哪个单词不属于javascript保留字：（B）A.withB.parentC.classD.void51、请选择结果为真的表达式：（C）A.null instanceof ObjectB.null === undefinedC.null == undefinedD.NaN == NaN52、Javascript中, 如果已知HTML页面中的某标签对象的id=”username”，用_document.getElementById(‘username’) `方法获得该标签对象。``53、typeof运算符返回值中有一个跟javascript数据类型不一致，它是__”function”__。54、定义了一个变量，但没有为该变量赋值，如果alert该变量，javascript弹出的对话框中显示_undefined__ 。55、分析代码，得出正确的结果。1234567891011var a=10, b=20 , c=30;++a;a++;e=++a+(++b)+(c++)+a++;alert(e);弹出提示对话框：77 56、写出函数DateDemo的返回结果，系统时间假定为今天12345678910111213function DateDemo()&#123; var d, s=&quot;今天日期是：&quot;; d = new Date();s += d.getMonth() + &quot;/&quot;;s += d.getDate() + &quot;/&quot;;s += d.getYear();return s;&#125; 结果：今天日期是：7/17/2010 57、写出程序运行的结果？123for(i=0, j=0; i&lt;10, j&lt;6; i++, j++)&#123;k = i + j;&#125; 结果：10 58、阅读以下代码，请分析出结果：1234567891011 var arr = new Array(1 ,3 ,5); arr[4]=&apos;z&apos;; arr2 = arr.reverse(); arr3 = arr.concat(arr2); alert(arr3);弹出提示对话框：z,,5,3,1,z,,5,3,1 59、补充按钮事件的函数，确认用户是否退出当前页面，确认之后关闭窗口；12345678910111213141516171819202122232425262728 &lt;html&gt;&lt;head&gt;&lt;script type=”text/javascript” &gt;function closeWin()&#123;//在此处添加代码if(confirm(“确定要退出吗？”))&#123;window.close();&#125;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=”button”value=”关闭窗口”onclick=”closeWin()”/&gt;&lt;/body&gt;&lt;/html&gt; 60、写出简单描述html标签（不带属性的开始标签和结束标签）的正则表达式，并将以下字符串中的html标签去除掉12345678910111213var str = “&lt;div&gt;这里是div&lt;p&gt;里面的段落&lt;/p&gt;&lt;/div&gt;”;//&lt;scripttype=”text/javascript”&gt;varreg = /&lt;\/?\w+\/?&gt;/gi;varstr = “&lt;div&gt;这里是div&lt;p&gt;里面的段落&lt;/p&gt;&lt;/div&gt;”;alert(str.replace(reg,”&quot;));&lt;/script&gt; 61、完成foo()函数的内容，要求能够弹出对话框提示当前选中的是第几个单选框。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;html&gt;&lt;head&gt;&lt;metahttp-equiv=”Content-Type” content=”text/html;charset=utf-8″ /&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=”text/javascript” &gt;function foo() &#123;//在此处添加代码var rdo =document.form1.radioGroup;for(var i =0 ;i&lt;rdo.length;i++)&#123;if(rdo.checked)&#123;alert(“您选择的是第”+(i+1)+”个单选框”);&#125;&#125;&#125;&lt;/script&gt;&lt;body&gt;&lt;form name=”form1″ &gt;&lt;input type=”radio” name=”radioGroup”/&gt;&lt;input type=”radio” name=”radioGroup”/&gt;&lt;input type=”radio” name=”radioGroup”/&gt;&lt;input type=”radio” name=”radioGroup”/&gt;&lt;input type=”submit”/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 62、完成函数showImg()，要求能够动态根据下拉列表的选项变化，更新图片的显示1234567891011121314151617181920212223242526272829&lt;body&gt;&lt;script type=”text/javascript” &gt;function showImg (oSel) &#123;//在此处添加代码var str = oSel.value;document.getElementById(“pic”).src= str+”.jpg”;&#125;&lt;/script&gt;&lt;img id=”pic”src=”img1.jpg”width=”200″ height=”200″ /&gt;&lt;br /&gt;&lt;select id=”sel”&gt;&lt;option value=”img1“&gt;城市生活&lt;/option&gt;&lt;option value=”img2“&gt;都市早报&lt;/option&gt;&lt;option value=”img3“&gt;青山绿水&lt;/option&gt;&lt;/select&gt;&lt;/body&gt; 63、截取字符串abcdefg的efg1alert(&apos;abcdefg&apos;.substring(4)); 64、列举浏览器对象模型BOM里常用的至少4个对象，并列举window对象的常用方法至少5个对象：Window document location screen history navigator 方法：Alert() confirm() prompt() open() close() 65、简述列举文档对象模型DOM里document的常用的查找访问节点的方法并做简单说明Document.getElementById 根据元素id查找元素 Document.getElementByName 根据元素name查找元素 Document.getElementTagName 根据指定的元素名查找元素 66、希望获取到页面中所有的checkbox怎么做？(不使用第三方框架)123456789101112131415var domList = document.getElementsByTagName(‘input’)var checkBoxList = [];var len = domList.length; //缓存到局部变量while (len--) &#123; //使用while的效率会比for循环更高 if (domList[len].type == ‘checkbox’) &#123; checkBoxList.push(domList[len]); &#125;&#125; 67、JavaScript的数据类型都有什么？基本数据类型：String,Boolean,Number,Undefined,Null 引用数据类型：Object(Array,Date,RegEx p,Function) 68、javascript中有哪几种数据类型，分别写出中文和英文。string boolean number null undefined object 字符串 布尔 数值 空值 未定义 对象 69、javascript中==和===的区别是什么？举例说明。===会自动进行类型转换，==不会 70、简述创建函数的几种方式第一种（函数声明）： function sum1(num1,num2){ return num1+num2; } 第二种（函数表达式）： var sum2 = function(num1,num2){ return num1+num2; } 第三种（函数对象方式）： var sum3 = new Function(“num1”,”num2”,”return num1+num2”); 71、Javascript如何实现继承？原型链继承，借用构造函数继承，组合继承，寄生式继承，寄生组合继承 72、Javascript创建对象的几种方式？工厂方式，构造函数方式，原型模式，混合构造函数原型模式，动态原型方式 73、把 Script 标签 放在页面的最底部的body封闭之前 和封闭之后有什么区别？浏览器会如何解析它们？74、iframe的优缺点？优点： 解决加载缓慢的第三方内容如图标和广告等的加载问题 Security sandbox 并行加载脚本 缺点： iframe会阻塞主页面的Onload事件 即时内容为空，加载也需要时间 没有语意 75、请你谈谈Cookie的弊端？缺点： 1.Cookie数量和长度的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉。 2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目的了。 3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。 76、DOM操作——怎样添加、移除、移动、复制、创建和查找节点。 创建新节点 createDocumentFragment() // 创建一个DOM片段 createElement() // 创建一个具体的元素 createTextNode() // 创建一个文本节点 添加、移除、替换、插入 appendChild() removeChild() replaceChild() insertBefore() // 在已有的子节点前插入一个新的子节点 查找 getElementsByTagName() // 通过标签名称 getElementsByName() // 通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的) getElementById() // 通过元素Id，唯一性 77、js延迟加载的方式有哪些？ 1. defer和async 2. 动态创建DOM方式（创建script，插入到DOM中，加载完毕后callBack） 3. 按需异步载入js 78、documen.write和 innerHTML 的区别？document.write 只能重绘整个页面 innerHTML 可以重绘页面的一部分 79、哪些操作会造成内存泄漏？内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。 垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。 setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。 闭包 控制台日志 循环（在两个对象彼此引用且彼此保留时，就会产生一个循环） 80、javascript的typeof返回哪些数据类型?答：object、 number、 function 、boolean、 underfind 81、split() join() 的区别答：前者是切割成数组的形式，后者是将数组转换成字符串 82、数组方法pop() push() unshift() shift()各表示什么意思？答：Push()尾部添加、pop()尾部删除、Unshift()头部添加、shift()头部删除 83、判断一个字符串中出现次数最多的字符，统计这个次数答：123456789101112131415161718var str = &apos;asdfssaaasasasasaa&apos;;var json = &#123;&#125;;for (var i = 0; i &lt; str.length; i++) &#123; if(!json[str.charAt(i)])&#123; json[str.charAt(i)] = 1; &#125;else&#123; json[str.charAt(i)]++; &#125;&#125;;var iMax = 0;var iIndex = &apos;&apos;;for(var i in json)&#123; if(json[i]&gt;iMax)&#123; iMax = json[i]; iIndex = i; &#125;&#125;alert(&apos;出现次数最多的是:&apos;+iIndex+&apos;出现&apos;+iMax+&apos;次&apos;); 84、javascript的typeof返回哪些数据类型Object number function boolean underfind 85、例举3种强制类型转换和2种隐式类型转换?强制（parseInt,parseFloat,number） 隐式（== – ===） 86、split() join() 的区别前者是切割成数组的形式，后者是将数组转换成字符串 87、数组方法pop() push() unshift() shift()Push()尾部添加 shift() 尾部删除 Unshift() 头部添加 shift() 头部删除 88、事件绑定和普通事件有什么区别事件绑定和普通事件有什么区别 89、IE和DOM事件流的区别1.执行顺序不一样、 2.参数不一样 3.事件加不加on 4.this指向问题 90、IE和标准下有哪些兼容性的写法Var ev = ev || window.event document.documentElement.clientWidth || document.body.clientWidth Var target = ev.srcElement||ev.target 91、call和apply的区别Object.call(this,obj1,obj2,obj3) Object.apply(this,arguments) 92、b继承a的方法93、写一个获取非行间样式的函数123456789101112131415161718192021222324252627282930313233function getStyle(obj,attr,value)&#123; if(!value) &#123; if(obj.currentStyle) &#123; return obj.currentStyle(attr); &#125; else&#123; obj.getComputedStyle(attr,false); &#125; &#125; else &#123; obj.style[attr] = value; &#125;&#125; 94、事件委托是什么让利用事件冒泡的原理，让自己的所触发的事件，让他的父元素代替执行！ http://www.webasily.com/?p=78 例子可见此链接 事件委托是什么 95、闭包是什么，有什么特性，对页面有什么影响闭包就是能够读取其他函数内部变量的函数。 http://blog.csdn.NET/gaoshanwudi/article/details/7355794 此链接可查看（问这个问题的不是一个公司） 96、解释jsonp的原理，以及为什么不是真正的ajax动态创建script标签，回调函数 Ajax是页面无刷新请求数据操作 97、javascript的本地对象，内置对象和宿主对象本地对象为array obj regexp等可以new实例化 内置对象为gload Math 等不可以实例化的 宿主为浏览器自带的document,window 等 98、document load 和document ready的区别Document.onload 是在结构和样式加载完才执行js Document.ready原生种没有这个方法，jquery中有 $().ready(function) 99、字符串反转，如将 ‘12345678’ 变成 ‘87654321’1234567891011121314151617181920212223242526272829//大牛做法；//思路：先将字符串转换为数组 split()，利用数组的反序函数 reverse()颠倒数组，再利用 jion() 转换为字符串var str = &apos;12345678&apos;;str = str.split(&apos;&apos;).reverse().join(&apos;&apos;);100、将数字 12345678 转化成 RMB形式 如： 12,345,678//个人方法；//思路：先将数字转为字符， str= str + &apos;&apos; ;//利用反转函数，每三位字符加一个 &apos;,&apos;最后一位不加； re()是自定义的反转函数，最后再反转回去！for(var i = 1; i &lt;= re(str).length; i++)&#123; tmp += re(str)[i - 1]; if(i % 3 == 0 &amp;&amp; i != re(str).length)&#123; tmp += &apos;,&apos;; &#125;&#125; 101、生成5个不同的随机数； //思路：5个不同的数，每生成一次就和前面的所有数字相比较，如果有相同的，则放弃当前生成的数字！1234567891011121314151617var num1 = [];for(var i = 0; i &lt; 5; i++)&#123; num1[i] = Math.floor(Math.random()*10) + 1; //范围是 [1, 10] for(var j = 0; j &lt; i; j++)&#123; if(num1[i] == num1[j])&#123; i--; &#125; &#125;&#125; 102、去掉数组中重复的数字 方法一； //思路：每遍历一次就和之前的所有做比较，不相等则放入新的数组中！ //这里用的原型 个人做法；123456789101112131415161718192021222324252627Array.prototype.unique = function()&#123; var len = this.length, newArr = [], flag = 1; for(var i = 0; i &lt; len; i++, flag = 1)&#123; for(var j = 0; j &lt; i; j++)&#123; if(this[i] == this[j])&#123; flag = 0; //找到相同的数字后，不执行添加数据 &#125; &#125; flag ? newArr.push(this[i]) : &apos;&apos;; &#125; return newArr;&#125; 方法二： 12345678910111213141516171819202122232425262728(function(arr)&#123; var len = arr.length, newArr = [], flag; for(var i = 0; i &lt; len; i+=1, flag = 1)&#123; for(var j = 0; j &lt; i; j++)&#123; if(arr[i] == arr[j])&#123; flag = 0; &#125; &#125; flag?newArr.push(arr[i]):&apos;&apos;; &#125; alert(newArr);&#125;)([1, 1, 22, 3, 4, 55, 66]); 103、阶乘函数； //原型方法1234567891011121314151617Number.prototype.N = function()&#123; var re = 1; for(var i = 1; i &lt;= this; i++)&#123; re *= i; &#125; return re;&#125;var num = 5;alert(num.N()); 104、window.location.search() 返回的是什么？ 答：查询(参数)部分。除了给动态语言赋值以外，我们同样可以给静态页面,并使用javascript来获得相信应的参数值 返回值：?ver=1.0&amp;id=timlq 也就是问号后面的！ 105、window.location.hash 返回的是什么？ 答：锚点 ， 返回值：#love ； 106、window.location.reload() 作用？ 答：刷新当前页面。 107、阻止冒泡函数 123456789101112131415161718192021function stopPropagation(e) &#123; e = e || window.event; if(e.stopPropagation) &#123; //W3C阻止冒泡方法 e.stopPropagation(); &#125; else &#123; e.cancelBubble = true; //IE阻止冒泡方法 &#125; &#125; document.getElementById(&apos;need_hide&apos;).onclick = function(e) &#123; stopPropagation(e); &#125; 108、什么是闭包？ 写一个简单的闭包？； 答：我的理解是，闭包就是能够读取其他函数内部变量的函数。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 1234567891011121314151617function outer()&#123; var num = 1; function inner()&#123; var n = 2; alert(n + num); &#125; return inner;&#125;outer()(); 109、javascript 中的垃圾回收机制？ 答：在Javascript中，如果一个对象不再被引用，那么这个对象就会被GC回收。如果两个对象互相引用，而不再 被第3者所引用，那么这两个互相引用的对象也会被回收。因为函数a被b引用，b又被a外的c引用，这就是为什么 函数a执行后不会被回收的原因。 110、看题做答： 1234567891011121314151617function f1()&#123; var tmp = 1; this.x = 3; console.log(tmp); //A console.log(this.x)； //B&#125;var obj = new f1(); //1console.log(obj.x) //2console.log(f1()); //3 分析： 这道题让我重新认识了对象和函数，首先看代码（1），这里实例话化了 f1这个类。相当于执行了 f1函数。所以这个时候 A 会输出 1， 而 B 这个时候的 this 代表的是 实例化的当前对象 obj B 输出 3.。 代码（2）毋庸置疑会输出 3， 重点 代码（3）首先这里将不再是一个类，它只是一个函数。那么 A输出 1， B呢？这里的this 代表的其实就是window对象，那么this.x 就是一个全局变量 相当于在外部 的一个全局变量。所以 B 输出 3。最后代码由于f没有返回值那么一个函数如果没返回值的话，将会返回 underfined ，所以答案就是 ： 1， 3， 3， 1， 3， underfined 。 111、下面输出多少？ 1234567var o1 = new Object();var o2 = o1;o2.name = &quot;CSSer&quot;;console.log(o1.name); 如果不看答案，你回答真确了的话，那么说明你对javascript的数据类型了解的还是比较清楚了。js中有两种数据类型，分别是：基本数据类型和引用数据类型（object Array）。对于保存基本类型值的变量，变量是按值访问的，因为我们操作的是变量实际保存的值。对于保存引用类型值的变量，变量是按引用访问的，我们操作的是变量值所引用（指向）的对象。答案就清楚了： //CSSer; 112、再来一个 123456789101112131415function changeObjectProperty (o) &#123; o.siteUrl = &quot;http://www.csser.com/&quot;; o = new Object(); o.siteUrl = &quot;http://www.popcg.com/&quot;;&#125;var CSSer = new Object();changeObjectProperty(CSSer);console.log(CSSer.siteUrl); // 如果CSSer参数是按引用传递的，那么结果应该是&quot;http://www.popcg.com/&quot;，但实际结果却仍是&quot;http://www.csser.com/&quot;。事实是这样的：在函数内部修改了引用类型值的参数，该参数值的原始引用保持不变。我们可以把参数想象成局部变量，当参数被重写时，这个变量引用的就是一个局部变量，局部变量的生存期仅限于函数执行的过程中，函数执行完毕，局部变量即被销毁以释放内存。 （补充：内部环境可以通过作用域链访问所有的外部环境中的变量对象，但外部环境无法访问内部环境。每个环境都可以向上搜索作用域链，以查询变量和函数名，反之向下则不能。） 113、输出多少？ 1234567891011var a = 6;setTimeout(function () &#123; var a = 666; alert(a); // 输出666，&#125;, 1000);a = 66; 因为var a = 666;定义了局部变量a，并且赋值为666，根据变量作用域链，全局变量处在作用域末端，优先访问了局部变量，从而覆盖了全局变量 。 1234567891011var a = 6;setTimeout(function () &#123; alert(a); // 输出undefined var a = 666;&#125;, 1000);a = 66; 因为var a = 666;定义了局部变量a，同样覆盖了全局变量，但是在alert(a);之前a并未赋值，所以输出undefined。 123456789101112131415var a = 6;setTimeout(function()&#123; alert(a); var a = 66;&#125;, 1000);a = 666;alert(a);// 666, undefined; 记住： 异步处理，一切OK 声明提前 114、输出多少？ 123456789101112131415function setN(obj)&#123; obj.name=&apos;屌丝&apos;; obj = new Object(); obj.name = &apos;腐女&apos;;&#125;;var per = new Object();setN(per);alert(per.name); //屌丝 内部 115、JS的继承性 1234567891011121314151617window.color = &apos;red&apos;;var o = &#123;color: &apos;blue&apos;&#125;;function sayColor()&#123; alert(this.color);&#125;sayColor(); //redsayColor.call(this); //red this-window对象sayColor.call(window); //redsayColor.call(o); //blue 116、精度问题: JS 精度不能精确到 0.1 所以 。。。。同时存在于值和差值中12345678var n = 0.3,m = 0.2, i = 0.2, j = 0.1;alert((n - m) == (i - j)); //falsealert((n-m) == 0.1); //falsealert((i-j)==0.1); //true 117、加减运算 1234567alert(&apos;5&apos;+3); //53 stringalert(&apos;5&apos;+&apos;3&apos;); //53 stringalert(&apos;5&apos;-3); //2 numberalert(&apos;5&apos;-&apos;3&apos;); //2 number 118、什么是同源策略？ 指： 同协议、端口、域名的安全策略，由王景公司提出来的安全协议！ 119、call和applay的区别是什么？ 参数形式不同，call(obj, pra, pra)后面是单个参数。applay(obj, [args])后面是数组。 120、为什么不能定义1px左右的div容器？IE6下这个问题是因为默认的行高造成的，解决的方法也有很多，例如： overflow:hidden | zoom:0.08 | line-height:1px 121、结果是什么？ 1234567891011121314151617181920212223function foo()&#123; foo.a = function()&#123;alert(1)&#125;; this.a = function()&#123;alert(2)&#125;; a = function()&#123;alert(3)&#125;; var a = function()&#123;alert(4)&#125;;&#125;;foo.prototype.a = function()&#123;alert(5)&#125;;foo.a = function()&#123;alert(6)&#125;;foo.a(); //6var obj = new foo();obj.a(); //2foo.a(); //1 122、输出结果 12345678910111213141516171819var a = 5;function test()&#123; a = 0; alert(a); alert(this.a); //没有定义 a这个属性 var a; alert(a)&#125;test(); // 0, 5, 0new test(); // 0, undefined, 0 //由于类它自身没有属性a， 所以是undefined 123、计算字符串字节数：123456789101112131415161718new function(s)&#123; if(!arguments.length||!s) return null; if(&quot;&quot;==s) return 0; var l=0; for(var i=0;i&lt;s.length;i++)&#123; if(s.charCodeAt(i)&gt;255) l+=2; else l+=1; //charCodeAt()得到的是unCode码 &#125; //汉字的unCode码大于 255bit 就是两个字节 alert(l);&#125;(&quot;hello world!&quot;); 124、结果是： var bool = !!2; alert(bool)；//true; 双向非操作可以把字符串和数字转换为布尔值。 125、声明对象，添加属性，输出属性 12345678910111213 var obj = &#123; name: &apos;leipeng&apos;, showName: function()&#123; alert(this.name); &#125; &#125;obj.showName(); 126、匹配输入的字符：第一个必须是字母或下划线开头，长度5-20 12345678910111213141516171819var reg = /^[a-zA-Z][a-zA-Z0-9_]&#123;5,20&#125;/, name1 = &apos;leipeng&apos;, name2 = &apos;0leipeng&apos;, name3 = &apos;你好leipeng&apos;, name4 = &apos;hi&apos;; alert(reg.test(name1)); alert(reg.test(name2)); alert(reg.test(name3)); alert(reg.test(name4)); 127、检测变量类型 function checkStr(str){ typeof str == &apos;string&apos;? alert(&apos;true&apos;):alert(&apos;false&apos;); } checkStr(&apos;leipeng&apos;); 128、如何在HTML中添加事件，几种方法？ 1、标签之中直接添加 onclick=”fun()”; 2、JS添加 Eobj.onclick = method; 3、现代事件 IE： obj.attachEvent(&apos;onclick&apos;, method)； FF: obj.addEventListener(&apos;click&apos;, method, false); 129、BOM对象有哪些，列举window对象？ 1、window对象 ，是JS的最顶层对象，其他的BOM对象都是window对象的属性； 2、document对象，文档对象； 3、location对象，浏览器当前URL信息； 4、navigator对象，浏览器本身信息； 5、screen对象，客户端屏幕信息； 6、history对象，浏览器访问历史信息； 130、请问代码实现 outerHTML //说明：outerHTML其实就是innerHTML再加上本身； 123456789Object.prototype.outerHTML = function()&#123; var innerCon = this.innerHTML, //获得里面的内容 outerCon = this.appendChild(innerCon); //添加到里面 alert(outerCon); &#125; 演示代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;outer&quot;&gt; hello &lt;/div&gt; &lt;script&gt; Object.prototype.outerHTML = function()&#123; var innerCon = this.innerHTML, //获得里面的内容 outerCon = this.appendChild(innerCon); //添加到里面 alert(outerCon); &#125; function $(id)&#123; return document.getElementById(id); &#125; alert($(&apos;outer&apos;).innerHTML); alert($(&apos;outer&apos;).outerHTML); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 131、JS中的简单继承 call方法！12345678910111213141516171819202122232425262728293031323334353637383940//顶一个父母类，注意：类名都是首字母大写的哦！ function Parent(name, money)&#123; this.name = name; this.money = money; this.info = function()&#123; alert(&apos;姓名： &apos;+this.name+&apos; 钱： &apos;+ this.money); &#125; &#125; //定义孩子类 function Children(name)&#123; Parent.call(this, name); //继承 姓名属性，不要钱。 this.info = function()&#123; alert(&apos;姓名： &apos;+this.name); &#125; &#125; //实例化类 var per = new Parent(&apos;parent&apos;, 800000000000); var chi = new Children(&apos;child&apos;); per.info(); chi.info(); 132、bind(), live(), delegate()的区别 bind： 绑定事件，对新添加的事件不起作用，方法用于将一个处理程序附加到每个匹配元素的事件上并返回jQuery对象。 live： 方法将一个事件处理程序附加到与当前选择器匹配的所有元素（包含现有的或将来添加的）的指定事件上并返回jQuery对象。 delegate： 方法基于一组特定的根元素将处理程序附加到匹配选择器的所有元素（现有的或将来的）的一个或多个事件上。 133、typeof 的返回类型有哪些？ alert(typeof [1, 2]); //object alert(typeof &apos;leipeng&apos;); //string var i = true; alert(typeof i); //boolean alert(typeof 1); //number var a; alert(typeof a); //undefined function a(){;}; alert(typeof a) //function 134、简述link和import的区别？区别1：link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。 区别2：link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。 区别3：link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。 区别4：link支持使用Javascript控制DOM去改变样式；而@import不支持。 135、window.onload 和 document.ready的区别？load要等到图片和包含的文件都加在进来之后执行； ready是不包含图片和非文字文件的文档结构准备好就执行； 136、 解析URL成一个对象？ String.prototype.urlQueryString = function(){ var url = this.split(&apos;?&apos;)[1].split(&apos;&amp;&apos;), len = url.length; this.url = {}; for(var i = 0; i &lt; len; i += 1){ var cell = url[i].split(&apos;=&apos;), key = cell[0], val = cell[1]; this.url[&apos;&apos;+key+&apos;&apos;] = val; } return this.url; } var url = &apos;?name=12&amp;age=23&apos;; console.log(url.urlQueryString().age); 137、看下列代码输出什么？var foo = “11”+2-“1”; console.log(foo); console.log(typeof foo);执行完后foo的值为111，foo的类型为Number。138、看下列代码,输出什么？var a = new Object();a.value = 1;b = a;b.value = 2;alert(a.value);执行完后输出结果为2139、已知数组var stringArray = [“This”, “is”, “Baidu”, “Campus”]，Alert出”This is Baidu Campus”。答案：alert(stringArray.join(“”)) 140、已知有字符串foo=”get-element-by-id”,写一个function将其转化成驼峰表示法”getElementById”。答案：1234567891011121314151617function combo(msg)&#123; var arr = msg.split(&quot;-&quot;); var len = arr.length; //将arr.length存储在一个局部变量可以提高for循环效率 for(var i=1;i&lt;len;i++)&#123; arr[i]=arr[i].charAt(0).toUpperCase()+arr[i].substr(1,arr[i].length-1); &#125; msg=arr.join(&quot;&quot;); return msg;&#125; 141、怎样添加、移除、移动、复制、创建和查找节点 1）创建新节点 createDocumentFragment() //创建一个DOM片段createElement() //创建一个具体的元素createTextNode() //创建一个文本节点 2）添加、移除、替换、插入appendChild() //添加removeChild() //移除replaceChild() //替换insertBefore() //插入 3）查找getElementsByTagName() //通过标签名称getElementsByName() //通过元素的Name属性的值getElementById() //通过元素Id，唯一性 142、原生JS的window.onload与Jquery的$(document).ready(function(){})有什么不同？ window.onload()方法是必须等到页面内包括图片的所有元素加载完毕后才能执行。 $(document).ready()是DOM结构绘制完毕后就执行，不必等到加载完毕。 143、你如何优化自己的代码？代码重用 避免全局变量（命名空间，封闭空间，模块化mvc..） 拆分函数避免函数过于臃肿 注释 144、请描述出下列代码运行的结果1234567function d()&#123; console.log(this);&#125;d(); 145、需要将变量e的值修改为“a+b+c+d”,请写出对应的代码var e=”abcd”; 设计一段代码能够遍历下列整个DOM节点12345678910111213141516171819&lt;div&gt; &lt;p&gt; &lt;span&gt;&lt;a/&gt;&lt;/span&gt; &lt;span&gt;&lt;a/&gt;&lt;/span&gt; &lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 146、怎样实现两栏等高？147、使用js实现这样的效果：在文本域里输入文字时，当按下enter键时不换行，而是替换成“”,(只需要考虑在行尾按下enter键的情况).148、以下代码中end字符串什么时候输出12345678910111213var t=true;setTimeout(function()&#123; console.log(123); t=false; &#125;,1000);while(t)&#123;&#125;console.log(‘end’); 149、specify(‘hello,world’)//=&gt;’h,e,l,l,o,w,o,r,l,d’实现specify函数150、请将一个URL的search部分参数与值转换成一个json对象151、请用原生js实现jquery的get\post功能，以及跨域情况下152、请简要描述web前端性能需要考虑哪方面，你的优化思路是什么？153、简述readyonly与disabled的区别154、判断一个字符吕串出现次数最多的字符，统计这个次数并输出155、编写一个方法，去掉一个数组的复重元素156、写出3个使用this的典型应用157、请尽可能详尽的解释ajax的工作原理158、为什么扩展javascript内置对象不是好的做法？159、请解释一下javascript的同源策略160、什么是三元表达式？“三元”表示什么意思？161、浏览器标准模式和怪异模式之间的区别是什么？162、如果设计中使用了非标准的字体，你该如何去实现？163、用css分别实现某个div元素上下居中和左右居中164、modulo(12,5)//2 实现满足这个结果的modulo函数165、HTTP协议中，GET和POST有什么区别？分别适用什么场景 ？166、HTTP状态消息200 302 304 403 404 500分别表示什么167、HTTP协议中，header信息里面，怎么控制页面失效时间（last-modified,cache-control,Expires分别代表什么）168、HTTP雷锋议目前常用的有哪几个？KEEPALIVE从哪个版本开始出现的？169、业界常用的优化WEB页面加载速度的方法（可以分别从页面元素展现，请求连接，css,js,服务器等方面介绍）170、列举常用的web页面开发，调试以及优化工具171、解释什么是sql注入，xss漏洞172、如何判断一个js变量是数组类型173、请列举js数组类型中的常用方法174、FF与IE中如何阻止事件冒泡，如何获取事件对象，以及如何获取触发事件的元素175、列举常用的js框架以及分别适用的领域176、js中如何实现一个map177、js可否实现面向对象编程，如果可以如何实现js对象的继承178、约瑟夫环—已知n个人（以编号1，2，3…分别表示）围坐在一张圆桌周围。从编号为k的人开始报数，数到m的那个人出列；他的下一个人又从1开始报数，数到m的那个人又出列；依此规律重复下去，直到圆桌周围的人全部出列。179、有1到10w这个10w个数，去除2个并打乱次序，如何找出那两个数？180、如何获取对象a拥有的所有属性（可枚举的、不可枚举的，不包括继承来的属性）181、有下面这样一段HTML结构，使用css实现这样的效果：左边容器无论宽度如何变动，右边容器都能自适应填满父容器剩余的宽度。 182、下面这段代码想要循环昝输出结果01234，请问输出结果是否正确，如果不正确，请说明为什么，并修改循环内的代码使其输出正确结果for(var i=0;i&lt;5;++i){ setTimeout(function(){ console.log(i+’’); },100*i); } 183、解释下这个css选择器什么发生什么？[role=nav]&gt;ul a:not([href^-mailto]){} 184、JavaScript以下哪条语句会产生运行错误A. var obj = (); B. var obj = []; C. var obj = {}; D. var obj = //; 答案：AD 185、以下哪些是javascript的全局函数：（ABC）A. escape 函数可对字符串进行编码，这样就可以在所有的计算机上读取该字符串。ECMAScript v3 反对使用该方法，应用使用 decodeURI() 和 decodeURIComponent() 替代它。 B. parseFloat parseFloat() 函数可解析一个字符串，并返回一个浮点数。 该函数指定字符串中的首个字符是否是数字。如果是，则对字符串进行解析，直到到达数字的末端为止，然后以数字返回该数字，而不是作为字符串。 C. eval 函数可计算某个字符串，并执行其中的的 JavaScript 代码。 D. setTimeout E. alert 186、关于IE的window对象表述正确的有：（ACD）A. window.opener属性本身就是指向window对象 B. window.reload()方法可以用来刷新当前页面 应该是location.reload或者window.location.reload C. window.location=”a.html”和window.location.href=”a.html”的作用都是把当前页面替换成a.html页面 D. 定义了全局变量g；可以用window.g的方式来存取该变量 187、描述错误的是A：Http状态码302表示暂时性转移 对 B:domContentLoaded事件早于onload事件 onload 事件会在页面或图像加载完成后立即发生。 C: IE678不支持事件捕获 D:localStorage 存储的数据在电脑重启后丢失 没有时间限制 try…catch 语句。(在 IE5+、Mozilla 1.0、和 Netscape 6 中可用) 188、关于link和@import的区别正确的是 AA: link属于XHTML标签，而@import是CSS提供的； B：页面被加载时，link会同时被加载，而后者引用的CSS会等到页面被加载完再加载 C：import只在IE5以上才能识别 而link是XHTML标签，无兼容问题 D: link方式的样式的权重高于@import的权重 189、下面正确的是 AA: 跨域问题能通过JsonP方案解决 B：不同子域名间仅能通过修改window.name解决跨域 还可以通过script标签src jsonp等h5 Javasplit等 C：只有在IE中可通过iframe嵌套跨域 D：MediaQuery属性是进行视频格式检测的属性是做响应式的 188、错误的是A: Ajax本质是XMLHttpRequest B: 块元素实际占用的宽度与它的width、border、padding属性有关，与background无关 C: position属性absolute、fixed、—relative—会使文档脱标 D: float属性left也会使div脱标 189、不用任何插件，如何实现一个tab栏切换？190、基本数据类型的专业术语以及单词拼写191、变量的命名规范以及命名推荐192、三种弹窗的单词以及三种弹窗的功能193、console.log( 8 | 1 ); 输出值是多少？答案：9 194、只允许使用 + - / 和 Math. ，求一个函数 y = f(x, a, b);当x &gt; 100 时返回 a 的值，否则返回 b 的值，不能使用 if else 等条件语句，也不能使用|,?:,数组。答案：123456789function f(x, a, b) &#123; var temp = Math.ceil(Math.min(Math.max(x - 100, 0), 1)); return a * temp + b * (1 - temp);&#125;console.log(f(-10, 1, 2)); 195、JavaScriptalert(0.4*0.2);结果是多少？和你预期的一样吗？如果不一样该如何处理？ 有误差，应该比准确结果偏大。 一般我会将小数变为整数来处理。当前之前遇到这个问题时也上网查询发现有人用try catch return写了一个函数， 当然原理也是一致先转为整数再计算。看起来挺麻烦的，我没用过。 196、一个div，有几种方式得到这个div的jQuery对象？想直接获取这个div的dom对象，如何获取？dom对象如何转化为jQuery对象？197、主流浏览器内核IE trident 火狐gecko 谷歌苹果webkit Opera：Presto 198、如何显示/隐藏一个dom元素？请用原生的JavaScript方法实现199、JavaScript有哪几种数据类型 Number String Boolean Null Undefined Object 200、jQuery框架中$.ajax()的常用参数有哪些？写一个post请求并带有发送数据和返回数据的样例201、JavaScript数组元素添加、删除、排序等方法有哪些？Array.concat( ) 连接数组 Array.join( ) 将数组元素连接起来以构建一个字符串 Array.length 数组的大小 Array.pop( ) 删除并返回数组的最后一个元素 Array.push( ) 给数组添加元素 Array.reverse( ) 颠倒数组中元素的顺序 Array.shift( ) 将元素移出数组 Array.slice( ) 返回数组的一部分 Array.sort( ) 对数组元素进行排序 Array.splice( ) 插入、删除或替换数组的元素 Array.toLocaleString( ) 把数组转换成局部字符串 Array.toString( ) 将数组转换成一个字符串 Array.unshift( ) 在数组头部插入一个元素 202、如何添加html元素的事件，有几种方法？请列举直接在标签里添加；在元素上添加、使用事件注册函数添加 203、JavaScript的循环语句有哪些？while for do while forEach 204、作用域-编译期执行期以及全局局部作用域问题理解js执行主要的两个阶段：预解析和执行期 205、闭包：下面这个ul，如何点击每一列的时候alert其index？123456789&lt;ul id=&quot;test&quot;&gt;&lt;li&gt;这是第一条&lt;/li&gt;&lt;li&gt;这是第二条&lt;/li&gt;&lt;li&gt;这是第三条&lt;/li&gt;&lt;/ul&gt; 206、列出3条以上ff和IE的脚本兼容问题1、在IE下可通过document.frames[“id”];得到该IFRAME对象， 而在火狐下则是通过document.getElementById(“content_panel_if”).contentWindow; 2、IE的写法： `_tbody=_table.childNodes[0]`` 在FF中，firefox会在子节点中包含空白则第一个子节点为空白””， 而ie不会返回空白 可以通过if(“” != node.nodeName)过滤掉空白子对象 3、模拟点击事件123456789101112131415if(document.all)&#123; //ie下 document.getElementById(&quot;a3&quot;).click(); &#125;else&#123; //非IE var evt = document.createEvent(&quot;MouseEvents&quot;); evt.initEvent(&quot;click&quot;, true, true); document.getElementById(&quot;a3&quot;).dispatchEvent(evt);&#125; 4、事件注册 if (isIE){window.attachEvent(“onload”, init);}else{window.addEventListener(“load”, init, false);} 207、列举可以哪些方面对前端开发进行优化代码压缩、合并减少http请求，图片制作精灵图、代码优化 208、至少列出一种JavaScript继承的实现方式209、如现在有一个效果，有显示用户头像、用户昵称、用户其他信息；当用户鼠标移到头像上时，会弹出用户的所有信息；如果是你，你会如何实现这个功能，请用代码实现？210、call与apply有什么作用？又有什么什么区别？用callee属性实现函数递归？apply的参数是数组,call的参数是单个的值，除此之外，两者没有差别，重点理解this的改变，callee已经不推荐使用 211、用正则表达式，写出由字母开头，其余由数字、字母、下划线组成的6~30的字符串？212、列举浏览器对象模型BOM里常用的至少4个对象，并列举window对象的常用方法至少5个 （10分）对象：Window document location screen history navigator 方法：Alert() confirm() prompt() open() close() 213、Javascript中callee和caller的作用？caller是返回一个对函数的引用，该函数调用了当前函数； callee是返回正在被执行的function函数，也就是所指定的function对象的正文。 214、对于apply和call两者在作用上是相同的，即是调用一个对象的一个方法，以另一个对象替换当前对象。将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。但两者在参数上有区别的。对于第一个参数意义都一样，但对第二个参数：?apply传入的是一个参数数组，也就是将多个参数组合成为一个数组传入，而call则作为call的参数传入（从第二个参数开始）。?如 func.call(func1,var1,var2,var3)对应的apply写法为：func.apply(func1,[var1,var2,var3]) 。 215、在Javascript中什么是伪数组？如何将伪数组转化为标准数组？伪数组（类数组）：无法直接调用数组方法或期望length属性有什么特殊的行为，但仍可以对真正数组遍历方法来遍历它们。典型的是函数的argument参数，还有像调用getElementsByTagName,document.childNodes之类的,它们都返回NodeList对象都属于伪数组。可以使用Array.prototype.slice.call(fakeArray)将数组转化为真正的Array对象。 216、写一个函数可以计算 sum(5,0,-5);输出0; sum(1,2,3,4);输出10;Js基本功 217、事件代理怎么实现？在元素的父节点注册事件，通过事件冒泡，在父节点捕获事件 218、《正则》写出正确的正则表达式匹配固话号，区号3-4位，第一位为0，中横线，7-8位数字，中横线，3-4位分机号格式的固话号常用正则表达式语法要熟悉 219、《算法》 一下A,B可任选一题作答，两题全答加分A:农场买了一只羊，第一年是小羊，第二年底生一只，第三年不生，第四年底再生一只，第五年死掉。 B:写出代码对下列数组去重并从大到小排列{5,2,3,6,8,6,5,4,7,1,9} 220、请写出一张图片的HTML代码，已知道图片地址为“images/abc.jpg”,宽100px，高50px221、请写一个正则表达式：要求最短6位数，最长20位，阿拉伯数和英文字母（不区分大小写）组成1^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])[a-zA-Z\d]&#123;6,20&#125;$ 222、统计1到400亿之间的自然数中含有多少个1？比如1-21中，有1、10、11、21这四个自然数有5个1223、删除与某个字符相邻且相同的字符，比如fdaffdaaklfjklja字符串处理之后成为“fdafdaklfjklja”224、请写出三种以上的Firefox有但InternetExplorer没有的属性和函数1、在IE下可通过document.frames[“id”];得到该IFRAME对象， 而在火狐下则是通过document.getElementById(“content_panel_if”).contentWindow; 2、IE的写法： `_tbody=_table.childNodes[0]`` 在FF中，firefox会在子节点中包含空白则第一个子节点为空白””， 而ie不会返回空白 可以通过if(“” != node.nodeName)过滤掉空白子对象 3、模拟点击事件123456789101112131415if(document.all)&#123; //ie下 document.getElementById(&quot;a3&quot;).click();&#125;else&#123; //非IE var evt = document.createEvent(&quot;MouseEvents&quot;); evt.initEvent(&quot;click&quot;, true, true); document.getElementById(&quot;a3&quot;).dispatchEvent(evt);&#125; 4、事件注册 if (isIE){window.attachEvent(“onload”, init);}else{window.addEventListener(“load”, init, false);} 225、请写出一个程序，在页面加载完成后动态创建一个form表单，并在里面添加一个input对象并给它任意赋值后义post方式提交到：http://127.0.0.1/save.php 226、用JavaScript实现冒泡排序。数据为23、45、18、37、92、13、24面试经常遇到的排序，查找算法要熟悉 227、解释一下什么叫闭包，并实现一段闭包代码简单理解就是函数的嵌套形成闭包，闭包包括函数本身及其外部作用域 228、简述一下什么叫事件委托以及其原理在元素的父节点注册事件，通过事件冒泡，在父节点捕获事件 229、前端代码优化的方法12345678910111213141516171819var User = &#123; 对象 count = 1，属性 getCount：function（）&#123; 方法 return this.count; &#125;&#125;console.log(User.getCount());var func = User.getCount;console.log(func());1 undefined（window）; 230、下列JavaScript代码执行后，依次alert的结果是12345678910111213(function test()&#123; var a=b=5; alert(typeof a); alert(typeof b);&#125;)();alert(typeof a);alert(typeof b); 231、下列JavaScript代码执行后，iNum的值是12345678910111213var iNum = 0;for(var i = 1; i&lt; 10; i++)&#123; if(i % 5 == 0)&#123; continue; &#125; iNum++;&#125; 232、输出结果是多少？12345678910111213 1） var a;var b = a * 0;if (b == b) &#123; console.log(b * 2 + &quot;2&quot; - 0 + 4);&#125; else &#123; console.log(!b * 2 + &quot;2&quot; - 0 + 4);&#125; 答案：26 2）1234567891011121314151617181920212223&lt;script&gt; var a = 1;&lt;/script&gt;&lt;script&gt;var a;var b = a * 0;if (b == b) &#123; console.log(b * 2 + &quot;2&quot; - 0 + 4);&#125; else &#123; console.log(!b * 2 + &quot;2&quot; - 0 + 4);&#125;&lt;/script&gt; 答案：6 3）123456789 var t = 10;function test(t)&#123; var t = t++;&#125;test(t);console.log(t); 答案：10 4）1234567891011var t = 10;function test(test)&#123; var t = test++;&#125;test(t);console.log(t);答案：10 6）1234567891011var t = 10;function test(test)&#123; t = test++;&#125;test(t);console.log(t);答案：10 7） var t = 10;1234567891011function test(test)&#123; t = t + test; console.log(t); var t = 3;&#125;test(t);console.log(t); 答案：NaN 10 8）var a;1234567891011var b = a / 0;if (b == b) &#123; console.log(b * 2 + &quot;2&quot; - 0 + 4);&#125; else &#123; console.log(!b * 2 + &quot;2&quot; - 0 + 4);&#125; 答案：26123456789101112131415161718192021222324259）&lt;script&gt; var a = 1;&lt;/script&gt;&lt;script&gt; var a; var b = a / 0; if (b == b) &#123; console.log(b * 2 + &quot;2&quot; + 4); &#125; else &#123; console.log(!b * 2 + &quot;2&quot; + 4); &#125;&lt;/script&gt;答案：Infinity24 233、12345678910111213141516171819&lt;body&gt;&lt;form id=&apos;form1&apos;&gt;&lt;div id=&apos;div1&apos;&gt;&lt;/div&gt;&lt;div id=&apos;div2&apos;&gt;&lt;/div&gt;&lt;div id=&apos;div3&apos;&gt;&lt;/div&gt;&lt;div id=&apos;div4&apos;&gt;&lt;/div&gt;&lt;div id=&apos;div5&apos;&gt;&lt;/div&gt;&lt;div id=&apos;div3&apos;&gt;id名重复的元素&lt;/div&gt;&lt;/form&gt;&lt;/body&gt; 用程序实现找到html中id名相同的元素？ 234、下列JavaScript代码执行后，运行的结果是1234567891011121314151617&lt;button id=&apos;btn&apos;&gt;点击我&lt;/button&gt;var btn = document.getElementById(&apos;btn&apos;);var handler = &#123; id: &apos;_eventHandler&apos;, exec: function()&#123; alert(this.id); &#125;&#125;btn.addEventListener(&apos;click&apos;, handler.exec.false); 235、下列JavaScript代码执行后，依次alert的结果是123456789101112131415161718192021var obj = &#123;proto: &#123;a:1,b:2&#125;&#125;;function F()&#123;&#125;;F.prototype = obj.proto;var f = new F();obj.proto.c = 3;obj.proto = &#123;a:-1, b:-2&#125;;alert(f.a);alert(f.c);delete F.prototype[&apos;a&apos;];alert(f.a);alert(obj.proto.a); 236、下列JavaScript代码执行后的效果是12345678910111213141516171819202122232425&lt;ul id=&apos;list&apos;&gt;&lt;li&gt;item&lt;/li&gt;&lt;li&gt;item&lt;/li&gt;&lt;li&gt;item&lt;/li&gt;&lt;li&gt;item&lt;/li&gt;&lt;li&gt;item&lt;/li&gt;&lt;/ul&gt;var items = document.querySelectorAll(&apos;#list&gt;li&apos;);for(var i = 0;i &lt; items.length; i++)&#123; setTimeout(function()&#123; items[i].style.backgroundColor = &apos;#fee&apos;; &#125;, 5);&#125; 237、下列JavaScript代码执行后的li元素的数量是12345678910111213141516171819202122232425&lt;ul&gt;&lt;li&gt;Item&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;Item&lt;/li&gt;&lt;li&gt;Item&lt;/li&gt;&lt;/ul&gt;var items = document.getElementsByTagName(&apos;li&apos;);for(var i = 0; i&lt; items.length; i++)&#123; if(items[i].innerHTML == &apos;&apos;)&#123; items[i].parentNode.removeChild(items[i]); &#125;&#125; 238、程序中捕获异常的方法？window.error try{}catch(){}finally{} 239、将字符串”{$id}{$name}”中的{$id}替换成10，{$name}替换成Tony （使用正则表达式）答案：”{$id}{$id}_{$name}”.replace(/{\$id}/g,?’10′).replace(/{\$name}/g,?‘Tony’); 240、给String对象添加一个方法，传入一个string类型的参数，然后将string的每个字符间价格空格返回，例如：addSpace(“hello world”) // -&gt; ‘h e l l o ?w o r l d’ String.prototype.spacify = function(){ return this.split(‘’).join(‘ ‘); }; 241、写出函数DateDemo的返回结果，系统时间假定为今天1234567891011121314151617function DateDemo()&#123; var d, s=&quot;今天日期是：&quot;;d = new Date();s += d.getMonth() + &quot;/&quot;;s += d.getDate() + &quot;/&quot;;s += d.getYear(); return s;&#125;结果：今天日期是：7/17/2010 242、输出今天的日期，以YYYY-MM-DD的方式，比如今天是2014年9月26日，则输出2014-09-26123456789101112131415161718192021var d = new Date();// 获取年，getFullYear()返回4位的数字var year = d.getFullYear();// 获取月，月份比较特殊，0是1月，11是12月var month = d.getMonth() + 1;// 变成两位month = month &lt; 10 ? &apos;0&apos; + month : month;// 获取日var day = d.getDate();day = day &lt; 10 ? &apos;0&apos; + day : day;alert(year + &apos;-&apos; + month + &apos;-&apos; + day); 243、已知数组var?stringArray?=?[“This”,?“is”,?“Baidu”,?“Campus”]，Alert出”This?is?Baidu?Campus”。答案：alert(stringArray.join(“”)) 244、已知有字符串foo=”get-element-by-id”,写一个function将其转化成驼峰表示法”getElementById”。123456789101112131415function combo(msg)&#123;var arr=msg.split(&quot;-&quot;);for(var i=1;i&lt;arr.length;i++)&#123;arr[i]=arr[i].charAt(0).toUpperCase()+arr[i].substr(1,arr[i].length-1);&#125;msg=arr.join(&quot;&quot;);return msg;&#125; 245、.varnumberArray=[3,6,2,4,1,5]; （考察基础API）1)实现对该数组的倒排，输出[5,1,4,2,6,3] 2)实现对该数组的降序排列，输出[6,5,4,3,2,1]123456789101112131415function combo(msg)&#123;var arr=msg.split(&quot;-&quot;);for(var i=1;i&lt;arr.length;i++)&#123;arr[i]=arr[i].charAt(0).toUpperCase()+arr[i].substr(1,arr[i].length-1);&#125;msg=arr.join(&quot;&quot;);return msg;&#125; 246、把两个数组合并，并删除第二个元素。12345var array1 = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];var bArray = [&apos;d&apos;,&apos;e&apos;,&apos;f&apos;];var cArray = array1 247、如何消除一个数组里面重复的元素？1234567891011121314151617181920212223242526272829303132333435var arr=[1,2,3,3,4,4,5,5,6,1,9,3,25,4];function deRepeat()&#123;var newArr=[];var obj=&#123;&#125;;var index=0;var l=arr.length;for(var i=0;i&lt;l;i++)&#123;if(obj[arr[i]]==undefined)&#123;obj[arr[i]]=1;newArr[index++]=arr[i];&#125;else if(obj[arr[i]]==1)&#125;return newArr;&#125;var newArr2=deRepeat(arr);alert(newArr2); //输出1,2,3,4,5,6,9,25 248、用js实现随机选取10–100之间的10个数字，存入一个数组，并排序。1234567891011121314151617var iArray = [];funtion getRandom(istart, iend)&#123;var iChoice = istart - iend +1;return Math.floor(Math.random() * iChoice + istart;&#125;for(var i=0; i&lt;10; i++)&#123;iArray.push(getRandom(10,100));&#125;iArray.sort(); 249、正则表达式构造函数var reg=new RegExp(“xxx”)与正则表达字面量var reg=//有什么不同？匹配邮箱的正则表达式？答案：当使用RegExp()构造函数的时候，不仅需要转义引号（即\”表示”），并且还需要双反斜杠（即\表示一个\）。使用正则表达字面量的效率更高。? 250、1 var regMail = /^([a-zA-Z0-9-])+@([a-zA-Z0-9-])+((.[a-zA-Z0-9_-]{2,3}){1,2})$/;正则表达式对象3 – 清除空格 写一个function，清除字符串前后的空格。（兼容所有浏览器） 使用自带接口trim()，考虑兼容性：12345678910111213if (!String.prototype.trim) &#123;String.prototype.trim = function() &#123;return this.replace(/^\s+/, &quot;&quot;).replace(/\s+$/,&quot;&quot;);&#125; &#125;// test the functionvar str = &quot; \t\n test string &quot;.trim();alert(str == &quot;test string&quot;); // alerts &quot;true&quot; 251、数组和字符串12345678910111213141516171819202122232425262728293031323334353637&lt;script lang=&quot;JavaScript&quot; type=&quot;text/javascript&quot;&gt; function outPut(s) &#123; document.writeln(s); &#125; var a = &quot;lashou&quot;; var b = a; outPut(b); a = &quot;拉手&quot;; outPut(a); outPut(b); var a_array = [1, 2, 3]; var b_array = a_array; outPut(b_array); a_array[3] = 4; outPut(a_array); outPut(b_array);&lt;/script&gt;输出结果：答案：lashou 拉手 lashou 1,2,3 1,2,3,4 1,2,3,4 252、下列控制台都输出什么第1题：1234567891011function setName()&#123; name=&quot;张三&quot;;&#125;setName();console.log(name);答案：&quot;张三&quot; 253、第2题：123456789101112131415//考点：1、变量声明提升 2、变量搜索机制var a=1;function test()&#123; console.log(a); var a=1;&#125;test();答案：undefined 254、第3题：12345678910111213var b=2;function test2()&#123; window.b=3; console.log(b);&#125;test2();答案：3 255、第4题：123456789101112131415c=5;//声明一个全局变量cfunction test3()&#123; window.c=3; console.log(c); //答案：undefined，原因：由于此时的c是一个局部变量c，并且没有被赋值 var c; console.log(window.c);//答案：3，原因：这里的c就是一个全局变量c&#125;test3(); 256、第5题：1234567891011var arr = [];arr[0] = &apos;a&apos;;arr[1] = &apos;b&apos;;arr[10] = &apos;c&apos;;alert(arr.length); //答案：11console.log(arr[5]); //答案：undefined 257、第6题：123456789101112var a=1;console.log(a++); //答案：1console.log(++a); //答案：3258、第7题：console.log(null==undefined); //答案：trueconsole.log(&quot;1&quot;==1); //答案：true，因为会将数字1先转换为字符串1console.log(&quot;1&quot;===1); //答案：false，因为数据类型不一致 259、第8题：123456789101112131415typeof 1; &quot;number&quot;typeof &quot;hello&quot;; &quot;string&quot;typeof /[0-9]/; &quot;object&quot;typeof &#123;&#125;; &quot;object&quot;typeof null; &quot;object&quot;typeof undefined; &quot;undefined&quot;typeof [1,2,3]; &quot;object&quot;typeof function()&#123;&#125;; //&quot;function&quot; 260、第9题：1234567parseInt(3.14); //3parseFloat(&quot;3asdf&quot;); //3parseInt(&quot;1.23abc456&quot;);parseInt(true);//&quot;true&quot; NaN 261、第10题：123456789101112131415//考点：函数声明提前function bar() &#123; return foo; foo = 10; function foo() &#123;&#125; //var foo = 11;&#125;alert(typeof bar());//&quot;function&quot; 262、第11题：考点：函数声明提前123456789101112131415var foo = 1;function bar() &#123; foo = 10; return; function foo() &#123;&#125;&#125;bar();alert(foo);//答案：1 263、第12题：1234567console.log(a);//是一个函数var a = 3;function a()&#123;&#125;console.log(a);////3 264、第13题：//考点：对arguments的操作 function foo(a) { arguments[0] = 2; alert(a);//答案：2，因为：a、arguments是对实参的访问，b、通过arguments[i]可以修改指定实参的值 } foo(1); 265、第14题：function foo(a) { alert(arguments.length);//答案：3，因为arguments是对实参的访问 } foo(1, 2, 3); 266、第15题bar();//报错 var foo = function bar(name) { console.log(&quot;hello&quot;+name); console.log(bar); }; //alert(typeof bar); foo(“world”);//“hello” console.log(bar);//undefined console.log(foo.toString()); bar();//报错 267、第16题function test(){ console.log(&quot;test函数&quot;); } setTimeout(function(){ console.log(&quot;定时器回调函数&quot;); }, 0) test(); function foo(){ var name=&quot;hello&quot;; } 三、Jquery1、jQuery 的 slideUp动画 ，如果目标元素是被外部事件驱动, 当鼠标快速地连续触发外部元素事件, 动画会滞后的反复执行，该如何处理呢? 四、HTML5 CSS31、CSS3有哪些新特性？ 1. CSS3实现圆角（border-radius），阴影（box-shadow）， 2. 对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform） 3.transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);// 旋转,缩放,定位,倾斜 4. 增加了更多的CSS选择器 多背景 rgba 5. 在CSS3中唯一引入的伪元素是 ::selection. 6. 媒体查询，多栏布局 7. border-image 2、html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？新特性： 1. 拖拽释放(Drag and drop) API 2. 语义化更好的内容标签（header,nav,footer,aside,article,section） 3. 音频、视频API(audio,video) 4. 画布(Canvas) API 5. 地理(Geolocation) API 6. 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失； 7. sessionStorage 的数据在浏览器关闭后自动删除 8. 表单控件，calendar、date、time、email、url、search 9. 新的技术webworker, websocket, Geolocation 移除的元素： 1. 纯表现的元素：basefont，big，center，font, s，strike，tt，u； 2. 对可用性产生负面影响的元素：frame，frameset，noframes； 支持HTML5新标签： IE8/IE7/IE6支持通过 document.createElement 方法产生的标签，可以利用这一特性让这些浏览器支持 Html5 新标签，浏览器支持新标签后，还需要添加标签默认的样式（当然最好的方式是直接使用成熟的框架、使用最多的是html5shim框架）： 如何区分： DOCTYPE声明新增的结构元素、功能元素 3、本地存储（Local Storage ）和cookies（储存在用户本地终端上的数据）之间的区别是什么？Cookies:服务器和客户端都可以访问；大小只有4KB左右；有有效期，过期后将会删除； 本地存储：只有本地浏览器端可访问数据，服务器不能访问本地存储直到故意通过POST或者GET的通道发送到服务器；每个域5MB；没有过期数据，它将保留知道用户从浏览器清除或者使用Javascript代码移除 4、如何实现浏览器内多个标签页之间的通信?调用 localstorge、cookies 等本地存储方式 5、你如何对网站的文件和资源进行优化？文件合并 文件最小化/文件压缩 使用CDN托管 缓存的使用 6、什么是响应式设计？它是关于网页制作的过程中让不同的设备有不同的尺寸和不同的功能。响应式设计是让所有的人能在这些设备上让网站运行正常 7、新的 HTML5 文档类型和字符集是？答：HTML5文档类型：&lt;!doctype html&gt; HTML5使用的编码&lt;meta charset=”UTF-8”&gt; 8、HTML5 Canvas 元素有什么用？答：Canvas 元素用于在网页上绘制图形，该元素标签强大之处在于可以直接在 HTML 上进行图形操作。 9、HTML5 存储类型有什么区别？答：Media API、Text Track API、Application Cache API、User Interaction、Data Transfer API、Command API、Constraint Validation API、History API 10、用H5+CSS3解决下导航栏最后一项掉下来的问题11、CSS3新增伪类有那些？ p:first-of-type 选择属于其父元素的首个 元素的每个 元素。 p:last-of-type 选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 p:only-of-type 选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 p:only-child 选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。 p:nth-child(2) 选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。 :enabled、:disabled 控制表单控件的禁用状态。 :checked，单选框或复选框被选中。 12、请用CSS实现：一个矩形内容，有投影，有圆角，hover状态慢慢变透明。css属性的熟练程度和实践经验 13、描述下CSS3里实现元素动画的方法动画相关属性的熟悉程度 14、html5\CSS3有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，地理定位等功能的增加。 绘画 canvas 元素 用于媒介回放的 video 和 audio 元素 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失； sessionStorage 的数据在浏览器关闭后自动删除 语意化更好的内容元素，比如 article、footer、header、nav、section 表单控件，calendar、date、time、email、url、search CSS3实现圆角，阴影，对文字加特效，增加了更多的CSS选择器 多背景 rgba 新的技术webworker, websockt, Geolocation 移除的元素 纯表现的元素：basefont，big，center，font, s，strike，tt，u； 对可用性产生负面影响的元素：frame，frameset，noframes； 是IE8/IE7/IE6支持通过document.createElement方法产生的标签， 可以利用这一特性让这些浏览器支持HTML5新标签， 浏览器支持新标签后，还需要添加标签默认的样式： 当然最好的方式是直接使用成熟的框架、使用最多的是html5shim框架 15、你怎么来实现页面设计图，你认为前端应该如何高质量完成工作? 一个满屏 品 字布局 如何设计? 首先划分成头部、body、脚部；。。。。。 实现效果图是最基本的工作，精确到2px； 与设计师，产品经理的沟通和项目的参与 做好的页面结构，页面重构和用户体验 处理hack，兼容、写出优美的代码格式 针对服务器的优化、拥抱 HTML5。 16、你能描述一下渐进增强和优雅降级之间的不同吗?渐进增强 progressive enhancement：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 优雅降级 graceful degradation：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。 区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。 “优雅降级”观点 “优雅降级”观点认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器（如 IE、Mozilla 等）的前一个版本。 在这种设计范例下，旧版的浏览器被认为仅能提供“简陋却无妨 (poor, but passable)” 的浏览体验。你可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注的焦点，因此除了修复较大的错误之外，其它的差异将被直接忽略。 “渐进增强”观点 “渐进增强”观点则认为应关注于内容本身。 内容是我们建立网站的诱因。有的网站展示它，有的则收集它，有的寻求，有的操作，还有的网站甚至会包含以上的种种，但相同点是它们全都涉及到内容。这使得“渐进增强”成为一种更为合理的设计范例。这也是它立即被 Yahoo! 所采纳并用以构建其“分级式浏览器支持 (Graded Browser Support)”策略的原因所在。 那么问题了。现在产品经理看到IE6,7,8网页效果相对高版本现代浏览器少了很多圆角，阴影（CSS3），要求兼容（使用图片背景，放弃CSS3），你会如何说服他？ 17、为什么利用多个域名来存储网站资源会更有效？CDN缓存更方便 突破浏览器并发限制 节约cookie带宽 节约主域名的连接数，优化页面响应速度 防止不必要的安全问题 18、请谈一下你对网页标准和标准制定机构重要性的理解。 （无标准答案）网页标准和标准制定机构都是为了能让web发展的更‘健康’，开发者遵循统一的标准，降低开发难度，开发成本，SEO也会更好做，也不会因为滥用代码导致各种BUG、安全问题，最终提高网站易用性。 19、请描述一下cookies，sessionStorage和localStorage的区别？ sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。 web storage和cookie的区别 Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。 除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。但是Cookie也是不可以或缺的：Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生。 20、知道css有个content属性吗？有什么作用？有什么应用？知道。css的content属性专门应用在 before/after 伪元素上，用来插入生成内容。最常见的应用是利用伪类清除浮动。 //一种常见利用伪类清除浮动的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590.clearfix:after &#123; content:&quot;.&quot;; //这里利用到了content属性 display:block; height:0; visibility:hidden; clear:both; &#125;.clearfix &#123; *zoom:1;&#125;``after伪元素通过 content 在元素的后面生成了内容为一个点的块级素，再利用clear:both清除浮动。 那么问题继续还有，知道css计数器（序列数字字符自动递增）吗？如何通过css content属性实现css计数器？答案：css计数器是通过设置counter-reset 、counter-increment 两个属性 、及 counter()/counters()一个方法配合after / before 伪类实现。21、如何在 HTML5 页面中嵌入音频?HTML 5 包含嵌入音频文件的标准方式，支持的格式包括 MP3、Wav 和 Ogg：&lt;audio controls&gt; &lt;source src=&quot;jamshed.mp3&quot; type=&quot;audio/mpeg&quot;&gt; Your browser does&apos;nt support audio embedding feature.&lt;/audio&gt;22、如何在 HTML5 页面中嵌入视频？和音频一样，HTML5 定义了嵌入视频的标准方法，支持的格式包括：MP4、WebM 和 Ogg：&lt;video width=&quot;450&quot; height=&quot;340&quot; controls&gt; &lt;source src=&quot;jamshed.mp4&quot; type=&quot;video/mp4&quot;&gt; Your browser does&apos;nt support video embedding feature.&lt;/video&gt;23、HTML5 引入什么新的表单属性？Datalist datetime output keygen date month week time number range emailurl24、CSS3新增伪类有那些？ p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 p:last-of-type 选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 p:only-of-type 选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 p:only-child 选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。 p:nth-child(2) 选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。 :enabled、:disabled 控制表单控件的禁用状态。:checked，单选框或复选框被选中。25、(写)描述一段语义的html代码吧。（HTML5中新增加的很多标签（如：&lt;article&gt;、&lt;nav&gt;、&lt;header&gt;和&lt;footer&gt;等）就是基于语义化设计原则）&lt; div id=&quot;header&quot;&gt;&lt; h1&gt;标题&lt; /h1&gt;&lt; h2&gt;专注Web前端技术&lt; /h2&gt;&lt; /div&gt;语义 HTML 具有以下特性：文字包裹在元素中，用以反映内容。例如：段落包含在 &lt;p&gt; 元素中。顺序表包含在&lt;ol&gt;元素中。从其他来源引用的大型文字块包含在&lt;blockquote&gt;元素中。HTML 元素不能用作语义用途以外的其他目的。例如：&lt;h1&gt;包含标题，但并非用于放大文本。&lt;blockquote&gt;包含大段引述，但并非用于文本缩进。空白段落元素 ( &lt;p&gt;&lt;/p&gt; ) 并非用于跳行。文本并不直接包含任何样式信息。例如：不使用 &lt;font&gt; 或 &lt;center&gt; 等格式标记。类或 ID 中不引用颜色或位置。26.cookie在浏览器和服务器间来回传递。 sessionStorage和localStorage区别sessionStorage和localStorage的存储空间更大；sessionStorage和localStorage有更多丰富易用的接口；sessionStorage和localStorage各自独立的存储空间；27、html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？* HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。* 绘画 canvas 用于媒介回放的 video 和 audio 元素 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失； sessionStorage 的数据在浏览器关闭后自动删除 语意化更好的内容元素，比如 article、footer、header、nav、section 表单控件，calendar、date、time、email、url、search 新的技术webworker, websockt, Geolocation* 移除的元素纯表现的元素：basefont，big，center，font, s，strike，tt，u；对可用性产生负面影响的元素：frame，frameset，noframes；支持HTML5新标签：* IE8/IE7/IE6支持通过document.createElement方法产生的标签， 可以利用这一特性让这些浏览器支持HTML5新标签， 浏览器支持新标签后，还需要添加标签默认的样式：* 当然最好的方式是直接使用成熟的框架、使用最多的是html5shim框架&lt;!--[if lt IE 9]&gt;&lt;script&gt; src=&quot;http://html5shim.googlecode.com/svn/trunk/html5.js&quot;&lt;/script&gt;&lt;![endif]--&gt;28、如何区分： DOCTYPE声明\新增的结构元素\功能元素29、语义化的理解？用正确的标签做正确的事情！html语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析；在没有样式CCS情况下也以一种文档格式显示，并且是容易阅读的。搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 SEO。使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。30、HTML5的离线储存？localStorage 长期存储数据，浏览器关闭后数据不丢失；sessionStorage 数据在浏览器关闭后自动删除。31、写出HTML5的文档声明方式 &lt;DOCYPE html&gt;32、HTML5和CSS3的新标签 HTML5： nav, footer, header, section, hgroup, video, time, canvas, audio...CSS3: RGBA, opacity, text-shadow, box-shadow, border-radius, border-image,border-color, transform...;33、自己对标签语义化的理解 在我看来，语义化就是比如说一个段落， 那么我们就应该用 &lt;p&gt;标签来修饰，标题就应该用 &lt;h?&gt;标签等。符合文档语义的标签。五、移动web开发1、移动端常用类库及优缺点知识面宽度，多多益善2、Zepto库和JQ区别Zepto相对jQuery更加轻量，主要用在移动端，jQuery也有对应的jQuerymobile移动端框架六、Ajax1、Ajax 是什么? 如何创建一个Ajax？Ajax并不算是一种新的技术，全称是asychronous javascript and xml，可以说是已有技术的组合，主要用来实现客户端与服务器端的异步通信效果，实现页面的局部刷新，早期的浏览器并不能原生支持ajax，可以使用隐藏帧（iframe）方式变相实现异步效果，后来的浏览器提供了对ajax的原生支持使用ajax原生方式发送请求主要通过XMLHttpRequest(标准浏览器)、ActiveXObject(IE浏览器)对象实现异步通信效果基本步骤：var xhr =null;//创建对象if(window.XMLHttpRequest)&#123; xhr = new XMLHttpRequest();&#125;else&#123; xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);&#125; xhr.open(“方式”,”地址”,”标志位”);//初始化请求 xhr.setRequestHeader(“”,””);//设置http头信息 xhr.onreadystatechange =function()&#123;&#125;//指定回调函数 xhr.send();//发送请求js框架（jQuery/EXTJS等）提供的ajax API对原生的ajax进行了封装，熟悉了基础理论，再学习别的框架就会得心应手，好多都是换汤不换药的内容2、同步和异步的区别?同步：阻塞的-张三叫李四去吃饭，李四一直忙得不停，张三一直等着，直到李四忙完两个人一块去吃饭=浏览器向服务器请求数据，服务器比较忙，浏览器一直等着（页面白屏），直到服务器返回数据，浏览器才能显示页面异步：非阻塞的-张三叫李四去吃饭，李四在忙，张三说了一声然后自己就去吃饭了，李四忙完后自己去吃=浏览器向服务器请求数据，服务器比较忙，浏览器可以自如的干原来的事情（显示页面），服务器返回数据的时候通知浏览器一声，浏览器把返回的数据再渲染到页面，局部更新3、如何解决跨域问题?理解跨域的概念：协议、域名、端口都相同才同域，否则都是跨域出于安全考虑，服务器不允许ajax跨域获取数据，但是可以跨域获取文件内容，所以基于这一点，可以动态创建script标签，使用标签的src属性访问js文件的形式获取js脚本，并且这个js脚本中的内容是函数调用，该函数调用的参数是服务器返回的数据，为了获取这里的参数数据，需要事先在页面中定义回调函数，在回调函数中处理服务器返回的数据，这就是解决跨域问题的主流解决方案4、页面编码和被请求的资源编码如果不一致如何处理？对于ajax请求传递的参数，如果是get请求方式，参数如果传递中文，在有些浏览器会乱码，不同的浏览器对参数编码的处理方式不同，所以对于get请求的参数需要使用 encodeURIComponent函数对参数进行编码处理，后台开发语言都有相应的解码api。对于post请求不需要进行编码5、简述ajax 的过程。1. 创建XMLHttpRequest对象,也就是创建一个异步调用对象2. 创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息3. 设置响应HTTP请求状态变化的函数4. 发送HTTP请求5. 获取异步调用返回的数据6. 使用JavaScript和DOM实现局部刷新6、阐述一下异步加载。1. 异步加载的方案： 动态插入 script 标签2. 通过 ajax 去获取 js 代码，然后通过 eval 执行3. script 标签上添加 defer 或者 async 属性4. 创建并插入 iframe，让它异步执行 js7、请解释一下 JavaScript 的同源策略。同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。所谓同源指的是：协议，域名，端口相同，同源策略是一种安全协议，指一段脚本只能读取来自同一来源的窗口和文档的属性。8、GET和POST的区别，何时使用POST？GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符，有的浏览器是8000个字符POST：一般用于修改服务器上的资源，对所发送的信息没有限制在以下情况中，请使用 POST 请求：1. 无法使用缓存文件（更新服务器上的文件或数据库）2. 向服务器发送大量数据（POST 没有数据量限制）3. 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠9、ajax 是什么?ajax 的交互模型?同步和异步的区别?如何解决跨域问题? 1. 通过异步模式，提升了用户体验 2. 优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用3. Ajax在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。10、 Ajax的最大的特点是什么。 Ajax可以实现异步通信效果，实现页面局部刷新，带来更好的用户体验；按需获取数据，节约带宽资源；11、ajax的缺点 1、ajax不支持浏览器back按钮。 2、安全问题 AJAX暴露了与服务器交互的细节。 3、对搜索引擎的支持比较弱。 4、破坏了程序的异常机制。12、ajax请求的时候get 和post方式的区别get一般用来进行查询操作，url地址有长度限制，请求的参数都暴露在url地址当中，如果传递中文参数，需要自己进行编码操作，安全性较低。post请求方式主要用来提交数据，没有数据长度的限制，提交的数据内容存在于http请求体中，数据不会暴漏在url地址中。13、解释jsonp的原理，以及为什么不是真正的ajax Jsonp并不是一种数据格式，而json是一种数据格式，jsonp是用来解决跨域获取数据的一种解决方案，具体是通过动态创建script标签，然后通过标签的src属性获取js文件中的js脚本，该脚本的内容是一个函数调用，参数就是服务器返回的数据，为了处理这些返回的数据，需要事先在页面定义好回调函数，本质上使用的并不是ajax技术14、什么是Ajax和JSON，它们的优缺点。Ajax是全称是asynchronous JavaScript andXML，即异步JavaScript和xml，用于在Web页面中实现异步数据交互，实现页面局部刷新。优点：可以使得页面不重载全部内容的情况下加载局部内容，降低数据传输量，避免用户不断刷新或者跳转页面，提高用户体验缺点：对搜索引擎不友好；要实现ajax下的前后退功能成本较大；可能造成请求数的增加跨域问题限制；JSON是一种轻量级的数据交换格式，ECMA的一个子集优点：轻量级、易于人的阅读和编写，便于机器（JavaScript）解析，支持复合数据类型（数组、对象、字符串、数字）15、http常见的状态码有那些？分别代表是什么意思？200 - 请求成功301 - 资源（网页等）被永久转移到其它URL404 - 请求的资源（网页等）不存在500 - 内部服务器错误16、一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？分为4个步骤：1. 当发送一个 URL 请求时，不管这个 URL 是 Web 页面的 URL 还是 Web 页面上每个资源的 URL，浏览器都会开启一个线程来处理这个请求，同时在远程 DNS 服务器上启动一个 DNS 查询。这能使浏览器获得请求对应的 IP 地址。2. 浏览器与远程 Web 服务器通过 TCP 三次握手协商来建立一个 TCP/IP 连接。该握手包括一个同步报文，一个同步-应答报文和一个应答报文，这三个报文在 浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。3. 一旦 TCP/IP 连接建立，浏览器会通过该连接向远程服务器发送 HTTP 的 GET 请求。远程服务器找到资源并使用 HTTP 响应返回该资源，值为 200 的 HTTP 响应状态表示一个正确的响应。4. 此时，Web 服务器提供资源服务，客户端开始下载资源。17、ajax请求的时候get 和post方式的区别get一般用来进行查询操作，url地址有长度限制，请求的参数都暴露在url地址当中，如果传递中文参数，需要自己进行编码操作，安全性较低。post请求方式主要用来提交数据，没有数据长度的限制，提交的数据内容存在于http请求体中，数据不会暴漏在url地址中。18、ajax请求时，如何解释json数据使用eval()或者JSON.parse() 鉴于安全性考虑，推荐使用JSON.parse()更靠谱，对数据的安全性更好。19、.javascript的本地对象，内置对象和宿主对象本地对象为独立于宿主环境的ECMAScript提供的对象，包括ArrayObjectRegExp等可以new实例化的对象内置对象为Gload，Math 等不可以实例化的(他们也是本地对象，内置对象是本地对象的一个子集)宿主对象为所有的非本地对象，所有的BOM和DOM对象都是宿主对象，如浏览器自带的document,window 等对象20、为什么利用多个域名来存储网站资源会更有效？确保用户在不同地区能用最快的速度打开网站，其中某个域名崩溃用户也能通过其他郁闷访问网站，并且不同的资源放到不同的服务器上有利于减轻单台服务器的压力。21、请说出三种减低页面加载时间的方法1、压缩css、js文件2、合并js、css文件，减少http请求3、外部js、css文件放在最底下4、减少dom操作，尽可能用变量替代不必要的dom操作22、HTTP状态码都有那些。200 OK //客户端请求成功400 Bad Request //客户端请求有语法错误，不能被服务器所理解403 Forbidden //服务器收到请求，但是拒绝提供服务404 Not Found //请求资源不存在，输入了错误的URL500 Internal Server Error //服务器发生不可预期的错误503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常七、JS高级1、JQuery一个对象可以同时绑定多个事件，这是如何实现的？jQuery可以给一个对象同时绑定多个事件，低层实现方式是使用addEventListner或attachEvent兼容不同的浏览器实现事件的绑定，这样可以给同一个对象注册多个事件。2、知道什么是webkit么? 知道怎么用浏览器的各种工具来调试和debug代码么?Webkit是浏览器引擎，包括html渲染和js解析功能，手机浏览器的主流内核，与之相对应的引擎有Gecko（Mozilla Firefox 等使用）和Trident（也称MSHTML，IE 使用）。对于浏览器的调试工具要熟练使用，主要是页面结构分析，后台请求信息查看，js调试工具使用，熟练使用这些工具可以快速提高解决问题的效率3、如何测试前端代码? 知道BDD, TDD, Unit Test么? 知道怎么测试你的前端工程么(mocha, sinon, jasmin, qUnit..)?了解BDD行为驱动开发与TDD测试驱动开发已经单元测试相关概念，4、 前端templating(Mustache, underscore, handlebars)是干嘛的, 怎么用?Web 模板引擎是为了使用户界面与业务数据（内容）分离而产生的，Mustache 是一个 logic-less （轻逻辑）模板解析引擎，它的优势在于可以应用在 Javascript、PHP、Python、Perl 等多种编程语言中。Underscore封装了常用的JavaScript对象操作方法，用于提高开发效率。Handlebars 是 JavaScript 一个语义模板库，通过对view和data的分离来快速构建Web模板。5、简述一下 Handlebars 的基本用法？没有用过的话说出它是干什么的即可6、简述一下 Handlerbars 的对模板的基本处理流程， 如何编译的？如何缓存的？学习技术不仅要会用，还有熟悉它的实现机制，这样在开发中遇到问题时才能更好的解决7、用js实现千位分隔符?原生js的熟练度，实践经验，实现思路8、检测浏览器版本版本有哪些方式？IE与标准浏览器判断，IE不同版本的判断，userAgent var ie = /*@cc_on !@*/false;9、我们给一个dom同时绑定两个点击事件，一个用捕获，一个用冒泡，你来说下会执行几次事件，然后会先执行冒泡还是捕获对两种事件模型的理解10、实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制考察点1：对于基本数据类型和引用数据类型在内存中存放的是值还是指针这一区别是否清楚考察点2：是否知道如何判断一个变量是什么类型的考察点3：递归算法的设计// 方法一：Object.prototype.clone = function()&#123; var o = this.constructor === Array ? [] : &#123;&#125;; for(var e in this)&#123; o[e] = typeof this[e] === &quot;object&quot; ? this[e].clone() : this[e]; &#125; return o;&#125;//方法二： /** * 克隆一个对象 * @param Obj * @returns */ function clone(Obj) &#123; var buf; if (Obj instanceof Array) &#123; buf = [];//创建一个空的数组 var i = Obj.length; while (i--) &#123; buf[i] = clone(Obj[i]); &#125; return buf; &#125;else if (Obj instanceof Object)&#123; buf = &#123;&#125;;//创建一个空对象 for (var k in Obj) &#123; //为这个对象添加新的属性 buf[k] = clone(Obj[k]); &#125; return buf; &#125;else&#123; //普通变量直接赋值 return Obj; &#125; &#125;11、如何消除一个数组里面重复的元素？var arr=[1,2,3,3,4,4,5,5,6,1,9,3,25,4]; function deRepeat()&#123; var newArr=[]; var obj=&#123;&#125;; var index=0; var l=arr.length; for(var i=0;i&lt;l;i++)&#123; if(obj[arr[i]]==undefined) &#123; obj[arr[i]]=1; newArr[index++]=arr[i]; &#125; else if(obj[arr[i]]==1) continue; &#125; return newArr; &#125; var newArr2=deRepeat(arr); alert(newArr2); //输出1,2,3,4,5,6,9,2512、小贤是一条可爱的小狗(Dog)，它的叫声很好听(wow)，每次看到主人的时候就会乖乖叫一声(yelp)。从这段描述可以得到以下对象：function Dog() &#123; this.wow = function() &#123; alert(’Wow’); &#125; this.yelp = function() &#123; this.wow(); &#125;&#125;小芒和小贤一样，原来也是一条可爱的小狗，可是突然有一天疯了(MadDog)，一看到人就会每隔半秒叫一声(wow)地不停叫唤(yelp)。请根据描述，按示例的形式用代码来实。（继承，原型，setInterval） function MadDog() { this.yelp = function() { var self = this; setInterval(function() { self.wow(); }, 500); } } MadDog.prototype = new Dog(); //for test var dog = new Dog(); dog.yelp(); var madDog = new MadDog(); madDog.yelp();12345678910111213141513、下面这个ul，如何点击每一列的时候alert其index?（闭包）&lt;ul id=”test”&gt;&lt;li&gt;这是第一条&lt;/li&gt;&lt;li&gt;这是第二条&lt;/li&gt;&lt;li&gt;这是第三条&lt;/li&gt;&lt;/ul&gt;// 方法一： var lis=document.getElementById(‘2223’).getElementsByTagName(‘li’); for(var i=0;i&lt;3;i++) { lis[i].index=i; lis[i].onclick=function(){ alert(this.index); }; }123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305//方法二：var lis=document.getElementById(&apos;2223&apos;).getElementsByTagName(&apos;li&apos;);for(var i=0;i&lt;3;i++)&#123; lis[i].index=i; lis[i].onclick=(function(a)&#123; return function() &#123; alert(a); &#125; &#125;)(i);&#125;14、编写一个JavaScript函数，输入指定类型的选择器(仅需支持id，class，tagName三种简单CSS选择器，无需兼容组合选择器)可以返回匹配的DOM节点，需考虑浏览器兼容性和性能。/*** @param selector &#123;String&#125; 传入的CSS选择器。* @return &#123;Array&#125;*/var query = function(selector) &#123;var reg = /^(#)?(\.)?(\w+)$/img;var regResult = reg.exec(selector);var result = [];//如果是id选择器if(regResult[1]) &#123;if(regResult[3]) &#123;if(typeof document.querySelector === &quot;function&quot;) &#123;result.push(document.querySelector(regResult[3])); &#125;else &#123; result.push(document.getElementById(regResult[3])); &#125; &#125; &#125; //如果是class选择器 else if(regResult[2]) &#123; if(regResult[3]) &#123; if(typeof document.getElementsByClassName === &apos;function&apos;) &#123; var doms = document.getElementsByClassName(regResult[3]); if(doms) &#123; result = converToArray(doms); &#125; &#125; //如果不支持getElementsByClassName函数 else &#123; var allDoms = document.getElementsByTagName(&quot;*&quot;) ; for(var i = 0, len = allDoms.length; i &lt; len; i++) &#123; if(allDoms[i].className.search(new RegExp(regResult[2])) &gt; -1) &#123; result.push(allDoms[i]); &#125; &#125; &#125; &#125;&#125; //如果是标签选择器 else if(regResult[3]) &#123; var doms = document.getElementsByTagName(regResult[3].toLowerCase()); if(doms) &#123; result = converToArray(doms); &#125; &#125; return result; &#125; function converToArray(nodes)&#123; var array = null; try&#123; array = Array.prototype.slice.call(nodes,0);//针对非IE浏览器 &#125;catch(ex)&#123; array = new Array(); for( var i = 0 ,len = nodes.length; i &lt; len ; i++ ) &#123; array.push(nodes[i]) &#125; &#125; return array;&#125;15、请评价以下代码并给出改进意见。if(window.addEventListener)&#123; var addListener = function(el,type,listener,useCapture)&#123; el.addEventListener(type,listener,useCapture); &#125;;&#125;else if(document.all)&#123; addListener = function(el,type,listener)&#123; el.attachEvent(&quot;on&quot;+type,function()&#123; listener.apply(el); &#125;); &#125;&#125;不应该在if和else语句中声明addListener函数，应该先声明；不需要使用window.addEventListener或document.all来进行检测浏览器，应该使用能力检测；由于attachEvent在IE中有this指向问题，所以调用它时需要处理一下改进如下：function addEvent(elem, type, handler)&#123; if(elem.addEventListener)&#123; elem.addEventListener(type, handler, false); &#125;else if(elem.attachEvent)&#123; elem[&apos;temp&apos; + type + handler] = handler; elem[type + handler] = function()&#123; elem[&apos;temp&apos; + type + handler].apply(elem); &#125;; elem.attachEvent(&apos;on&apos; + type, elem[type + handler]); &#125;else&#123; elem[&apos;on&apos; + type] = handler; &#125;&#125;16、给String对象添加一个方法，传入一个string类型的参数，然后将string的每个字符间价格空格返回，例如：addSpace(“hello world”) // -&gt; ‘h e l l o w o r l d’String.prototype.spacify = function()&#123; return this.split(&apos;&apos;).join(&apos; &apos;); &#125;;接着上述问题答案提问，1）直接在对象的原型上添加方法是否安全？尤其是在Object对象上。(这个我没能答出？希望知道的说一下。) 2）函数声明与函数表达式的区别？答案：在js中，解析器在向执行环境中加载数据时，对函数声明和函数表达式并非是一视同仁的，解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问），至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解析执行。17、定义一个log方法，让它可以代理console.log的方法。可行的方法一：function log(msg) &#123; console.log(msg);&#125;log(&quot;hello world!&quot;) // hello world!如果要传入多个参数呢？显然上面的方法不能满足要求，所以更好的方法是：function log()&#123; console.log.apply(console, arguments);&#125;;到此，追问apply和call方法的异同。对于apply和call两者在作用上是相同的，即是调用一个对象的一个方法，以另一个对象替换当前对象。将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。但两者在参数上有区别的。对于第一个参数意义都一样，但对第二个参数： apply传入的是一个参数数组，也就是将多个参数组合成为一个数组传入，而call则作为call的参数传入（从第二个参数开始）。 如 func.call(func1,var1,var2,var3)对应的apply写法为：func.apply(func1,[var1,var2,var3]) 。18、在Javascript中什么是伪数组？如何将伪数组转化为标准数组？伪数组（类数组）：无法直接调用数组方法或期望length属性有什么特殊的行为，但仍可以对真正数组遍历方法来遍历它们。典型的是函数的argument参数，还有像调用getElementsByTagName,document.childNodes之类的,它们都返回NodeList对象都属于伪数组。可以使用Array.prototype.slice.call(fakeArray)将数组转化为真正的Array对象。假设接第八题题干，我们要给每个log方法添加一个”(app)”前缀，比如’hello world!’ -&gt;’(app)hello world!’。方法如下：function log()&#123; var args = Array.prototype.slice.call(arguments); //为了使用unshift数组方法，将argument转化为真正的数组 args.unshift(&apos;(app)&apos;); console.log.apply(console, args); &#125;;19、对作用域上下文和this的理解，看下列代码：var User = &#123; count: 1, getCount: function() &#123; return this.count; &#125;&#125;;console.log(User.getCount()); // what?var func = User.getCount;console.log(func()); // what?问两处console输出什么？为什么？答案是1和undefined。func是在winodw的上下文中被执行的，所以会访问不到count属性。继续追问，那么如何确保Uesr总是能访问到func的上下文，即正确返回1。正确的方法是使用Function.prototype.bind。兼容各个浏览器完整代码如下：Function.prototype.bind = Function.prototype.bind || function(context)&#123; var self = this; return function()&#123; return self.apply(context, arguments); &#125;;&#125;var func = User.getCount.bind(User);console.log(func());20、原生JS的window.onload与Jquery的$(document).ready(function()&#123;&#125;)有什么不同？如何用原生JS实现Jq的ready方法？window.onload()方法是必须等到页面内包括图片的所有元素加载完毕后才能执行。$(document).ready()是DOM结构绘制完毕后就执行，不必等到加载完毕。/* * 传递函数给whenReady() * 当文档解析完毕且为操作准备就绪时，函数作为document的方法调用 var whenReady = (function() { //这个函数返回whenReady()函数 var funcs = []; //当获得事件时，要运行的函数 var ready = false; //当触发事件处理程序时,切换为true //当文档就绪时,调用事件处理程序 function handler(e) { if(ready) return; //确保事件处理程序只完整运行一次 //如果发生onreadystatechange事件，但其状态不是complete的话,那么文档尚未准备好 if(e.type === &apos;onreadystatechange&apos; &amp;&amp; document.readyState !== &apos;complete&apos;) { return; } //运行所有注册函数 //注意每次都要计算funcs.length //以防这些函数的调用可能会导致注册更多的函数 for(var i=0; i&lt;funcs.length; i++) { funcs[i].call(document); } //事件处理函数完整执行,切换ready状态, 并移除所有函数 ready = true; funcs = null; } //为接收到的任何事件注册处理程序 if(document.addEventListener) { document.addEventListener(&apos;DOMContentLoaded&apos;, handler, false); document.addEventListener(&apos;readystatechange&apos;, handler, false); //IE9+ window.addEventListener(&apos;load&apos;, handler, false); }else if(document.attachEvent) { document.attachEvent(&apos;onreadystatechange&apos;, handler); window.attachEvent(&apos;onload&apos;, handler); } //返回whenReady()函数 return function whenReady(fn) { if(ready) { fn.call(document); } else { funcs.push(fn); } } })();1如果上述代码十分难懂，下面这个简化版： function ready(fn){ if(document.addEventListener) {//标准浏览器 document.addEventListener(&apos;DOMContentLoaded&apos;, function() { //注销事件, 避免反复触发 document.removeEventListener(&apos;DOMContentLoaded&apos;,arguments.callee, false); fn();//执行函数 }, false); }else if(document.attachEvent) {//IE document.attachEvent(&apos;onreadystatechange&apos;, function() { if(document.readyState == &apos;complete&apos;) { document.detachEvent(&apos;onreadystatechange&apos;, arguments.callee); fn();//函数执行 } }); } };12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510621、（设计题）想实现一个对页面某个节点的拖曳？如何做？（使用原生JS）回答出概念即可，下面是几个要点1. 给需要拖拽的节点绑定mousedown, mousemove, mouseup事件2. mousedown事件触发后，开始拖拽3. mousemove时，需要通过event.clientX和clientY获取拖拽位置，并实时更新位置4. mouseup时，拖拽结束5. 需要注意浏览器边界的情况22、请实现如下功能 function setcookie(name,value,days)&#123; //给cookie增加一个时间变量 var exp = new Date(); exp.setTime(exp.getTime() + days*24*60*60*1000); //设置过期时间为days天 document.cookie = name + &quot;=&quot;+ escape (value) + &quot;;expires=&quot; + exp.toGMTString(); &#125; function getCookie(name)&#123; var result = &quot;&quot;; var myCookie = &quot;&quot;+document.cookie+&quot;;&quot;; var searchName = &quot;+name+&quot;=&quot;; var startOfCookie = myCookie.indexOf(searchName); var endOfCookie; if(satrtOfCookie != -1)&#123; startOfcookie += searchName.length; endOfCookie = myCookie.indexOf(&quot;;&quot;,startOfCookie); result = (myCookie.substring(startOfCookie,endOfCookie)); &#125; return result; &#125; (function()&#123; var oTips = document.getElementById(&apos;tips&apos;);//假设tips的id为tips var page = &#123; check: function()&#123;//检查tips的cookie是否存在并且允许显示 var tips = getCookie(&apos;tips&apos;); if(!tips || tips == &apos;show&apos;) return true;//tips的cookie不存在 if(tips == &quot;never_show_again&quot;) return false; &#125;, hideTip: function(bNever)&#123; if(bNever) setcookie(&apos;tips&apos;, &apos;never_show_again&apos;, 365); oTips.style.display = &quot;none&quot;;//隐藏 &#125;, showTip: function()&#123; oTips.style.display = &quot;inline&quot;;//显示，假设tips为行级元素 &#125;, init: function()&#123; var _this = this; if(this.check())&#123; _this.showTip(); setcookie(&apos;tips&apos;, &apos;show&apos;, 1); &#125; oTips.onclick = function()&#123; _this.hideTip(true); &#125;; &#125; &#125;; page.init(); &#125;)(); 23、说出以下函数的作用是？空白区域应该填写什么？123456789101112131415161718192021222324252627282930313233343536373839//define(function(window)&#123; function fn(str)&#123; this.str=str; &#125; fn.prototype.format = function()&#123; var arg = ______; return this.str.replace(_____,function(a,b)&#123; return arg[b]||&quot;&quot;; &#125;); &#125; window.fn = fn;&#125;)(window);//use(function()&#123; var t = new fn(&apos;&lt;p&gt;&lt;a href=&quot;&#123;0&#125;&quot;&gt;&#123;1&#125;&lt;/a&gt;&lt;span&gt;&#123;2&#125;&lt;/span&gt;&lt;/p&gt;&apos;); console.log(t.format(&apos;http://www.alibaba.com&apos;,&apos;Alibaba&apos;,&apos;Welcome&apos;));&#125;)(); 答案：访函数的作用是使用format函数将函数的参数替换掉{0}这样的内容，返回一个格式化后的结果： 第一个空是：arguments 第二个空是：/{(\d+)}/ig 24、Javascript作用链域?理解变量和函数的访问范围和生命周期，全局作用域与局部作用域的区别，JavaScript中没有块作用域，函数的嵌套形成不同层次的作用域，嵌套的层次形成链式形式，通过作用域链查找属性的规则需要深入理解。 25、谈谈This对象的理解。理解不同形式的函数调用方式下的this指向，理解事件函数、定时函数中的this指向，函数的调用形式决定了this的指向。 26、eval是做什么的？它的功能是把对应的字符串解析成JS代码并运行；应该避免使用eval，不安全，非常耗性能（2个步骤，一次解析成js语句，一次执行） 27、关于事件，IE与火狐的事件机制有什么区别？ 如何阻止冒泡？[1].在IE中,事件对象是作为一个全局变量来保存和维护的.所有的浏览器事件,不管是用户触发的，还是其他事件,都会更新window.event对象.所以在代码中，只要调用window.event就可以获取事件对象， 再event.srcElement就可以取得触发事件的元素进行进一步处理. [2].在FireFox中，事件对象却不是全局对象，一般情况下，是现场发生，现场使用，FireFox把事件对象自动传给事件处理程序. 关于事件的兼容性处理要熟练掌握，事件对象具体哪些属性存在兼容性问题，IE与标准事件模型事件冒泡与事件捕获的支持要理解 28、什么是闭包（closure），为什么要用它？简单的理解是函数的嵌套形成闭包，闭包包括函数本身已经它的外部作用域 使用闭包可以形成独立的空间，延长变量的生命周期，报存中间状态值 29、javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？意思是使用严格模式，使用严格模式，一些不规范的语法将不再支持 30、如何判断一个对象是否属于某个类？Instanceof constructor 31、new操作符具体干了什么呢?1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。 2、属性和方法被加入到 this 引用的对象中。 3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。 32、用原生JavaScript的实现过什么功能吗？主要考察原生js的实践经验 33、Javascript中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？HasOwnProperty 34、对JSON的了解？轻量级数据交互格式，可以形成复杂的嵌套格式，解析非常方便 35、js延迟加载的方式有哪些？ `方案一：标签的async=”async”属性（详细参见：script标签的async属性） 方案二：&lt;script&gt;标签的defer=&quot;defer&quot;属性 方案三：动态创建&lt;script&gt;标签 方案四：AJAX eval（使用AJAX得到脚本内容，然后通过eval_r(xmlhttp.responseText)来运行脚本） 方案五：iframe方式` 36、模块化开发怎么做？理解模块化开发模式：浏览器端requirejs，seajs；服务器端nodejs；ES6模块化；fis、webpack等前端整体模块化解决方案；grunt、gulp等前端工作流的使用 37、AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？理解这两种规范的差异，主要通过requirejs与seajs的对比，理解模块的定义与引用方式的差异以及这两种规范的设计原则 38、requireJS的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何 缓存的？）核心是js的加载模块，通过正则匹配模块以及模块的依赖关系，保证文件加载的先后顺序，根据文件的路径对加载过的文件做了缓存 39、让你自己设计实现一个requireJS，你会怎么做？核心是实现js的加载模块，维护js的依赖关系，控制好文件加载的先后顺序 40、谈一谈你对ECMAScript6的了解？ES6新的语法糖，类，模块化等新特性 41、ECMAScript6 怎么写class么，为什么会出现class这种东西?1234567891011121314151617class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return &apos;(&apos;+this.x+&apos;, &apos;+this.y+&apos;)&apos;; &#125;&#125; 42、异步加载的方式有哪些？方案一：标签的async=”async”属性（详细参见：script标签的async属性） 方案二：标签的defer=”defer”属性 方案三：动态创建标签 方案四：AJAX eval（使用AJAX得到脚本内容，然后通过eval_r(xmlhttp.responseText)来运行脚本） 方案五：iframe方式 43、documen.write和 innerHTML的区别?document.write是重写整个document, 写入内容是字符串的html innerHTML是HTMLElement的属性，是一个元素的内部html内容 44、DOM操作——怎样添加、移除、移动、复制、创建和查找节点?（1）创建新节点 createDocumentFragment() //创建一个DOM片段 createElement_x() //创建一个具体的元素 createTextNode() //创建一个文本节点 （2）添加、移除、替换、插入 appendChild() removeChild() replaceChild() insertBefore() （3）查找 getElementsByTagName() //通过标签名称 getElementsByName() //通过元素的Name属性的值 getElementById() //通过元素Id，唯一性 45、call() 和 .apply() 的含义和区别？apply的参数是数组形式，call的参数是单个的值，除此之外在使用上没有差别，重点理解这两个函数调用的this改变 46、数组和对象有哪些原生方法，列举一下？123456789101112131415161718192021222324252627282930313233343536373839Array.concat( ) 连接数组Array.join( ) 将数组元素连接起来以构建一个字符串Array.length 数组的大小Array.pop( ) 删除并返回数组的最后一个元素Array.push( ) 给数组添加元素Array.reverse( ) 颠倒数组中元素的顺序Array.shift( ) 将元素移出数组Array.slice( ) 返回数组的一部分Array.sort( ) 对数组元素进行排序Array.splice( ) 插入、删除或替换数组的元素Array.toLocaleString( ) 把数组转换成局部字符串Array.toString( ) 将数组转换成一个字符串Array.unshift( ) 在数组头部插入一个元素Object.hasOwnProperty( ) 检查属性是否被继承Object.isPrototypeOf( ) 一个对象是否是另一个对象的原型Object.propertyIsEnumerable( ) 是否可以通过for/in循环看到属性Object.toLocaleString( ) 返回对象的本地字符串表示Object.toString( ) 定义一个对象的字符串表示Object.valueOf( ) 指定对象的原始值 47、JS 怎么实现一个类。怎么实例化这个类严格来讲js中并没有类的概念，不过js中的函数可以作为构造函数来使用，通过new来实例化，其实函数本身也是一个对象。 48、JavaScript中的作用域与变量声明提升？理解JavaScript的预解析机制，js的运行主要分两个阶段：js的预解析和运行，预解析阶段所有的变量声明和函数定义都会提前，但是变量的赋值不会提前 49、如何编写高性能的Javascript？使用 DocumentFragment 优化多次 append 通过模板元素 clone ，替代 createElement 使用一次 innerHTML 赋值代替构建 dom 元素 使用 firstChild 和 nextSibling 代替 childNodes 遍历 dom 元素 使用 Array 做为 StringBuffer ，代替字符串拼接的操作 将循环控制量保存到局部变量 顺序无关的遍历时，用 while 替代 for 将条件分支，按可能性顺序从高到低排列 在同一条件子的多（ &gt;2 ）条件分支时，使用 switch 优于 if 使用三目运算符替代条件分支 需要不断执行的时候，优先考虑使用 setInterval 50、那些操作会造成内存泄漏？闭包，循环 51、javascript对象的几种创建方式？ 1. 工厂模式 2. 构造函数模式 3. 原型模式 4. 混合构造函数和原型模式 5. 动态原型模式 6. 寄生构造函数模式 7. 稳妥构造函数模式 52、javascript继承的 6 种方法？ 1. 原型链继承 2. 借用构造函数继承 3. 组合继承(原型+借用构造) 4. 原型式继承 5. 寄生式继承 6. 寄生组合式继承 53、eval是做什么的？ 1. 它的功能是把对应的字符串解析成JS代码并运行 2. 应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行） 54、JavaScript 原型，原型链 ? 有什么特点？ 1. 原型对象也是普通的对象，是对象一个自带隐式的 __proto__ 属性，原型也有可能有自己的原型，如果一个原型对象的原型不为 null 的话，我们就称之为原型链 2. 原型链是由一些用来继承和共享属性的对象组成的（有限的）对象链 55、事件、IE与火狐的事件机制有什么区别？ 如何阻止冒泡？ 1. 我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为 2. 事件处理机制：IE是事件冒泡、firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件 3. ev.stopPropagation(); 注意旧ie的方法：ev.cancelBubble = true; 56、简述一下Sass、Less，且说明区别？他们是动态的样式语言，是CSS预处理器,CSS上的一种抽象层。他们是一种特殊的语法/语言而编译成CSS。 变量符不一样，less是@，而Sass是$; Sass支持条件语句，可以使用if{}else{},for{}循环等等。而Less不支持; Sass是基于Ruby的，是在服务端处理的，而Less是需要引入less.js来处理Less代码输出Css到浏览器 57、关于javascript中apply()和call()方法的区别？相同点:两个方法产生的作用是完全一样的 不同点:方法传递的参数不同 Object.call(this,obj1,obj2,obj3) Object.apply(this,arguments) apply()接收两个参数，一个是函数运行的作用域(this)，另一个是参数数组。 call()方法第一个参数与apply()方法相同，但传递给函数的参数必须列举出来。 58、简述一下JS中的闭包？闭包用的多的两个作用：读取函数内部的变量值；让这些变量值始终保存着(在内存中)。 同时需要注意的是：闭包慎用，不滥用，不乱用，由于函数内部的变量都被保存在内存中，会导致内存消耗大。 59、说说你对this的理解？在JavaScript中，this通常指向的是我们正在执行的函数本身，或者是，指向该函数所属的对象。 全局的this → 指向的是Window 函数中的this → 指向的是函数所在的对象 对象中的this → 指向其本身 60、分别阐述split(),slice(),splice(),join()？join()用于把数组中的所有元素拼接起来放入一个字符串。所带的参数为分割字符串的分隔符，默认是以逗号分开。归属于Array split()即把字符串分离开，以数组方式存储。归属于Stringstring slice() 方法可从已有的数组中返回选定的元素。该方法并不会修改数组，而是返回一个子数组。如果想删除数组中的一段元素，应该使用方法 Array.splice() splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。返回的是含有被删除的元素的数组。 61、事件委托是什么？让利用事件冒泡的原理，让自己的所触发的事件，让他的父元素代替执行！ 62、如何阻止事件冒泡和默认事件？阻止浏览器的默认行为 window.event?window.event.returnValue=false:e.preventDefault(); 停止事件冒泡 window.event?window.event.cancelBubble=true:e.stopPropagation(); 原生JavaScript中，return false;只阻止默认行为，不阻止冒泡，jQuery中的return false;既阻止默认行为，又阻止冒泡 63、添加 删除 替换 插入到某个接点的方法？obj.appendChidl() obj.removeChild() obj.replaceChild() obj.innersetBefore() 64、你用过require.js吗？它有什么特性？（1）实现js文件的异步加载，避免网页失去响应； （2）管理模块之间的依赖性，便于代码的编写和维护。 65、谈一下JS中的递归函数，并且用递归简单实现阶乘？递归即是程序在执行过程中不断调用自身的编程技巧，当然也必须要有一个明确的结束条件，不然就会陷入死循环。 66、请用正则表达式写一个简单的邮箱验证。/^[a-zA-Z0-9-]+@[a-zA-Z0-9-]+(.[a-zA-Z0-9_-]+)+$/; 67、简述一下你对web性能优化的方案？ 1、尽量减少 HTTP 请求 2、使用浏览器缓存 3、使用压缩组件 4、图片、JS的预载入 5、将脚本放在底部 6、将样式文件放在页面顶部 7、使用外部的JS和CSS 8、精简代码 68、在JS中有哪些会被隐式转换为falseUndefined、null、关键字false、NaN、零、空字符串 69、定时器setInterval有一个有名函数fn1，setInterval（fn1,500）与setInterval（fn1(),500）有什么区别？第一个是重复执行每500毫秒执行一次，后面一个只执行一次。 70、外部JS文件出现中文字符，会出现什么问题，怎么解决？会出现乱码，加charset=”GB2312”; 71、谈谈浏览器的内核，并且说一下什么是内核？Trident ([‘traɪd(ə)nt])–IE，Gecko ([‘gekəʊ])–Firefox, Presto ([‘prestəʊ])–opera,webkit—谷歌和Safari 浏览器内核又可以分成两部分：渲染引擎和 JS 引擎。它负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。JS 引擎则是解析 Javascript 语言，执行 javascript 语言来实现网页的动态效果。 72、JavaScript原型，原型链 ? 有什么特点？ 原型对象也是普通的对象，是对象一个自带隐式的 __proto__ 属性，原型也有可能有自己的原型，如果一个原型对象的原型不为null的话，我们就称之为原型链。 原型链是由一些用来继承和共享属性的对象组成的（有限的）对象链。 JavaScript的数据对象有那些属性值？ writable：这个属性的值是否可以改。 configurable：这个属性的配置是否可以删除，修改。 enumerable：这个属性是否能在for…in循环中遍历出来或在Object.keys中列举出来。 value：属性值。 当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性， 如果没有的话，就会查找他的Prototype对象是否有这个属性。1234567891011121314151617181920212223function clone(proto) &#123; function Dummy() &#123; &#125; Dummy.prototype = proto; Dummy.prototype.constructor = Dummy; return new Dummy(); //等价于Object.create(Person);&#125; function object(old) &#123; function F() &#123;&#125;; F.prototype = old; return new F(); &#125; var newObj = object(oldObject); 73、写一个通用的事件侦听器函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153// event(事件)工具集，markyun.Event = &#123; // 页面加载完成后 readyEvent : function(fn) &#123; if (fn==null) &#123; fn=document; &#125; var oldonload = window.onload; if (typeof window.onload != &apos;function&apos;) &#123; window.onload = fn; &#125; else &#123; window.onload = function() &#123; oldonload(); fn(); &#125;; &#125; &#125;, // 视能力分别使用dom0||dom2||IE方式 来绑定事件 // 参数： 操作的元素,事件名称 ,事件处理程序 addEvent : function(element, type, handler) &#123; if (element.addEventListener) &#123; //事件类型、需要执行的函数、是否捕捉 element.addEventListener(type, handler, false); &#125; else if (element.attachEvent) &#123; element.attachEvent(&apos;on&apos; + type, function() &#123; handler.call(element); &#125;); &#125; else &#123; element[&apos;on&apos; + type] = handler; &#125; &#125;, // 移除事件 removeEvent : function(element, type, handler) &#123; if (element.removeEnentListener) &#123; element.removeEnentListener(type, handler, false); &#125; else if (element.datachEvent) &#123; element.detachEvent(&apos;on&apos; + type, handler); &#125; else &#123; element[&apos;on&apos; + type] = null; &#125; &#125;, // 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获) stopPropagation : function(ev) &#123; if (ev.stopPropagation) &#123; ev.stopPropagation(); &#125; else &#123; ev.cancelBubble = true; &#125; &#125;, // 取消事件的默认行为 preventDefault : function(event) &#123; if (event.preventDefault) &#123; event.preventDefault(); &#125; else &#123; event.returnValue = false; &#125; &#125;, // 获取事件目标 getTarget : function(event) &#123; return event.target || event.srcElement; &#125;, // 获取event对象的引用，取到事件的所有信息，确保随时能使用event； getEvent : function(e) &#123; var ev = e || window.event; if (!ev) &#123; var c = this.getEvent.caller; while (c) &#123; ev = c.arguments[0]; if (ev &amp;&amp; Event == ev.constructor) &#123; break; &#125; c = c.caller; &#125; &#125; return ev; &#125;&#125;; 74、事件、IE与火狐的事件机制有什么区别？ 如何阻止冒泡？ 1. 我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。 2. 事件处理机制：IE是事件冒泡、火狐是 事件捕获； 3. ev.stopPropagation(); 75、什么是闭包（closure），为什么要用？执行say667()后,say667()闭包内部变量会存在,而闭包内部函数的内部变量不会存在.使得Javascript的垃圾回收机制GC不会收回say667()所占用的资源，因为say667()的内部函数的执行需要依赖say667()中的变量。这是对闭包作用的非常直白的描述. function say667() { // Local variable that ends up within closure var num = 666; var sayAlert = function() { alert(num); } num++; return sayAlert; } var sayAlert = say667(); sayAlert()//执行结果应该弹出的667 76、如何判断一个对象是否属于某个类？使用instanceof （待完善） if(a instanceof Person){ alert(&apos;yes&apos;); } 77、new操作符具体干了什么呢? 1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。 2、属性和方法被加入到 this 引用的对象中。 3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。12345var obj = &#123;&#125;;obj.__proto__ = Base.prototype;Base.call(obj); 78、JSON 的了解JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小 {‘age’:’12’, ‘name’:’back’} 79、js延迟加载的方式有哪些defer和async、动态创建DOM方式（用得最多）、按需异步载入js 80、模块化怎么做？立即执行函数,不暴露私有成员12345678910111213141516171819202122232425var module1 = (function()&#123; var _count = 0; var m1 = function()&#123; //... &#125;; var m2 = function()&#123; //... &#125;; return &#123; m1 : m1, m2 : m2 &#125;; &#125;)(); 81、异步加载的方式 (1) defer，只支持IE (2) async： (3) 创建script，插入到DOM中，加载完毕后callBack documen.write和 innerHTML的区别 document.write只能重绘整个页面 innerHTML可以重绘页面的一部分 82、告诉我答案是多少？1234567(function(x)&#123; delete x; alert(x);&#125;)(1+5); 函数参数无法delete删除，delete只能删除通过for in访问的属性。 当然，删除失败也不会报错，所以代码运行会弹出“1”。 83、JS中的call()和apply()方法的区别？例子中用 add 来替换 sub，add.call(sub,3,1) == add(3,1) ，所以运行结果为：alert(4); 注意：js 中的函数其实是对象，函数名是对 Function 对象的引用。12345678910111213function add(a,b)&#123; alert(a+b);&#125;function sub(a,b)&#123; alert(a-b);&#125;add.call(sub,3,1); 84、Jquery与jQuery UI 有啥区别？ jQuery是一个js库，主要提供的功能是选择器，属性修改和事件绑定等等。 jQuery UI则是在jQuery的基础上，利用jQuery的扩展性，设计的插件。 提供了一些常用的界面元素，诸如对话框、拖动行为、改变大小行为等等 85、jquery 中如何将数组转化为json字符串，然后再转化回来？jQuery中没有提供这个功能，所以你需要先编写两个jQuery的扩展：1234567891011$.fn.stringifyArray = function(array) &#123; return JSON.stringify(array)&#125;$.fn.parseArray = function(array) &#123; return JSON.parse(array)&#125; 然后调用： 1$(&quot;&quot;).stringifyArray(array) 86、JavaScript中的作用域与变量声明提升？其他部分 （HTTP、正则、优化、重构、响应式、移动端、团队协作、SEO、UED、职业生涯） 基于Class的选择性的性能相对于Id选择器开销很大，因为需遍历所有DOM元素。 频繁操作的DOM，先缓存起来再操作。用Jquery的链式调用更好。 比如：var str=$(&quot;a&quot;).attr(&quot;href&quot;); for (var i = size; i &lt; arr.length; i++) {} for 循环每一次循环都查找了数组 (arr) 的.length 属性，在开始循环的时候设置一个变量来存储这个数字，可以让循环跑得更快： for (var i = size, length = arr.length; i &lt; length; i++) {} 87、前端开发的优化问题（看雅虎14条性能优化原则）。 （1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。 （2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数 （3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。 （4） 当需要设置的样式很多时设置className而不是直接操作style。 （5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。 （6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。 （7） 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。 （8） 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢。 88、http状态码有那些？分别代表是什么意思？ 100-199 用于指定客户端应相应的某些动作。 200-299 用于表示请求成功。 300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。 400-499 用于指出客户端的错误。 400 语义有误，当前请求无法被服务器理解。 401 当前请求需要用户验证 403 服务器已经理解请求，但是拒绝执行它。 500-599 用于支持服务器错误。 503 – 服务不可用 89、一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好） 要熟悉前后端的通信流程，最好把动态网站的背后细节也介绍一遍 八、流行框架1、JQuery的源码看过吗？能不能简单概况一下它的实现原理？考察学习知识的态度，是否仅仅是停留在使用层面，要知其然知其所以然 2、jQuery.fn的init方法返回的this指的是什么对象？为什么要返回this？this执行init构造函数自身，其实就是jQuery实例对象，返回this是为了实现jQuery的链式操作 3、jquery中如何将数组转化为json字符串，然后再转化回来？$.parseJSON(‘{“name”:”John”}’); 4、jQuery 的属性拷贝(extend)的实现原理是什么，如何实现深拷贝？递归赋值 5、jquery.extend 与 jquery.fn.extend的区别？Jquery.extend用来扩展jQuery对象本身；jquery.fn.extend用来扩展jQuery实例 6、谈一下Jquery中的bind(),live(),delegate(),on()的区别？7、JQuery一个对象可以同时绑定多个事件，这是如何实现的？可以同时绑定多个事件，低层实现原理是使用addEventListner与attachEvent兼容处理做事件注册 10、Jquery与jQuery UI有啥区别？jQuery是操作dom的框架，jQueryUI是基于jQuery做的一个UI组件库 11、jQuery和Zepto的区别？各自的使用场景？jQuery主要用于pc端，当然有对应的jQuerymobile用于移动端，zepto比jQuery更加小巧，主要用于移动端 12、针对 jQuery 的优化方法？优先使用ID选择器 在class前使用tag(标签名) 给选择器一个上下文 慎用 .live()方法（应该说尽量不要使用） 使用data()方法存储临时变量 13、Zepto的点透问题如何解决？点透主要是由于两个div重合，例如：一个div调用show()，一个div调用hide()；这个时候当点击上面的div的时候就会影响到下面的那个div； 解决办法主要有2种： 1.github上有一个叫做fastclick的库，它也能规避移动设备上click事件的延迟响应，https://github.com/ftlabs/fastclick 将它用script标签引入页面（该库支持AMD，于是你也可以按照AMD规范，用诸如require.js的模块加载器引入），并且在dom ready时初始化在body上， 2.根据分析，如果不引入其它类库，也不想自己按照上述fastclcik的思路再开发一套东西，需要1.一个优先于下面的“divClickUnder”捕获的事件；2.并且通过这个事件阻止掉默认行为（下面的“divClickUnder”对click事件的捕获，在iOS的safari，click的捕获被认为和滚屏、点击输入框弹起键盘等一样，是一种浏览器默认行为，即可以被event.preventDefault()阻止的行为）。 12、知道各种JS框架(Angular, Backbone, Ember, React, Meteor, Knockout…)么? 能讲出他们各自的优点和缺点么?知识面的宽度，流行框架要多多熟悉 13、Underscore 对哪些 JS 原生对象进行了扩展以及提供了哪些好用的函数方法？Underscore的熟悉程度 14、使用过angular吗？angular中的过滤器是干什么用的在表达式中转换数据1&lt;p&gt;姓名为 &#123;&#123; lastName | uppercase &#125;&#125;&lt;/p&gt; currency，是什么过滤器——格式化数字为货币格式，单位是$符。 九、移动APP开发1、移动端最小触控区域是多大？移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？（click 有 300ms 延迟,为了实现safari的双击事件的设计，浏览器要知道你是不是要双击操作。） 十、NodeJs1、对Node的优点和缺点提出了自己的看法：（优点）因为Node是基于事件驱动和无阻塞的，所以非常适合处理并发请求， 因此构建在Node上的代理服务器相比其他技术实现（如Ruby）的服务器表现要好得多。 此外，与Node代理服务器交互的客户端代码是由javascript语言编写的， 因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。 （缺点）Node是一个相对新的开源项目，所以不太稳定，它总是一直在变， 而且缺少足够多的第三方库支持。看起来，就像是Ruby/Rails当年的样子。 2、需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？至少给出自己的思路（url-hash,可以使用已有的一些框架history.js等） 6、Node.js的适用场景？1)、实时应用：如在线聊天，实时通知推送等等（如socket.io） 2)、分布式应用：通过高效的并行I/O使用已有的数据 3)、工具类应用：海量的工具，小到前端压缩部署（如grunt），大到桌面图形界面应用程序 4)、游戏类应用：游戏领域对实时和并发有很高的要求（如网易的pomelo框架） 5)、利用稳定接口提升Web渲染能力 6)、前后端编程语言环境统一：前端开发人员可以非常快速地切入到服务器端的开发（如著名的纯Javascript全栈式MEAN架构） 4、(如果会用node)知道route, middleware, cluster, nodemon, pm2, server-side rendering么?Nodejs相关概念的理解程度 7、解释一下 Backbone 的 MVC 实现方式？流行的MVC架构模式 8、什么是“前端路由”?什么时候适合使用“前端路由”? “前端路由”有哪些优点和缺点?熟悉前后端通信相关知识 7、对Node的优点和缺点提出了自己的看法？优点： 因为Node是基于事件驱动和无阻塞的，所以非常适合处理并发请求，因此构建在Node上的代理服务器相比其他技术实现（如Ruby）的服务器表现要好得多。 与Node代理服务器交互的客户端代码是由javascript语言编写的，因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。 缺点： Node是一个相对新的开源项目，所以不太稳定，它总是一直在变。 缺少足够多的第三方库支持。看起来，就像是Ruby/Rails当年的样子（第三方库现在已经很丰富了，所以这个缺点可以说不存在了）。 十一、前端概括性问题1、常使用的库有哪些？常用的前端开发工具？开发过什么应用或组件？使用率较高的框架有jQuery、YUI、Prototype、Dojo、Ext.js、Mootools等。尤其是jQuery，超过91%。 轻量级框架有Modernizr、underscore.js、backbone.js、Raphael.js等。（理解这些框架的功能、性能、设计原理） 前端开发工具：Sublime Text 、Eclipse、Notepad、Firebug、HttpWatch、Yslow。 开发过的插件：城市选择插件，汽车型号选择插件、幻灯片插件。弹出层。（写过开源程序，加载器，js引擎更好） 9、对BFC规范的理解？Formatting Context：指页面中的一个渲染区域，并且拥有一套渲染规则，他决定了其子元素如何定位，以及与其他元素的相互关系和作用。 3、99%的网站都需要被重构是那本书上写的？网站重构：应用web标准进行设计（第2版） 4、WEB应用从服务器主动推送Data到客户端有那些方式？ html5 websoket WebSocket通过Flash XHR长时间连接 XHR Multipart Streaming 不可见的Iframe 标签的长时间连接(可跨域) 5、加班的看法加班就像借钱，原则应当是——救急不救穷 6、平时如何管理你的项目，如何设计突发大规模并发架构？先期团队必须确定好全局样式（globe.css），编码模式(utf-8) 等 编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）； 标注样式编写人，各模块都及时标注（标注关键样式调用的地方）； 页面进行标注（例如 页面 模块 开始和结束）； CSS跟HTML 分文件夹并行存放，命名都得统一（例如style.css） JS 分文件夹存放 命民以该JS 功能为准英文翻译； 图片采用整合的 images.png png8 格式文件使用 尽量整合在一起使用方便将来的管理 7、那些操作会造成内存泄漏？内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。 垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。 setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。 闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环） 8、你说你热爱前端，那么应该WEB行业的发展很关注吧？ 说说最近最流行的一些东西吧？Node.js、MongoDB、npm、MVVM、MEAN、React、AngularJS 9、你有了解我们公司吗？说说你的认识？因为我想去阿里，所以我针对阿里的说 最羡慕就是在双十一购物节，350.19亿元，每分钟支付79万笔。海量数据，居然无一漏单、无一故障。太厉害了。 10、 移动端（比如：Android IOS）怎么做好用户体验?融入自己的设计理念，注重用户体验，选择合适的技术 11、 你所知道的页面性能优化方法有那些？压缩、合并，减少请求，代码层析优化。。。 12、 除了前端以外还了解什么其它技术么？你最最厉害的技能是什么？知识面宽度，最好熟悉一些后台语言，比如php，展现出自己的技术两点 13、AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？14、谈谈你认为怎样做能使项目做的更好？考虑问题的深入，不仅仅停留在完成任务上，要精益求精 15、你对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？表现出对前端的认同与兴趣，关注相关技术前沿 16、php中下面哪个函数可以打开一个文件，以对文件进行读和写操作？A.fget();B.file_open();C.fopen();D.open_file(); 17、php中rmdir可以直接删除文件夹吗？该目录必须是空的，而且要有相应的权限–来自apiA.任何文件夹都可以删除 B.空文件夹可以删除 C.有权限的任何文件夹都可以删除 D.有权限的空文件夹可以删除 18、phpinset和empty的区别，举例说明1、empty函数 用途：检测变量是否为空 判断：如果 var 是非空或非零的值，则 empty() 返回 FALSE。换句话说，””、0、”0”、NULL、FALSE、array()、var $var; 以及没有任何属性的对象都将被认为是空的，如果 var 为空，则返回 TRUE。注意：empty() 只检测变量，检测任何非变量的东西都将导致解析错误。换句话说，后边的语句将不会起作用; 2、isset函数 用途：检测变量是否设置 判断：检测变量是否设置，并且不是 NULL。如果已经使用 unset() 释放了一个变量之后，它将不再是 isset()。若使用 isset() 测试一个被设置成 NULL 的变量，将返回 FALSE。同时要注意的是一个NULL 字节（”\0”）并不等同于 PHP 的 NULL 常数。 19、php中$_SERVER变量中如何得到当前执行脚本路劲 20、写一个php函数，要求两个日期字符串的天数差，如2012-02-05~2012-03-06的日期差数21、一个衣柜中放了许多杂乱的衬衫，如果让你去整理一下，使得更容易找到你想要的衣服；你会怎么做？请写出你的做法和思路？22、如何优化网页加载速度？ 1.减少css，js文件数量及大小(减少重复性代码，代码重复利用)，压缩CSS和Js代码 2.图片的大小 3.把css样式表放置顶部，把js放置页面底部 4.减少http请求数 5.使用外部 Js 和 CSS 23、工作流程，你怎么来实现页面设计图，你认为前端应该如何高质量完成工作?熟悉相关设计规范，自己总结的一些经验 24、介绍项目经验、合作开发、独立开发。团队协作，个人能力。实践经验 25、开发过程中遇到困难，如何解决。考察解决问题的能力 26、对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？ 前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。 1、实现界面交互 2、提升用户体验 3、有了Node.js，前端可以实现服务端的一些事情 前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好， 参与项目，快速高质量完成实现效果图，精确到1px； 与团队成员，UI设计，产品经理的沟通； 做好的页面结构，页面重构和用户体验； 处理hack，兼容、写出优美的代码格式； 针对服务器的优化、拥抱最新前端技术。 其它相关的加分项： 1. 都使用和了解过哪些编辑器?都使用和了解过哪些日常工具? 2. 都知道有哪些浏览器内核?开发过的项目都兼容哪些浏览器? 3. 瀑布流布局或者流式布局是否有了解 4. HTML5都有哪些新的API? 5. 都用过什么代码调试工具? 6. 是否有接触过或者了解过重构。 7.你遇到过比较难的技术问题是？你是如何解决的？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTTP、HTTP2.0、SPDY、HTTPS]]></title>
      <url>%2F2017%2F06%2F05%2FHTTP%E3%80%81HTTP2-0%E3%80%81SPDY%E3%80%81HTTPS%2F</url>
      <content type="text"><![CDATA[作为一个经常和web打交道的程序员，了解这些协议是必须的，本文就向大家介绍一下这些协议的区别和基本概念，文中可能不局限于前端知识，还包括一些运维，协议方面的知识 1. web始祖HTTP 全称：超文本传输协议(HyperText Transfer Protocol) 伴随着计算机网络和浏览器的诞生，HTTP1.0也随之而来，处于计算机网络中的应用层。 HTTP是建立在TCP协议之上，所以HTTP协议的瓶颈及其优化技巧都是基于TCP协议本身的特性，例如tcp建立连接的3次握手和断开连接的4次挥手以及每次建立连接带来的RTT延迟时间。 2. HTTP与现代化浏览器 早在HTTP建立之初，主要就是为了将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器。也是说对于前端来说，我们所写的HTML页面将要放在我们的web服务器上，用户端通过浏览器访问url地址来获取网页的显示内容。 但是到了WEB2.0以来，我们的页面变得复杂，不仅仅单纯的是一些简单的文字和图片，同时我们的HTML页面有了CSS，Java，来丰富我们的页面展示。 当ajax的出现，我们又多了一种向服务器端获取数据的方法，这些其实都是基于HTTP协议的。 同样到了移动互联网时代，我们页面可以跑在手机端浏览器里面，但是和PC相比，手机端的网络情况更加复杂，这使得我们开始了不得不对HTTP进行深入理解并不断优化过程中。 3. HTTP的基本优化 影响一个HTTP网络请求的因素主要有两个：带宽和延迟。 带宽：如果说我们还停留在拨号上网的阶段，带宽可能会成为一个比较严重影响请求的问题，但是现在网络基础建设已经使得带宽得到极大的提升，我们不再会担心由带宽而影响网速，那么就只剩下延迟了。 延迟： 浏览器阻塞（HOL blocking）：浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能有 4 个连接（这个根据浏览器内核不同可能会有所差异），超过浏览器最大连接数限制，后续请求就会被阻塞。 DNS 查询（DNS Lookup）：浏览器需要知道目标服务器的 IP 才能建立连接。将域名解析为 IP 的这个系统就是 DNS。这个通常可以利用DNS缓存结果来达到减少这个时间的目的。 建立连接（Initial connection）：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。 4. HTTP1.0和HTTP1.1的一些区别 HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在： 缓存处理，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。 带宽优化及网络连接的使用，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。 错误通知的管理，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。 Host头处理，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。 长连接，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。以下是常见的HTTP1.0： 区别用一张图来体现： 5. HTTP1.0和1.1现存的一些问题 上面提到过的，HTTP1.x在传输数据时，每次都需要重新建立连接，无疑增加了大量的延迟时间，特别是在移动端更为突出。 HTTP1.x在传输数据时，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份，这在一定程度上无法保证数据的安全性。 HTTP1.x在使用时，header里携带的内容过大，在一定程度上增加了传输的成本，并且每次请求header基本不怎么变化，尤其在移动端增加用户流量。 虽然HTTP1.x支持了keep-alive，来弥补多次创建连接产生的延迟，但是keep-alive使用多了同样会给服务端带来大量的性能压力，并且对于单个文件被不断请求的服务(例如图片存放网站)，keep-alive可能会极大的影响性能，因为它在文件被请求之后还保持了不必要的连接很长时间。 6. HTTPS应声而出 为了解决以上问题，网景在1994年创建了HTTPS，并应用在网景导航者浏览器中。 最初，HTTPS是与SSL一起使用的；在SSL逐渐演变到TLS时（其实两个是一个东西，只是名字不同而已），最新的HTTPS也由在2000年五月公布的RFC 2818正式确定下来。 简单来说，HTTPS就是安全版的HTTP，并且由于当今时代对安全性要求更高，chrome和firefox都大力支持网站使用HTTPS，苹果也在iOS 10系统中强制app使用HTTPS来传输数据，由此可见HTTPS势在必行。 7. HTTPS与HTTP的一些区别 HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。 HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。 HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。 8. HTTPS改造 如果一个网站要全站由HTTP替换成HTTPS，可能需要关注以下几点： 安装CA证书，一般的证书都是需要收费的，这边推荐一个比较好的购买证书网站：1）Let’s Encrypt，免费，快捷，支持多域名（不是通配符），三条命令即时签署+导出证书。缺点是暂时只有三个月有效期，到期需续签。2Comodo PositiveSSL，收费，但是比较稳定。 在购买证书之后，在证书提供的网站上配置自己的域名，将证书下载下来之后，配置自己的web服务器，同时进行代码改造。 HTTPS 降低用户访问速度。SSL握手，HTTPS 对速度会有一定程度的降低，但是只要经过合理优化和部署，HTTPS 对速度的影响完全可以接受。在很多场景下，HTTPS 速度完全不逊于 HTTP，如果使用 SPDY，HTTPS 的速度甚至还要比 HTTP 快。 相对于HTTPS降低访问速度，其实更需要关心的是服务器端的CPU压力，HTTPS中大量的密钥算法计算，会消耗大量的CPU资源，只有足够的优化，HTTPS 的机器成本才不会明显增加。 推荐一则淘宝网改造HTTPS（http://velocity.oreilly.com.cn/2015/ppts/lizhenyu.pdf）的文章。 9. 使用SPDY加快你的网站速度 2012年google如一声惊雷提出了SPDY的方案，大家才开始从正面看待和解决老版本HTTP协议本身的问题，SPDY可以说是综合了HTTPS和HTTP两者有点于一体的传输协议， 主要解决： 降低延迟，针对HTTP高延迟的问题，SPDY优雅的采取了多路复用（multiplexing）。多路复用通过多个请求stream共享一个tcp连接的方式，解决了HOL blocking的问题，降低了延迟同时提高了带宽的利用率。 请求优先级（request prioritization）。多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。SPDY允许给每个request设置优先级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的html内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。 header压缩。前面提到HTTP1.x的header很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。 基于HTTPS的加密协议传输，大大提高了传输数据的可靠性。 服务端推送（server push），采用了SPDY的网页，例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了。SPDY构成图： SPDY位于HTTP之下，TCP和SSL之上，这样可以轻松兼容老版本的HTTP协议(将HTTP1.x的内容封装成一种新的frame格式)，同时可以使用已有的SSL功能。 兼容性： 10. HTTP2.0的前世今生 顾名思义有了HTTP1.x，那么HTTP2.0也就顺理成章的出现了。 HTTP2.0可以说是SPDY的升级版（其实原本也是基于SPDY设计的），但是，HTTP2.0 跟 SPDY 仍有不同的地方，主要是以下两点： HTTP2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS HTTP2.0 消息头的压缩算法采用 HPACK，而非 SPDY 采用的 DEFLATE 11. HTTP2.0的新特性 新的二进制格式（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。 多路复用（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。多路复用原理图： header压缩，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。 服务端推送（server push），同SPDY一样，HTTP2.0也具有server push功能。目前，有大多数网站已经启用HTTP2.0，例如YouTuBe，淘宝网等网站，利用chrome控制台可以查看是否启用H2： 更多关于HTTP2的问题可以参考：HTTP2奇妙日常（http://www.alloyteam.com/2015/03/http2-0-di-qi-miao-ri-chang/），以及HTTP2.0的官方网站。 关于HTTP2和HTTP1.x的区别大致可以看下图： 12. HTTP2.0的升级改造 对比HTTPS的升级改造，HTTP2.0或许会稍微简单一些，你可能需要关注以下问题： 前文说了HTTP2.0其实可以支持非HTTPS的，但是现在主流的浏览器像chrome，firefox表示还是只支持基于 TLS 部署的HTTP2.0协议，所以要想升级成HTTP2.0还是先升级HTTPS为好。 当你的网站已经升级HTTPS之后，那么升级HTTP2.0就简单很多，如果你使用NGINX，只要在配置文件中启动相应的协议就可以了，可以参考NGINX白皮书，NGINX配置HTTP2.0官方指南。 使用了HTTP2.0那么，原本的HTTP1.x怎么办，这个问题其实不用担心，HTTP2.0完全兼容HTTP1.x的语义，对于不支持HTTP2.0的浏览器，NGINX会自动向下兼容的。 后记 以上就是关于HTTP,HTTP2.0,SPDY,HTTPS的一些基本理论，有些内容没有深入讲解，大家可以跟进参考连接具体查看。 关于HTTP1.x的一些优化方式，例如文件合并压缩，资源cdn，js，css优化等等同样使用与HTTP2.0和HTTPS，所以web前端的优化，还是要继续进行。 其实WEB发展如此迅速的今天，有些技术是真的要与时俱进的，就像苹果宣布ios 10必须使用HTTPS开始，关于web协议革新就已经开始了，为了更好的性能，更优越的方式，现在就开始升级改造吧 参考资料： http://www.nihaoshijie.com.cn/index.PHP/archives/630 https://www.nginx.com/blog/7-tips-for-faster-http2-performance/ https://www.gitbook.com/book/ye11ow/http2-explained/details http://op.baidu.com/2015/04/https-s01a01/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浅谈csrf攻击方式]]></title>
      <url>%2F2017%2F06%2F01%2F%E6%B5%85%E8%B0%88csrf%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[一.CSRF是什么？ CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。 二.CSRF可以做什么？ 你这可以这么理解CSRF攻击：攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账……造成的问题包括：个人隐私泄露以及财产安全。 三.CSRF漏洞现状 CSRF这种攻击方式在2000年已经被国外的安全人员提出，但在国内，直到06年才开始被关注，08年，国内外的多个大型社区和交互网站分别爆出CSRF漏洞，如：NYTimes.com（纽约时报）、Metafilter（一个大型的BLOG网站），YouTube和百度HI……而现在，互联网上的许多站点仍对此毫无防备，以至于安全业界称CSRF为“沉睡的巨人”。 四.CSRF的原理 下图简单阐述了CSRF攻击的思想： 从上图可以看出，要完成一次CSRF攻击，受害者必须依次完成两个步骤： 1.登录受信任网站A，并在本地生成Cookie。 2.在不登出A的情况下，访问危险网站B。 看到这里，你也许会说：“如果我不满足以上两个条件中的一个，我就不会受到CSRF的攻击”。是的，确实如此，但你不能保证以下情况不会发生： 1.你不能保证你登录了一个网站后，不再打开一个tab页面并访问另外的网站。 2.你不能保证你关闭浏览器了后，你本地的Cookie立刻过期，你上次的会话已经结束。（事实上，关闭浏览器不能结束一个会话，但大多数人都会错误的认为关闭浏览器就等于退出登录/结束会话了……） 3.上图中所谓的攻击网站，可能是一个存在其他漏洞的可信任的经常被人访问的网站。 上面大概地讲了一下CSRF攻击的思想，下面我将用几个例子详细说说具体的CSRF攻击，这里我以一个银行转账的操作作为例子（仅仅是例子，真实的银行网站没这么傻:&gt;） 示例1： 银行网站A，它以GET请求来完成银行转账的操作，如：http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000 危险网站B，它里面有一段HTML的代码如下：1 &lt;img src=http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&gt; 首先，你登录了银行网站A，然后访问危险网站B，噢，这时你会发现你的银行账户少了1000块…… 为什么会这样呢？原因是银行网站A违反了HTTP规范，使用GET请求更新资源。在访问危险网站B的之前，你已经登录了银行网站A，而B中的以GET的方式请求第三方资源（这里的第三方就是指银行网站了，原本这是一个合法的请求，但这里被不法分子利用了），所以你的浏览器会带上你的银行网站A的Cookie发出Get请求，去获取资源“http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000”，结果银行网站服务器收到请求后，认为这是一个更新资源操作（转账操作），所以就立刻进行转账操作…… 示例2： 为了杜绝上面的问题，银行决定改用POST请求完成转账操作。 银行网站A的WEB表单如下： 12345 &lt;form action=&quot;Transfer.php&quot; method=&quot;POST&quot;&gt; &lt;p&gt;ToBankId: &lt;input type=&quot;text&quot; name=&quot;toBankId&quot; /&gt;&lt;/p&gt; &lt;p&gt;Money: &lt;input type=&quot;text&quot; name=&quot;money&quot; /&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;Transfer&quot; /&gt;&lt;/p&gt; &lt;/form&gt; 后台处理页面Transfer.php如下： 1234567 &lt;?php session_start(); if (isset($_REQUEST[&apos;toBankId&apos;] &amp;&amp; isset($_REQUEST[&apos;money&apos;])) &#123; buy_stocks($_REQUEST[&apos;toBankId&apos;], $_REQUEST[&apos;money&apos;]); &#125; ?&gt; 危险网站B，仍然只是包含那句HTML代码：1 &lt;img src=http://www.mybank.com/Transfer.php?toBankId=11&amp;money=1000&gt; 和示例1中的操作一样，你首先登录了银行网站A，然后访问危险网站B，结果…..和示例1一样，你再次没了1000块～T_T，这次事故的原因是：银行后台使用了$_REQUEST去获取请求的数据，而$_REQUEST既可以获取GET请求的数据，也可以获取POST请求的数据，这就造成了在后台处理程序无法区分这到底是GET请求的数据还是POST请求的数据。在PHP中，可以使用$_GET和$_POST分别获取GET请求和POST请求的数据。在JAVA中，用于获取请求数据request一样存在不能区分GET请求数据和POST数据的问题。 示例3： 经过前面2个惨痛的教训，银行决定把获取请求数据的方法也改了，改用$_POST，只获取POST请求的数据，后台处理页面Transfer.php代码如下： 1234567 &lt;?php session_start(); if (isset($_POST[&apos;toBankId&apos;] &amp;&amp; isset($_POST[&apos;money&apos;])) &#123; buy_stocks($_POST[&apos;toBankId&apos;], $_POST[&apos;money&apos;]); &#125; ?&gt; 然而，危险网站B与时俱进，它改了一下代码： 1234567891011121314151617181920&lt;html&gt; &lt;head&gt; &lt;script type=&quot;text/javascript&quot;&gt; function steal() &#123; iframe = document.frames[&quot;steal&quot;]; iframe.document.Submit(&quot;transfer&quot;); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body onload=&quot;steal()&quot;&gt; &lt;iframe name=&quot;steal&quot; display=&quot;none&quot;&gt; &lt;form method=&quot;POST&quot; name=&quot;transfer&quot; action=&quot;http://www.myBank.com/Transfer.php&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;toBankId&quot; value=&quot;11&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;money&quot; value=&quot;1000&quot;&gt; &lt;/form&gt; &lt;/iframe&gt; &lt;/body&gt;&lt;/html&gt; 如果用户仍是继续上面的操作，很不幸，结果将会是再次不见1000块……因为这里危险网站B暗地里发送了POST请求到银行! 总结一下上面3个例子，CSRF主要的攻击模式基本上是以上的3种，其中以第1,2种最为严重，因为触发条件很简单，一个就可以了，而第3种比较麻烦，需要使用JavaScript，所以使用的机会会比前面的少很多，但无论是哪种情况，只要触发了CSRF攻击，后果都有可能很严重。 理解上面的3种攻击模式，其实可以看出，CSRF攻击是源于WEB的隐式身份验证机制！WEB的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的！ 五.CSRF的防御 我总结了一下看到的资料，CSRF的防御可以从服务端和客户端两方面着手，防御效果是从服务端着手效果比较好，现在一般的CSRF防御也都在服务端进行。 1.服务端进行CSRF防御 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数。 (1).Cookie Hashing(所有表单都包含同一个伪随机值)： 这可能是最简单的解决方案了，因为攻击者不能获得第三方的Cookie(理论上)，所以表单中的数据也就构造失败了:&gt;12345 &lt;?php //构造加密的Cookie信息 $value = “DefenseSCRF”; setcookie(”cookie”, $value, time()+3600); ?&gt; 在表单里增加Hash值，以认证这确实是用户发送的请求。 123456789 &lt;?php $hash = md5($_COOKIE[&apos;cookie&apos;]); ?&gt; &lt;form method=”POST” action=”transfer.php”&gt; &lt;input type=”text” name=”toBankId”&gt; &lt;input type=”text” name=”money”&gt; &lt;input type=”hidden” name=”hash” value=”&lt;?=$hash;?&gt;”&gt; &lt;input type=”submit” name=”submit” value=”Submit”&gt; &lt;/form&gt; 然后在服务器端进行Hash值验证 123456789101112&lt;?php if(isset($_POST[&apos;check&apos;])) &#123; $hash = md5($_COOKIE[&apos;cookie&apos;]); if($_POST[&apos;check&apos;] == $hash) &#123; doJob(); &#125; else &#123; //... &#125; &#125; else &#123; //... &#125;?&gt; 这个方法个人觉得已经可以杜绝99%的CSRF攻击了，那还有1%呢….由于用户的Cookie很容易由于网站的XSS漏洞而被盗取，这就另外的1%。一般的攻击者看到有需要算Hash值，基本都会放弃了，某些除外，所以如果需要100%的杜绝，这个不是最好的方法。 (2).验证码 这个方案的思路是：每次的用户提交都需要用户在表单中填写一个图片上的随机字符串，厄….这个方案可以完全解决CSRF，但个人觉得在易用性方面似乎不是太好，还有听闻是验证码图片的使用涉及了一个被称为MHTML的Bug，可能在某些版本的微软IE中受影响。 (3).One-Time Tokens(不同的表单包含一个不同的伪随机值) 在实现One-Time Tokens时，需要注意一点：就是“并行会话的兼容”。如果用户在一个站点上同时打开了两个不同的表单，CSRF保护措施不应该影响到他对任何表单的提交。考虑一下如果每次表单被装入时站点生成一个伪随机值来覆盖以前的伪随机值将会发生什么情况：用户只能成功地提交他最后打开的表单，因为所有其他的表单都含有非法的伪随机值。必须小心操作以确保CSRF保护措施不会影响选项卡式的浏览或者利用多个浏览器窗口浏览一个站点。 以下我的实现: 1).先是令牌生成函数(gen_token())： 1234567&lt;?phpfunction gen_token() &#123; //这里我是贪方便，实际上单使用Rand()得出的随机数作为令牌，也是不安全的。 //这个可以参考我写的Findbugs笔记中的《Random object created and used only once》 $token = md5(uniqid(rand(), true)); return $token;&#125; 2).然后是Session令牌生成函数(gen_stoken())： 123456789101112&lt;?php function gen_stoken() &#123; $pToken = &quot;&quot;; if($_SESSION[STOKEN_NAME] == $pToken)&#123; //没有值，赋新值 $_SESSION[STOKEN_NAME] = gen_token(); &#125; else&#123; //继续使用旧的值 &#125; &#125;?&gt; 3).WEB表单生成隐藏输入域的函数： 1234567&lt;?php function gen_input() &#123; gen_stoken(); echo “&lt;input type=\”hidden\” name=\”&quot; . FTOKEN_NAME . “\” value=\”&quot; . $_SESSION[STOKEN_NAME] . “\”&gt; “; &#125;?&gt; 4).WEB表单结构： 12345678910&lt;?php session_start(); include(”functions.php”);?&gt;&lt;form method=”POST” action=”transfer.php”&gt; &lt;input type=”text” name=”toBankId”&gt; &lt;input type=”text” name=”money”&gt; &lt;? gen_input(); ?&gt; &lt;input type=”submit” name=”submit” value=”Submit”&gt;&lt;/FORM&gt; 5).服务端核对令牌： 这个很简单，这里就不再啰嗦了。 六.参考文献 [1].Preventing CSRF [2].Security Corner: Cross-Site Request Forgeries [3].《深入解析跨站请求伪造漏洞：原理剖析》 [4].《Web安全测试之跨站请求伪造（CSRF）》 [5].《深入解析跨站请求伪造漏洞：实例讲解》 [6].http://baike.baidu.com/view/1609487.htm]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端知识图谱]]></title>
      <url>%2F2017%2F05%2F22%2F%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%2F</url>
      <content type="text"><![CDATA[综合类 前端知识体系 前端知识结构 Web前端开发大系概览 Web前端开发大系概览-中文版 Web Front-end Stack v2.2 免费的编程中文书籍索引 前端书籍 前端免费书籍大全 前端知识体系 免费的编程中文书籍索引 智能社 - 精通JavaScript开发 重新介绍 JavaScript（JS 教程） 麻省理工学院公开课：计算机科学及编程导论 JavaScript中的this陷阱的最全收集–没有之一 JS函数式编程指南 JavaScript Promise迷你书（中文版） 腾讯移动Web前端知识库 Front-End-Develop-Guide 前端开发指南 前端开发笔记本 大前端工具集 - 聂微东 前端开发者手册 入门类 前端入门教程 瘳雪峰的Javascript教程 jQuery基础教程 前端工程师必备的PS技能——切图篇 结合个人经历总结的前端入门方法 效果类 弹出层 焦点图轮播特效 工具类 css sprite 雪碧图制作 版本控制入门 – 搬进 Github Grunt-beginner前端自动化工具 慕课专题 张鑫旭 - 慕课系列 lyn - 慕课系列 艾伦 - 慕课系列 碧仔 - Hello，移动WEB 周报类 平安科技移动开发二队技术周报 六. API:总目录开发中心 mozilla js参考 chrome开发中心（chrome的内核已转向blink） safari开发中心 microsoft js参考.aspx) js秘密花园 js秘密花园 w3help 综合Bug集合网站 综合搜索 javascripting 各种流行库搜索 综合API runoob.com-包含各种API集合 开源中国在线API文档合集 devdocs 英文综合API网站 2. jQuery jQuery API 中文文档hemin 在线版css88 jq apicss88 jqui api学习jqueryjquery 源码查找3. EcmascriptUnderstanding ECMAScript 6 - Nicholas C. Zakasexploring-es6exploring-es6翻译exploring-es6翻译后预览阮一峰 es6阮一峰 JavascriptECMA-262，第 5 版es54. Js templatetemplate-chooserartTemplatetomdjs淘宝模板juicer模板Fxtpl v1.0 繁星前端模板引擎laytplmozilla - nunjucksJuicerdustjsetpl5. 弹出层artDialog 最新版artDialog 文档google code 下载地址贤心弹出层响应式用户交互组件库sweetalert-有css3动画弹出层6. CSSCSS 语法参考CSS3动画手册腾讯css3动画制作工具志爷css小工具集合css3 js 移动大杂烩bouncejs 触摸库css3 按钮动画animate.css全局CSS的终结(狗带) [译]7. AngularjsAngular.js 的一些学习资源angularjs中文社区Angularjs源码学习Angularjs源码学习angular对bootstrap的封装angularjs + nodejs吕大豹 AngularjsAngularJS 最佳实践Angular的一些扩展指令Angular数据绑定原理一些扩展Angular UI组件Ember和AngularJS的性能测试带你走近AngularJS - 基本功能介绍Angularjs开发指南Angularjs学习不要带着jQuery的思维去学习AngularJSangularjs 学习笔记angularjs 开发指南angularjs 英文资料angular bootstrapangular jq mobileangular ui整合jQuery Mobile+AngularJS经验谈有jQuery背景，该如何用AngularJS编程思想AngularJS在线教程angular学习笔记8. Reactreact.js 中文论坛react.js 官方网址react.js 官方文档react.js material UIreact.js TouchstoneJS UIreact.js amazeui UIReact 入门实例教程 - 阮一峰React Native 中文版Webpack 和 React 小书 - 前端乱炖Webpack 和 React 小书 - gitbookwebpackWebpack，101入门体验webpack入门教程基于webpack搭建前端工程解决方案探索React原创实战视频教程9. 移动端APIAPI99移动端知识集合移动端前端开发知识库移动前端的一些坑和解决方法（外观表现）【原】移动web资源整理zepto 1.0 中文手册zepto 1.0 中文手册zepto 1.1.2zepto 中文注释jqmobile 手册移动浏览器开发集合移动开发大杂烩微信webview中的一些问题#### 框架特色的HTML框架可以创建精美的iOS应用淘宝SUI10. avalonavalonjsAvalon新一代UI库： OniUIavalon.oniui-基于avalon的组件库11. RequriejsJavascript模块化编程（一）：模块的写法 Javascript模块化编程（二）：AMD规范Javascript模块化编程（三）：require.js的用法RequireJS入门（一）RequireJS入门（二）RequireJS进阶（三）requrie源码学习requrie 入门指南requrieJS 学习笔记requriejs 其一 require backbone结合12. Seajsseajsseajs 中文手册13. Less,sasssasssass教程-sass中国Sass 中文文档less14. MarkdownMarkdown 语法说明 (简体中文版)markdown入门参考gitbook国外的在线markdown可编辑成书mdeditor 一款国内的在线markdown编辑器stackedit国外的在线markdown编辑器，功能强大，同步云盘 mditor 一款轻量级的markdown编辑器lepture-editormarkdown-editor15. D3d3 TutorialsGallerylofteriteyeruanyifeng16. 兼容性esma 兼容列表W3C CSS验证服务caniusecsscreatormicrosoft.aspx)在线测兼容-移动端emulators17. UI相关bootcssMetroUICSSsemanticButtonskitecsspintueramazeuiworldhellolinuxtoygitmagicrogerdudlergitrefbookgogojimmy18. HTTPHTTP API 设计指南19. 其它APIjavascript流行库汇总验证apiunderscore 中文手册underscore源码分析underscore源码分析-亚里士朱德的博客underscrejs en apilodash - underscore的代替品ext4apibackbone 中文手册qwrap手册缓动函数svg 中文参考svg mdn参考svg 导出 canvassvg 导出 pngai-to-svglocalStorage 库20. 图表类Highcharts 中文APIHighcharts 英文APIECharts 百度的图表软件高德地图开源的矢量图脚本框架svg 地图21. vueVueVue 论坛Vue 入门指南Vue 的一些资源索引 21. 正则 JS正则表达式元字符正则表达式30分钟入门教程MDN-正则表达式ruanyifeng - RegExp对象小胡子哥 - 进阶正则表达式is.js正则在线测试 22. ionic ionic23. 其它Mock.js 是一款模拟数据生成器### 七. 开发规范前端通过分析github代码库总结出来的工程师代码书写习惯HTML&amp;CSS编码规范 by @mdo团队合作的css命名规范-腾讯AlloyTeam前端团队前端编码规范之js - by yuwenhui前端编码规范之js - by 李靖前端开发规范手册Airbnb JavaScript 编码规范（简体中文版）AMD与CMD规范的区别AMD与CMD规范的区别KISSY 源码规范bt编码规范规范加强版前端代码规范 及 最佳实践百度前端规范百度前端规范百度前端规范ECMAScript6 编码规范–广发证券前端团队JavaScript 风格指南/编码规范（Airbnb公司版）网易前端开发规范css模块前端规范资源列表#### PHP- 最流行的PHP 代码规范- 最流行的PHP 代码规范#### Android- 【敏捷开发】Android团队开发规范- Android 开发规范与应用## 八. 其它收集### 1. 各大公司开源项目Facebook Projects百度web前端研发部百度EFE百度githuballoyteamalloyteam-githuballoyteam-AlloyGameEngineAlloyDesigner 即时修改，即时保存，设计稿较正，其它开发辅助工具H5交互页编辑器AEditor介绍 H5动画交互页开发的工具介绍AEditor H5动画交互页开发的工具maka值得订阅的weekly腾讯html5奇舞团开源项目Qunar UED### 2. Javascript#### 常用- ieBetter.js-让IE6-IE8拥有IE9+,Chrome等浏览器特性- 模拟键盘- 拼音- 中国个人身份证号验证#### 算法- 数据结构与算法 JavaScript 描述. 章节练习- 常见排序算法（JS版）- 经典排序- 常见排序算法-js版本- JavaScript 算法与数据结构 精华集- 面试常考算法题精讲- #### 移动端- fastclick- no-click-delay#### JSON- 模拟生成JSON数据- 返回跨域JSONAPI### 3. Html5HTML5 有哪些让你惊艳的 demo？### 4. CSSbrowserhacks 5. jQuery 焦点图- myfocus- myfocus-官方演示站- SuperSlidev2.1 – 大话主席- soChange### 6. Ext, EasyUI, J-UI 及其它各种UI方案#### Ext- extjs- ext4英文api- ext4中文api- #### EasyUI- jquery easyui 未压缩源代码#### J-UI- J-UI#### Other- MUI-最接近原生APP体验的高性能前端框架- Amaze UI | 中国首个开源 HTML5 跨屏前端框架- 淘宝 HTML5 前端框架- KISSY - 阿里前端JavaScript库- 网易Nej - Nice Easy Javascript- Kendo UI MVVM Demo- Bootstrap- Smart UI- 雅虎UI - CSS UI### 7. 页面 社会化 分享功能百度分享 pc端JiaThis pc端社会化分享组件 移动端ShareSDK 轻松实现社会化功能 移动端友盟分享 移动端8. 富文本编辑器百度 ueditor经典的ckeditor经典的kindeditorwysiwyg一个有情怀的编辑器。Bach’s Editortower用的编辑器summernote 编辑器html5编辑器XEditorwangEditor### 9. 日历#### pc- 经典my97- 强大的独立日期选择器- fullcalendar- fullcalendar日历控件知识点集合 - 中文api- 农历日历- 超酷的仿百度带节日日历老黄历控件- 日期格式化- 大牛日历控件- 我群某管理作品- input按位替换-官网- input按位替换-github- bootstrap-daterangepicker- 国外30个插件集合- JavaScript datepicker- Datepair.js- 一个风格多样的日历- 弹出层式的全日历- jquery双日历#### 移动- 大气实用jQuery手机移动端日历日期选择插件- jQuery Mobile 移动开发中的日期插件Mobiscroll #### Date library- Datejs- sugarjs### 10. 综合效果搜索平台效果网17素材常用的JavaScript代码片段### 11. 前端工程化#### 概述- 前端工具大全- 什么是前端工程化#### Gulp- Gulp官网- Gulp中文网- gulp资料收集- Gulp：任务自动管理工具 - ruanyifeng- Gulp插件- Gulp不完全入门教程- 为什么使用gulp?- Gulp安装及配合组件构建前端开发一体化- Gulp 入门指南- Gulp 入门指南 - nimojs- Gulp入门教程- Gulp in Action- Gulp开发教程（翻译）- 前端构建工具gulpjs的使用介绍及技巧#### Grunt- gruntjs- Grunt中文网#### Fis- fis 官网- fis### 12. 轮播图#### pc图轮- 单屏轮播sochange- 左右按钮多图切换- fullpage全屏轮播#### 移动端- 无缝切换- 滑屏效果- 全屏fullpage- 单个图片切换- 单个全屏切换- 百度的切换库- 单个全屏切换- 滑屏效果- 旋转拖动设置- 类似于swipe切换- 支持多种形式的触摸滑动- 滑屏效果- 大话主席pc移动图片轮换- 滑屏效果- 基于zepto的fullpage- [WebApp]定宽网页设计下，固定宽度布局开发WebApp并实现多终端下WebApp布局自适应- 判断微信客户端的那些坑- 可以通过javascript直接调用原生分享的工具- JiaThis 分享到微信代码- 聊聊移动端跨平台开发的各种技术- 前端自动化测试- 多种轮换图片- 滑动侧边栏### 13. 文件上传百度上传组件上传flash 头像上传图片上传预览图片裁剪图片裁剪-shearphotojQuery图片处理14. 模拟select糖饼 selectflexselect双selectselect2 15. 取色插件 类似 Photoshop 的界面取色插件jquery color取色插件集合farbtastic 圆环＋正方形 16. 城市联动 jquery.cityselect.js基于jQuery+JSON的省市或自定义联动效果 17. 剪贴板 剪贴板clipboard 最新的剪切方案不是Flash的剪贴板18. 简繁转换简繁转换19. 表格 Gridfacebook表格类似于Excel编辑表格-handsontablebootstrap-table插件datatables20. 在线演示js 在线编辑 - runjsjs 在线编辑 - jsbinjs 在线编辑 - codepenjs 在线编辑 - jsfiddlejava 在线编辑 - runjsjs 在线编辑 - hchartsjs 在线编辑 - jsdmsql 在线编辑 - sqlfiddlemozilla 在线编辑器21. 播放器Html5 VideoPlayer22. 粒子动画Proton 烟花九. Nodejsnodejs 篇幅比较巨大Node.js 包教不包会篇幅比较少node express 入门教程nodejs定时任务一个nodejs博客【NodeJS 学习笔记04】新闻发布系统过年7天乐，学nodejs 也快乐七天学会NodeJSNodejs学习笔记（二）— 事件模块nodejs入门angularjs nodejs从零开始nodejs系列文章理解nodejsnodejs事件轮询node入门nodejs cmsNode初学者入门，一本全面的NodeJS教程NodeJS的代码调试和性能调优## 十. 性能优化常规优化- Javascript高性能动画与页面渲染- 移动H5前端性能优化指南- 5173首页前端性能优化实践- 给网页设计师和前端开发者看的前端性能优化- 复杂应用的 CSS 性能分析和优化建议- 张鑫旭——前端性能- 前端性能监控总结- 网站性能优化之CSS无图片技术- web前端性能优化进阶路- 前端技术：网站性能优化之CSS无图片技术- 浏览器的加载与页面性能优化- 页面加载中的图片性能优化- Hey——前端性能- html优化- 99css——性能- Yslow——性能优化- YSLOW中文介绍- 转一篇Yahoo关于网站性能优化的文章，兼谈本站要做的优化- Yahoo!团队实践分享：网站性能- 网站性能优化指南：什么使我们的网站变慢？- 网站性能优化实践，减少加载时间，提高用户体验- 浅谈网站性能优化 前端篇- 前端重构实践之如何对网站性能优化？- 前端性能优化：使用媒体查询加载指定大小的背景图片- 网站性能系列博文- 加载，不只是少一点点- 前端性能的测试与优化- 分享网页加载速度优化的一些技巧？- 页面加载中的图片性能优化- web前端优化(基于Yslow)- 网站性能优化工具大全- 【高性能前端1】高性能HTML- 【高性能前端2】高性能CSS- 由12306谈谈网站前端性能和后端性能优化- AlloyTeam——前端优化- 毫秒必争，前端网页性能最佳实践- 网站性能工具Yslow的使用方法- 前端工程与性能优化（上）：静态资源版本更新与缓存- 前端工程与性能优化（下）：静态资源管理与模板框架- HTTPS连接的前几毫秒发生了什么- Yslow- Essential Web Performance Metrics — A Primer, Part 1- Essential Web Performance Metrics — Part 2- YUISlide,针对移动设备的动画性能优化- Improving Site Performance- 让网站提速的最佳前端实践- Why Website Speed is Important- Need for Speed – How to Improve your Website Performance- 阿里无线前端性能优化指南 (Pt.1 加载期优化) - 优化工具- JavaScript 性能分析新工具 OneProfile- JavaScript 堆内存分析新工具 OneHeap在线工具- google在线工具- 阿里测- 阿里-免费测试服务- 阿里-F2etest多浏览器兼容性测试解决方案- js性能测试- 十一. 前端架构技术架构前端架构如何成为前端架构师关于前端架构-张克军百度腾讯offer比较（腾讯游戏VS百度基础架构） 十二. 个人作品 1. 推荐作品 winter代码片段需要翻墙 fgm 岑安作品集 当耐特demo集合 米空格 js作品 myFocus SeaJS组件库 颜海镜作品 脚儿网作品 javascript个人作品 妙味的雷东升游戏作品 javascript作品集 云五笔，灰度产生生成工具 项目主页 个性的作品主页 播放器 ucren js demos 集 智能社 实例陈列架 zoye demo 王员外 平凡 jyg 游戏案例 很多jquery插件 不羁虫 - soJs 作品系列 frozenui 黑白棋 fromone 2. 群员作品 MDialog - [合肥-M.J] 轮播图 - [上海－冷静] [广州—坚壳] [成都 - 无痕] 感恩节专题 [球霸天] [北京-小数] [ptf] Magix 工具 [杭州-Pft] Magix 基于 MVC 结构和 Hash 驱动的 OPOA（One Page One Application）应用 [上海-剧中人]-实验室 [上海-豪情 ] 作品集合 [成都-feeling] [上海-angela] [海南-hank]作品 [上海-张力]博客 [上海-zenki]作品 移动端图案解锁 [合肥-M.J] - MPreview 移动端图片预览组 [合肥-M.J] - Mexam 移动端在线做题组 [北京-苏瑞] - dancer小人 [上海-玄沐]- 个人网站 [厦门-二哲]- 个人博客 3. 国外大牛精品 pazguille 十三. 简历模板 不错的个人简历 简历 张伦 简历 翁天信 动画方式的简历 组件丰富简历 简历池 haorooms博客 Justin Young 十四. 面试题 那几个月在找工作（百度，网易游戏） 2014最新面试题 阿里前端面试题 2016校招内推 – 阿里巴巴前端 – 三面面试经历 腾讯面试题 年后跳槽那点事：乐视+金山+360面试之行 阿里前端面试题上线 拉勾网js面试题 前端面试 Web开发笔试面试题 大全 前端开发面试题 2014最新前端面试题 百度面试 面试题 前端工作面试问题 前端开发面试题 5个经典的前端面试问题 最全前端面试问题及答案总结 如何面试一名前端开发工程师？ 史上最全 前端开发面试问题及答案整理 前端实习生面试总结 史上最全 前端开发面试问题及答案整理 BAT及各大互联网公司2014前端笔试面试题：JavaScript篇 前端开发面试题大收集 收集的前端面试题和答案 如何面试前端工程师 前端开发面试题 牛客网-笔试面经 十五. iconfont 中文字体 淘宝字库 字体 制作教程 zhangxinxu-icommon icommon 用字体在网页中画ICON图标(推荐教程) 字体压缩工具 感谢初级群 [深圳-小鱼] 的推荐 十六. 开发工具类 前端开发工具 IntelliJ IDEA 简体中文专题教程 Webstorm,InterllIdea,Phpstorm SublimeText Atom visual studio codeChrome, Firebug, Filddle 调试FiddlerFiddler调式使用知多少(一)深入研究微信fiddle微信fiddleChromeGoogle Chrome 官方Chrome - 基础Chrome - 进阶Chrome - 性能Chrome - 性能进阶Chrome - 移动Chrome - 使用技巧Chrome - Console控制台不完全指南Chrome - Workspace使浏览器变成IDEnetwork面板chrome开发工具快捷键chrome调试工具常用功能整理Chrome 开发工具 Workspace 使用Chrome神器Vimium快捷键学习记录 sass调试-w3cplus如何更专业的使用Chrome开发者工具-w3cpluschrome调试canvaschrome profiles1chrome profiles2chrome profiles3chrome移动版调试chrome调试chrome的调试chrome console 命令详解查看事件绑定1查看事件绑定2神器——Chrome开发者工具(一)奇趣百科性能优化(Chrome DevTools 中的 Timeline Profils 等工具使用介绍)chrome 开发者工具的 15 个小技巧Chrome开发者工具不完全指南Chrome 开发者工具使用技巧Firebugfirebug视频教程firefox 模拟器console.log 命令详解Firebug入门指南Firebug控制台详解移动,微信调试浏览器端调试安卓移动端前端开发调试使用 Chrome 远程调试 Android 设备mac移动端调试mac移动端调试无线调试攻略无线调试攻略屌爆了,完美调试 微信webview(x5)微信调试的那些事远程console微信调试工具各种真机远程调试方法汇总iOS SimulatorSimulatorXcode中的iOS模拟器(iOS Simulator)的介绍和使用心得img loading img 智图-图片优化平台 在线png优化生成二维码 生成二维码浏览器同步puerliveReloadf5File Watchers在线PPT制作nodePPTPPTrevealslippy十七. 前端导航网站界面清爽的前端导航前端导航前端网址导航前端名录前端导航前端开发资源网址导航前端开发仓库 - 众多效果的收集地 前端资源导航F2E 前端导航十八. 常用CDN新浪CDN百度静态资源公共库360网站卫士常用前端公共库CDN服务Bootstrap中文网开源项目免费 CDN 服务开放静态文件 CDN - 七牛CDN加速 - jq22jQuery CDNGoogle jQuery CDN微软CDN十九. Git,SVN,GithubGit git-scm 廖雪峰-Git教程 git-for-windows GitHub 添加 SSH keys gogithub git常规命令练习 git的资料整理 我所记录的git命令（非常实用） 企业开发git工作流模式探索部分休整 GitHub 漫游指南 GitHub秘籍 使用git和github进行协同开发流程 动画方式练习git]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端性能优化]]></title>
      <url>%2F2017%2F05%2F22%2F%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
      <content type="text"><![CDATA[移动H5前端性能优化指南概述 PC优化手段在Mobile侧同样适用 在Mobile侧我们提出三秒种渲染完成首屏指标 基于第二点，首屏加载3秒完成或使用Loading 基于联通3G网络平均338KB/s(2.71Mb/s)，所以首屏资源不应超过1014KB Mobile侧因手机配置原因，除加载外渲染速度也是优化重点 基于第五点，要合理处理代码减少渲染损耗 基于第二、第五点，所有影响首屏加载和渲染的代码应在处理逻辑中后置 加载完成后用户交互使用时也需注意性能 优化指南 [加载优化]加载过程是最为耗时的过程，可能会占到总耗时的80%时间，因此是优化的重点 · 减少HTTP请求因为手机浏览器同时响应请求为4个请求（Android支持4个，iOS 5后可支持6个），所以要尽量减少页面的请求数，首次加载同时请求数不能超过4个a) 合并CSS、JavaScriptb) 合并小图片，使用雪碧图 · 缓存使用缓存可以减少向服务器的请求数，节省加载时间，所以所有静态资源都要在服务器端设置缓存，并且尽量使用长Cache（长Cache资源的更新可使用时间戳）a) 缓存一切可缓存的资源b) 使用长Cache（使用时间戳更新Cache）c) 使用外联式引用CSS、JavaScript · 压缩HTML、CSS、JavaScript减少资源大小可以加快网页显示速度，所以要对HTML、CSS、JavaScript等进行代码压缩，并在服务器端设置GZipa) 压缩（例如，多余的空格、换行符和缩进）b) 启用GZip · 无阻塞写在HTML头部的JavaScript（无异步），和写在HTML标签中的Style会阻塞页面的渲染，因此CSS放在页面头部并使用Link方式引入，避免在HTML标签中写Style，JavaScript放在页面尾 部或使用异步方式加载 · 使用首屏加载首屏的快速显示，可以大大提升用户对页面速度的感知，因此应尽量针对首屏的快速显示做优化 · 按需加载将不影响首屏的资源和当前屏幕资源不用的资源放到用户需要时才加载，可以大大提升重要资源的显示速度和降低总体流量PS：按需加载会导致大量重绘，影响渲染性能a) LazyLoadb) 滚屏加载c) 通过Media Query加载 · 预加载大型重资源页面（如游戏）可使用增加Loading的方法，资源加载完成后再显示页面。但Loading时间过长，会造成用户流失对用户行为分析，可以在当前页加载下一页资源，提升速度a) 可感知Loading(如进入空间游戏的Loading)b) 不可感知的Loading（如提前加载下一页） · 压缩图片图片是最占流量的资源，因此尽量避免使用他，使用时选择最合适的格式（实现需求的前提下，以大小判断），合适的大小，然后使用智图压缩，同时在代码中用Srcset来按需显示PS：过度压缩图片大小影响图片显示效果a) 使用智图（ http://zhitu.isux.us/ ）b) 使用其它方式代替图片(1. 使用CSS3 2. 使用SVG 3. 使用IconFont)c) 使用Srcsetd) 选择合适的图片(1. webP优于JPG 2. PNG8优于GIF)e) 选择合适的大小（1. 首次加载不大于1014KB 2. 不宽于640（基于手机屏幕一般宽度）） · 减少CookieCookie会影响加载速度，所以静态资源域名不使用Cookie · 避免重定向重定向会影响加载速度，所以在服务器正确设置避免重定向 · 异步加载第三方资源第三方资源不可控会影响页面的加载和显示，因此要异步加载第三方资源 [脚本执行优化]脚本处理不当会阻塞页面加载、渲染，因此在使用时需当注意 · CSS写在头部，JavaScript写在尾部或异步· 避免图片和iFrame等的空Src空Src会重新加载当前页面，影响速度和效率 · 尽量避免重设图片大小重设图片大小是指在页面、CSS、JavaScript等中多次重置图片大小，多次重设图片大小会引发图片的多次重绘，影响性能 · 图片尽量避免使用DataURLDataURL图片没有使用图片的压缩算法文件会变大，并且要解码后再渲染，加载慢耗时长 [CSS优化]· 尽量避免写在HTML标签中写Style属性· 避免CSS表达式CSS表达式的执行需跳出CSS树的渲染，因此请避免CSS表达式 · 移除空的CSS规则空的CSS规则增加了CSS文件的大小，且影响CSS树的执行，所以需移除空的CSS规则 · 正确使用Display的属性Display属性会影响页面的渲染，因此请合理使用a) display:inline后不应该再使用width、height、margin、padding以及floatb) display:inline-block后不应该再使用floatc) display:block后不应该再使用vertical-alignd) display:table-*后不应该再使用margin或者float · 不滥用FloatFloat在渲染时计算量比较大，尽量减少使用 · 不滥用Web字体Web字体需要下载，解析，重绘当前页面，尽量减少使用 · 不声明过多的Font-size过多的Font-size引发CSS树的效率 · 值为0时不需要任何单位为了浏览器的兼容性和性能，值为0时不要带单位 · 标准化各种浏览器前缀a) 无前缀应放在最后b) CSS动画只用 （-webkit- 无前缀）两种即可c) 其它前缀为 -webkit- -moz- -ms- 无前缀 四种，（-o-Opera浏览器改用blink内核，所以淘汰） · 避免让选择符看起来像正则表达式高级选择器执行耗时长且不易读懂，避免使用 [JavaScript执行优化]· 减少重绘和回流a) 避免不必要的Dom操作b) 尽量改变Class而不是Style，使用classList代替classNamec) 避免使用document.writed) 减少drawImage · 缓存Dom选择与计算每次Dom选择都要计算，缓存他 · 缓存列表.length每次.length都要计算，用一个变量保存这个值 · 尽量使用事件代理，避免批量绑定事件· 尽量使用ID选择器ID选择器是最快的 · TOUCH事件优化使用touchstart、touchend代替click，因快影响速度快。但应注意Touch响应过快，易引发误操作 [渲染优化]· HTML使用ViewportViewport可以加速页面的渲染，请使用以下代码 · 减少Dom节点Dom节点太多影响页面的渲染，应尽量减少Dom节点 · 动画优化a) 尽量使用CSS3动画b) 合理使用requestAnimationFrame动画代替setTimeoutc) 适当使用Canvas动画 5个元素以内使用css动画，5个以上使用Canvas动画（iOS8可使用webGL） · 高频事件优化Touchmove、Scroll 事件可导致多次渲染a) 使用requestAnimationFrame监听帧变化，使得在正确的时间进行渲染b) 增加响应变化的时间间隔，减少重绘次数 · GPU加速CSS中以下属性（CSS3 transitions、CSS3 3D transforms、Opacity、Canvas、WebGL、Video）来触发GPU渲染，请合理使用PS：过渡使用会引发手机过耗电增加]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[手写webpack的plugin]]></title>
      <url>%2F2017%2F05%2F08%2F%E6%89%8B%E5%86%99webpack%E7%9A%84plugin%2F</url>
      <content type="text"><![CDATA[经过上一篇博客分析webpack从命令行到打包完成的整体流程，我们知道了webpage的plugin是基于事件机制工作的，这样最大的好处是易于扩展。社区里很多webpack的plugin，但是具体到我们的项目并不一定适用，这篇博客告诉你如何入手写一个plugin，然后分析源码相关部分告诉你你的plugin是如何工作。知其然且知其所以然。该系列博客的所有测试代码。从黑盒角度学习写一个plugin 所谓黑盒，就是先不管webpack的plugin如何运作，只去看官网介绍。 Compiler和Compilation两个类官网介绍告诉我们，plugin涉及到源码中的Compiler类和Compilation类，并对这两个类进行了简要介绍。 Compiler在开始打包时就进行实例化，实例对象里面装着与打包相关的环境和参数，包括options、plugins和loaders等。Compilation在每次文件变化重新打包时都进行一次实例化，它继承自Compiler，其实例对象里装着和modules及chunks相关的信息。如果黑盒角度写plugin，知道这些就行了，没必要非去看源码。这两个对象上挂载的具体内容可以自己打印看看，不赘述。 写一个简单的plugin写plugin大致分为两个步骤： 定义plugin 在webpack.config.js中引用这个plugin定义plugin1234567891011121314151617181920212223242526272829303132333435function HTMLPlugin(options)&#123; // options是配置文件，你可以在这里进行一些与options相关的工作&#125;// 每个plugin都必须定义一个apply方法，webpack会自动调用这个方法HTMLPlugin.prototype.apply = function(compiler)&#123; // apply方法中会传入Compiler的实例compiler // &apos;emit&apos;是该插件监听的事件，插件工作的逻辑在回调函数中 compiler.plugin(&apos;emit&apos;, function(compilation, callback)&#123; // 回掉函数有两个参数 // compilation和下一个回调函数，callback可以不传 // 同步事件不传callback compilation.chunks.forEach(function(chunk)&#123; console.log(&apos;chunk.name&apos;, chunk.name); console.log(&apos;=====================================&apos;); //console.log(&apos;chunk.modules&apos;, chunk.modules.length); chunk.modules.forEach(function(module)&#123; console.log(&apos;module&apos;, module.resource); module.fileDependencies.forEach(function(filepath)&#123; //console.log(&apos;filepath&apos;, filepath); &#125;); &#125;); chunk.files.forEach(function(filename)&#123; let source = compilation.assets[filename].source(); //console.log(&apos;file&apos;, source); &#125;) &#125;); // 最后调用callback callback(); &#125;);&#125;module.exports = HTMLPlugin; 所有可以监听的事件请查看。这里最让人疑惑的是compilation上的modules、chunks、assets，简单解释： compilation.modules，每一个资源文件都会被编译成一个模块， 每个模块module.fileDependencies记录了模块依赖的其它模块compilation.chunks，是entry的每个配置项及调用require.ensure的模块，每个chunk的， chunk.modules为chunk包含的模块以及模块所依赖的模块， chunk.files为每个配置项最后的输出结果文件，这里的值可以从compilation.assets获得compilation.assets，整个打包流程最终要输出的文件这里需要注意，compilation.chunks不仅包括webpack.config.js 中 entry 中配置的模块，还包括模块中使用require.ensure的模块。因为webpack在实现的时候也模仿commonjs规范想实现一个异步加载模块的功能，当使用require.ensure去加载模块时，只有在需要的时候才去下载模块，这可以实现类似懒加载的功能，避免一个页面打包后太大。 例如：1234567891011121314151617// webpack.config.jsentry: &#123; index : &apos;./index.js&apos;, detail: &apos;./detail.js&apos; &#125;// detail.jsrequire(&apos;./src/bundle_require.js&apos;); //bundle_require.js没有依赖// index.js// testTapable.js 和 temp.js都没有依赖require(&apos;./src/tapable/testTapable.js&apos;);let Temp = require.ensure(&apos;./src/plugins/temp.js&apos;, function()&#123; console.log(&apos;temp is loaded&apos;);&#125;, &apos;temp&apos;);let temp = new Temp();console.log(&apos;temp is resolved&apos;); 使用上面插件打包的结果：这里写图片描述 在webpack.config.js中引用这个plugin123456789var HTMLPlugin = require(&apos;./src/plugins/HTMLPlugin&apos;); module.exports = &#123; //插件项 plugins:[ new HTMLPlugin() ], ... &#125; 命令行执行webpack就可以打印出上图的结果。 白盒角度看plugin如何工作从源码分析apply方法到底如何调用，plugin方法到底如何定义一个插件等问题。 plugin的apply方法到底如何调用bin/webapck.js12var webpack = require(&quot;../lib/webpack.js&quot;);compiler = webpack(options); 没什么好解释，去看lib/webpack.js。 lib/webpack.js12345const Compiler = require(&quot;./Compiler&quot;);compiler = new Compiler();if(options.plugins &amp;&amp; Array.isArray(options.plugins)) &#123; compiler.apply.apply(compiler, options.plugins);&#125; 显然compiler有一个apply方法，这里给其传入的参数是插件数组options.plugins。compiler中的apply方法实际是从Tapable中继承来的，所以移步Tapable，可以npm install一下来查看其源码。 Tapable12345Tapable.prototype.apply = function apply() &#123; for(var i = 0; i &lt; arguments.length; i++) &#123; arguments[i].apply(this); &#125;&#125;; 这个方法就是保证执行环境this的情况下依次执行传入参数中的方法，这些方法就是plugin。 plugin方法到底如何定义一个插件 很明显，这个方法在compiler上是有的，其实plugin方法是通过继承Tapable得到的。12345678910Tapable.prototype.plugin = function plugin(name, fn) &#123; if(Array.isArray(name)) &#123; name.forEach(function(name) &#123; this.plugin(name, fn); &#125;, this); return; &#125; if(!this._plugins[name]) this._plugins[name] = [fn]; else this._plugins[name].push(fn);&#125;; 这就是观察者模式中的注册观测者。 可用于监听的事件 可以在官方文档中查看，当然也可以仔细研读Compiler和Comilation两类去理解。例如：123456789101112131415161718192021222324252627Compiler.prototype.compile = function(callback) &#123; var self = this; var params = self.newCompilationParams(); self.applyPluginsAsync(&quot;before-compile&quot;, params, function(err) &#123; if(err) return callback(err); self.applyPlugins(&quot;compile&quot;, params); var compilation = self.newCompilation(params); self.applyPluginsParallel(&quot;make&quot;, compilation, function(err) &#123; if(err) return callback(err); compilation.finish(); compilation.seal(function(err) &#123; if(err) return callback(err); self.applyPluginsAsync(&quot;after-compile&quot;, compilation, function(err) &#123; if(err) return callback(err); return callback(null, compilation); &#125;); &#125;); &#125;); &#125;);&#125;; compile方法是开始打包的一个重要方法，该方法会首先触发before-compile事件，也就是打包前需要干的事情，由一系列插件完成，然后触发compile事件，然后触发make事件，开始构建依赖关系。 总结我们了解了webpack的几个重要类及基本事件流程，通过这篇博客查看官网关于如何写plugin的介绍我们从黑盒角度知道了写plugin的基本步骤，对应webpack的工作流程就可以轻松从白盒角度总结出plugin的工作原理。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vue知识点]]></title>
      <url>%2F2017%2F04%2F27%2Fvue%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
      <content type="text"><![CDATA[vue是什么？vue也是一个数据驱动框架，做spa页面的vue如果不做页面可以当做一个单独使用的js库，做双向数据绑定用Vue的核心库只关注视图层,但是vue并不只关注视图，和angular一样也有指令，过滤器这些东西vue有非常强大的单文件组件就是css+html+js都写在一个.vue文件中，这样定义的组件很简洁，清晰，组件化分的很彻底而angular中的js文件只能写js虽然react中可以写css-in-js，但是缺乏选择器功能，即便可以在js中引入css文件，但还是不方便vue融合了react和angular的优点，并且解决了react和angualr的痛点 vue学习地址和技术栈Vue2.0中文网：vue全家桶变为vue2.0+vue-router+fetch+vuex我们下文中所出现的vue都指代vue2.0vue和其他框架的对比 vue比市面上的其他框架功能更完善，性能更高效 vue快速开始用vue-cli开始 12345678# 全局安装 vue-cli$ npm install --global vue-cli# 创建一个基于 webpack 模板的新项目$ vue init webpack my-project# 安装依赖，走你$ cd my-project$ npm install$ npm run dev 你只需要关注你配置的东西就可以了，不需要关注webpack的配置项，因为webpack的配置很难，很多人不会，也是为了简便开发自己创建Vue的开发环境 准备工作升级webstorm到最新版本，老版本对.vue文件的开发是有bug的下载webstorm为Vue提供的插件vue-for-idea，这个插件可以让webstorm支持以.vue结尾的文件能够运行下载vuenpm install vue -save下载编译模块npm install vue-template-compiler -savesrc/js文件中创建main.js123456789101112import Vue from &apos;vue&apos;import AppContainer from &apos;../containers/AppContainer&apos;const app = new Vue(&#123; render: h =&gt; h(AppContainer),&#125;).$mount(&apos;#app&apos;)// new Vue(&#123;// el:&apos;#app&apos;,// render: h =&gt; h(App)// &#125;) 在src/container中创建AppContainer.vue文件12345678910111213141516171819&lt;template&gt; &lt;div&gt; &#123;&#123;msg&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; body&#123; background-color:#ff0000; &#125;&lt;/style&gt;&lt;script&gt; export default&#123; data()&#123; return&#123; msg:&apos;hello vue&apos; &#125; &#125; &#125;&lt;/script&gt; 当你第一次创建.vue文件的时候IDE会问你用什么语法去解析，你选择html语法接下来就可以直接运行npm run develop了你可以去google中搜索vue-devtools下载并安装，用于帮你监听组件的data属性变化 vue中的基础知识点Vue实例 属性与方法我们自定义的一些数据和方法是要绑定到实例的不同属性上面去的例如数据都要绑定要data属性，方法都要绑定到methods方法实例上的data和methods里面的key值会自动挂载到vue实例上，我们管他们叫动态属性，获取方式直接使实例.动态属性名vue实例上的实例属性要通过实例.$实例属性名获取在vue实例里面用this，this指向的是vue实例可以通过this.a去获取动态属性可以通过this.$data去获取实例属性实例上有一个$watch方法可以监听data属性里面的数据的变化，data一变会自动触发监听事件的执行12345678910111213141516171819202122232425262728293031var data = &#123;a: 1&#125; const app = new Vue(&#123; // 和数据相关的都挂载到data上 data: data, // 和方法相关的都挂载到methods上 methods: &#123; // this和$的使用 func1: function () &#123; console.log(this.a); console.log(this.$data.a); &#125;, changeData:function () &#123; this.a=2 &#125; &#125; &#125;) // 先监听再改变 app.$watch(&apos;a&apos;, function (newVal, oldVal) &#123; console.log(newVal) console.log(oldVal) &#125;) // 值改变之后会自动执行监听方法 // data的值是可以直接改变的，和react的setState方法不一样，因为vue里面用了set和get方法，可以起到自动监听的作用 app.a=3 // 动态属性和实例属性// console.log(app)// console.log(app.a)// console.log(app.$data.a) 实例生命周期和react的生命周期基本思想是一样的只不过react中是监听props和state属性的变化而在vue中是只监听data属性的变化vue中的生命周期函数要比react中的方法多这些生命周期方法只能在spa应用中起作用，单独作为双向数据绑定库无法生效vue生命周期图 模板语法就是如何在.vue文件的template标签中书写内容 v-once指令只会执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上所有的数据绑定：v-html会按照html规则去解析内容我们在为标签的属性赋值的时候不能Mustache语法，我们要用v-bind指令v-bind绑定的属性必须是data属性里面定义的值，如果想写固定的值加单引号1234// 错误的写法&lt;div id=&quot;&#123;&#123;id&#125;&#125;&quot;&gt;&lt;/div&gt;// 正确的写法&lt;div v-bind:id=&quot;id&quot;&gt;&lt;/div&gt; 在Mustache中可以处理一些简单的js表达式，Mustache中的属性本身有什么方法，在里面也是可以直接使用的1234&#123;&#123; number + 1 &#125;&#125;&#123;&#123; ok ? &apos;YES&apos; : &apos;NO&apos; &#125;&#125;&#123;&#123; message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125;&#125;&lt;div v-bind:id=&quot;&apos;list-&apos; + id&quot;&gt;&lt;/div&gt; 在Mustache中可以使用自定义过滤器，也可以多过滤器串联。但是过滤器不能用在v-bind中，如果想实现相同的效果在v-bind中我们要用计算属性1234567891011121314&#123;&#123; message | capitalize &#125;&#125;&#123;&#123; message | filterA | filterB &#125;&#125;new Vue(&#123; // ... filters: &#123; capitalize: function (value) &#123; if (!value) return &apos;&apos; value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) &#125; &#125;&#125;) 在dom标签中可以使用指令，如v-if，v-for1&lt;a v-on:click=&quot;doSomething&quot;&gt; 在dom的事件中可以使用修饰符去帮你简化一些操作1&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt; v-bind和v-on在模板语法中可以缩写12345678//完整语法&lt;a v-bind:href=&quot;url&quot;&gt;&lt;/a&gt;//缩写&lt;a :href=&quot;url&quot;&gt;&lt;/a&gt;//完整语法&lt;a v-on:click=&quot;doSomething&quot;&gt;&lt;/a&gt;// 缩写&lt;a @click=&quot;doSomething&quot;&gt;&lt;/a&gt; 计算属性计算属性可以处理模板语法中的复杂业务逻辑，跟Mustache语法比计算属性 vs methods 我们看到计算属性和methods的效果基本你一样，那么他们的区别是什么？计算属性的依赖如果没有发生变化，当你再次调用计算属性的时候，能够立即返回上次缓存的计算值，而不需要从新执行计算属性的方法而方法需要从新执行方法体样例1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;div&gt; &lt;p&gt;Original message: &quot;&#123;&#123; message &#125;&#125;&#123;&#123;name&#125;&#125;&quot;&lt;/p&gt; &lt;p&gt;Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;&lt;/p&gt; &lt;p&gt;Computed reversed message: &quot;&#123;&#123; reverseMessage() &#125;&#125;&quot;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; body&#123; background-color:#ff0000; &#125;&lt;/style&gt;&lt;script&gt; export default&#123; data()&#123; return&#123; message: &apos;Hello&apos;, name:&apos;a&apos; &#125; &#125;, mounted()&#123; this.name=&quot;b&quot; &#125;, computed: &#123; reversedMessage: function () &#123; console.log(&apos;计算属性被调用了&apos;) return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125; &#125;, methods: &#123; reverseMessage: function () &#123; console.log(&apos;方法被执行了&apos;) return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125; &#125; &#125;&lt;/script&gt; 计算属性 vs watch watch方法每次只能监听一个data值的变化而计算属性可以同时监听多个data值的变化用计算属性可以简化watch中重复的代码123456789101112131415161718192021222324252627282930313233&lt;!--页面--&gt;&lt;div id=&quot;demo&quot;&gt;&#123;&#123; fullName &#125;&#125;&lt;/div&gt; //watch写法 var vm = new Vue(&#123; el: &apos;#demo&apos;, data: &#123; firstName: &apos;Foo&apos;, lastName: &apos;Bar&apos;, fullName: &apos;Foo Bar&apos; &#125;, watch: &#123; firstName: function (val) &#123; this.fullName = val + &apos; &apos; + this.lastName &#125;, lastName: function (val) &#123; this.fullName = this.firstName + &apos; &apos; + val &#125; &#125; &#125;) //计算属性的写法 //本质是你要获取全名 var vm = new Vue(&#123; el: &apos;#demo&apos;, data: &#123; firstName: &apos;Foo&apos;, lastName: &apos;Bar&apos; &#125;, computed: &#123; fullName: function () &#123; return this.firstName + &apos; &apos; + this.lastName &#125; &#125; &#125;) 计算setter 计算属性默认是只有getter的，那么data属性里面你的值发生改变了，计算属性要从新执行而setter的作用是调用计算属性的时候给一个初始值，那么data属性里面的值也会跟着做相应的改变123456789101112131415// 接上面的代码段computed: &#123; fullName: &#123; // getter get: function () &#123; return this.firstName + &apos; &apos; + this.lastName &#125;, // setter set: function (newValue) &#123; var names = newValue.split(&apos; &apos;) this.firstName = names[0] this.lastName = names[names.length - 1] &#125; &#125;&#125; vue实例上的观察watch还是很有用的，在进行执行异步操作或昂贵操作时，我们要用watch这个实例属性因为你不要忘记计算属性出现的原因是为了解决mustache语法中有过多的逻辑操作问题，它只能进行一些小型操作的内容Class与Style绑定 绑定要用v-bind:class和:bind:stylev-bind:class指令可以与普通的class属性共存绑定的时候可以给对象，可以个数组，还可以有条件判断和三元表达式条件渲染 v-if和v-else只能控制一个标签的渲染，而且v-else要紧跟着v-if如果想要控制一部分标签的渲染，需要用标签包裹，v-if作用在template标签上v-show也可以控制标签的显示隐藏，不过只是简单的切换样式v-show的元素会始终渲染并保持在 DOM 中，v-if的元素会被移除注意 v-show 不支持 语法v-if是惰性的，只有在条件第一次为true的时候才进行局部渲染吧v-if有更高的切换消耗，v-show有更高的初始渲染消耗。因此如果需要频繁切换使用v-show较好，如果在运行时条件不大可能改变则使用v-if较好。列表渲染 v-for是vue中做循环的，值可以给数组，对象，数值三种类型可以用of替换in如果想循环渲染一部分标签，要用template标签包裹，v-for作用在template标签上在循环渲染引入的自定义组件的时候要手动为组件传递item的属性值1234567&lt;my-components is=&quot;todo-item&quot; v-for=&quot;(item, index) in todos&quot; v-bind:title=&quot;item&quot; v-on:remove=&quot;item.splice(index, 1)&quot;&gt;&lt;/my-components&gt; 在循环渲染的时候要动态的绑定v-bind:key,这样可以提升vue的渲染效率Vue 包含一组观察数组的变异方法，只要调用它们将会触发视图更新，并且改变了原数组push() pop() shift() unshift() splice() sort() reverse()重塑数组不会改变原来的数据，而是返回一个改变之后的新数据filter(), concat(), slice()重塑数组一般是赋值用，这样才能触发vue的重新渲染，而你并不需要担心性能问题，因为vue会智能的重用数组由于JavaScript 的限制，Vue不能检测以下变动的数组：当你直接设置一个项的索引时，例如： vm.items[indexOfItem] = newValue用Vue.set解决当你修改数组的长度时，例如： vm.items.length = newLength用splice解决v-for结合计属性或者methods时可以做数据的过滤和排序123456789101112// &lt;li v-for=&quot;n in evenNumbers&quot;&gt;&#123;&#123; n &#125;&#125;&lt;/li&gt;data: &#123; numbers: [ 1, 2, 3, 4, 5 ]&#125;,computed: &#123; evenNumbers: function () &#123; return this.numbers.filter(function (number) &#123; return number % 2 === 0 &#125;) &#125;&#125; 事件处理器在v-on:click的时候想既传递参数又想传递事件对象，那么你需要手动传入$event参数12345678&lt;button v-on:click=&quot;warn(&apos;Form cannot be submitted yet.&apos;, $event)&quot;&gt;Submit&lt;/button&gt;methods: &#123; warn: function (message, event) &#123; // 现在我们可以访问原生事件对象 if (event) event.preventDefault() alert(message) &#125;&#125; 常用事件修饰符1234567891011121314&lt;!-- 阻止单击事件冒泡 --&gt;&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;&lt;!-- 修饰符可以串联 --&gt;&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;&lt;!-- 只有修饰符 --&gt;&lt;form v-on:submit.prevent&gt;&lt;/form&gt;&lt;!-- 添加事件侦听器时使用时间捕获模式 --&gt;&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;&lt;!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 --&gt;&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;&lt;!-- the click event will be triggered at most once --&gt;&lt;a v-on:click.once=&quot;doThis&quot;&gt;&lt;/a&gt; 常见的按键修饰符12345678910111213141516171819202122232425&lt;!-- 只有在 keyCode 是 13 时调用 vm.submit() --&gt;&lt;input v-on:keyup.13=&quot;submit&quot;&gt;&lt;!-- 同上 --&gt;&lt;input v-on:keyup.enter=&quot;submit&quot;&gt;&lt;!-- 缩写语法 --&gt;&lt;input @keyup.enter=&quot;submit&quot;&gt;&lt;!--全部的按键别名：--&gt; enter tab delete (捕获 “删除” 和 “退格” 键) esc space up down left right ctrl alt shift meta通过全局 config.keyCodes自定义按键修饰符别名,记住要在new新实例之前注册// 可以使用 v-on:keyup.f1Vue.config.keyCodes.f1 = 112 表单控件绑定表单的双向绑定用v-model指令在文本区域插值并不会生效，应用v-model来代替单个复选按钮绑定的是选中状态，多个复选按钮绑定的是值列表没有value值绑定的是标签内容，有value值绑定的就是value值如果想让表单的value属性绑定到Vue实例的动态属性上，需要用v-bind:value绑定1&lt;input type=&quot;radio&quot; v-model=&quot;pick&quot; v-bind:value=&quot;a&quot;&gt; .lazy修饰符可以实现单向数据绑定12&lt;!-- 在 &quot;change&quot; 而不是 &quot;input&quot; 事件中更新 --&gt;&lt;input v-model.lazy=&quot;msg&quot; &gt; 组件 组件可以扩展 HTML 元素，封装可重用的代码。在较高层面上，组件是自定义元素， Vue.js 的编译器为它添加特殊功能。在有些情况下，组件也可以是原生 HTML 元素的形式，以 is 特性扩展。组件是类似于angualr中自定义指令，是vue中的一种自定义标签相当于react中的通用组件，高可复用性的（例如：列表，按钮，等待器）组件的使用 全局注册组件全局组件的定义一定要在创建根实例之前在全局注册的组件可以在子组件的页面中随意使用1234567Vue.component(&apos;soupfree&apos;, &#123; template: &apos;&lt;div&gt;汤免费&lt;/div&gt;&apos; &#125;) const app = new Vue(&#123; el:&apos;#example&apos; &#125;) 局部注册组件在要使用的组价中增加components属性，注册引入的组件并改名，之后才可以在html代码中使用一般局部注册的组件都是通过.vue文件实现的1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;template&gt; &lt;div&gt; 姓名：汤免费，年龄：&#123;&#123;age&#125;&#125;,性别：&#123;&#123;genderSex&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;style scope&gt; div&#123; background-color:orange; &#125;&lt;/style&gt;&lt;script&gt; export default&#123; data()&#123; return&#123; &#125; &#125;, props:[&apos;age&apos;,&apos;genderSex&apos;] &#125;&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;soup-free&gt;&lt;/soup-free&gt; &#123;&#123;msg&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;style&gt; body&#123; background-color:#ff0000; &#125;&lt;/style&gt;&lt;script&gt; import soupfree from &apos;../components/soupfree.vue&apos; export default&#123; data()&#123; return&#123; msg:&apos;hello vue&apos; &#125; &#125;, components:&#123; &apos;soup-free&apos;:soupfree &#125; &#125;&lt;/script&gt; Dom模板解析问题当你在一些特殊标签如table，ul，ol，select中使用自定义组件的时候会有一些限制 例如123&lt;table&gt; &lt;my-row&gt;...&lt;/my-row&gt;&lt;/table&gt; 因为Vue只有在浏览器解析和标准化HTML后才能获取模版内容再准确的说也就是用Vue.component方法自定义的组件is特性可以解决这个问题123&lt;table&gt; &lt;tr is=&quot;my-row&quot;&gt;&lt;/tr&gt;&lt;/table&gt; 应当注意，如果您使用来自以下来源之一的字符串模板，这些限制将不适用：1&lt;script type=&quot;text/x-template&quot;&gt; 因为这里面的代码是内连载页面中的JavaScript内联模版字符串这个就是template属性.vue 组件在webpack构建的时候就已经处理了组件内容为html了因此，有必要的话请使用字符串模版。☆在自定义组件中data属性必须是函数形式☆ 也就是在Vue.component中和.vue文件中的data属性如果是父子组件，那么父组件向子组件传递参数用props,子组件向父组件传递参数用$emit广播props属性 参数在传递的过程中，父组件传递参数用kebab-case（短横线隔开），在子组件接收的时候用camelCase如果传递的属性来自父组件的data属性，也就是向子组件传递动态属性那么需要用v-bind去传递如何传递的属性类型是数值型，那么也需要用v-bind去传递把 ☆注意在JavaScript中对象和数组是引用类型，指向同一个内存空间，如果prop是一个对象或数组，在子组件内部改变它会影响父组件的状态。注意一般情况下不要在子组件中改变父组件中传递过来的props，但是有两种特殊情况会改变我们在传递属性的时候可以做属性校验当prop验证失败了,Vue将拒绝在子组件上设置此值，如果使用的是开发版本会抛出一条警告。自定义事件 用v-on去绑定自定义事件使用$on(eventName)监听事件使用$emit(eventName)触发事件在自定义组件上是不可以用v-model指令，但是这个效果可以通过自定义组件在内部用自定义事件模拟实现1234567891011121314151617181920212223242526272829Vue.component(&apos;currency-input&apos;, &#123; template: &apos;\ &lt;span&gt;\ $\ &lt;input\ ref=&quot;input&quot;\ v-bind:value=&quot;value&quot;\ v-on:input=&quot;updateValue($event.target.value)&quot;\ &gt;\ &lt;/span&gt;\ &apos;, props: [&apos;value&apos;], methods: &#123; // 不是直接更新值，而是使用此方法来对输入值进行格式化和位数限制 updateValue: function (value) &#123; var formattedValue = value // 删除两侧的空格符 .trim() // 保留 2 小数位 .slice(0, value.indexOf(&apos;.&apos;) + 3) // 如果值不统一，手动覆盖以保持一致 if (formattedValue !== value) &#123; this.$refs.input.value = formattedValue &#125; // 通过 input 事件发出数值 this.$emit(&apos;input&apos;, Number(formattedValue)) &#125; &#125;&#125;) 兄弟组件之间的通信可以通过bus中央事件总线实现但是更复杂的数据通信最好还是用vuex123456789// 在根组件中注册bus属性const app = new Vue(&#123; data:&#123; bus:new Vue() &#125;, render: h =&gt; h(AppContainer),&#125;).$mount(&apos;#app&apos;)// 在子组件中使用this.$root.bus.$emit(&apos;eventName&apos;,2323) slot分发 在自定义组件使用的时候，如果页面中有内容，又想让内容在自定义组件中使用，我们需要养slot标签slot标签在一个html标签中只能出现一次作用域插槽是一种特殊类型的插槽，用作使用一个（能够传递数据到）可重用模板替换已渲染元素。通俗的说就是子组件里面的数据可以通过作用域插槽用在父组件页面中的指定区域内动态组件 组件可以通过is特性动态加载你可以用keep-alive指令缓存组件杂项 你可以通过ref属性标记一个组件，之后可以用this.$refs.标记的名称或得到该组件当ref和v-for一起使用时，ref是一个数组或对象，包含相应的子组件。$refs只在组件渲染完成后才填充，并且它是非响应式的。它仅仅作为一个直接访问子组件的应急方案——应当避免在模版或计算属性中使用$refs 组件的异步加载组件命名规范组件的递归调用组件上的name属性还是这个组件在全局注册时候的名字1&lt;unique-name-of-my-component name=&quot;unique-name-of-my-component&quot;&gt;&lt;/unique-name-of-my-component&gt; 组件的循环引用Vue.component全局注册组件后，这个问题会自动解决，你要做的就是在写代码的时候不要出现组件循环引用内联模板 通俗的说就是在定义组件的时候不用给template属性了x-Templates]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[常用设计素材网站]]></title>
      <url>%2F2017%2F04%2F20%2F%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E7%B4%A0%E6%9D%90%E7%BD%91%E7%AB%99%2F</url>
      <content type="text"><![CDATA[花瓣 阿里巴巴矢量图标库 pinterest 站酷 easyicon 千图网]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[用户体验设计]]></title>
      <url>%2F2017%2F04%2F20%2F%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E8%AE%BE%E8%AE%A1%2F</url>
      <content type="text"><![CDATA[用户体验设计 腾讯用户体验设计 网易用户体验设计 网易游戏设计中心]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[gulp构建]]></title>
      <url>%2F2017%2F04%2F20%2Fgulp%E6%9E%84%E5%BB%BA%2F</url>
      <content type="text"><![CDATA[入门指南1. 全局安装 gulp：1$ npm install --global gulp 2. 作为项目的开发依赖（devDependencies）安装：1$ npm install --save-dev gulp 3. 在项目根目录下创建一个名为 gulpfile.js 的文件：12345var gulp = require(&apos;gulp&apos;);gulp.task(&apos;default&apos;, function() &#123; // 将你的默认的任务代码放在这&#125;); 4. 运行 gulp：1$ gulp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116var gulp = require(&apos;gulp&apos;);var browserSync = require(&apos;browser-sync&apos;);// 引入组件var jshint = require(&apos;gulp-jshint&apos;);var sass = require(&apos;gulp-sass&apos;);// 编译Sassvar concat = require(&apos;gulp-concat&apos;);var uglify = require(&apos;gulp-uglify&apos;);var rename = require(&apos;gulp-rename&apos;);var connect = require(&apos;gulp-connect&apos;); //自动刷新服务var rev = require(&apos;gulp-rev&apos;);//加MD5后缀var revReplace = require(&apos;gulp-rev-replace&apos;);//替换引用的加了md5后缀的文件名，修改过，用来加cdn前缀var minifyHtml = require(&apos;gulp-minify-html&apos;); //压缩htmlvar minifyCss = require(&apos;gulp-minify-css&apos;);var gulpif = require(&apos;gulp-if&apos;);var cssver = require(&apos;gulp-make-css-url-version&apos;); //css urlvar imagemin = require(&apos;gulp-imagemin&apos;);var pngquant = require(&apos;imagemin-pngquant&apos;); //png图片压缩插件var spritesmith = require(&apos;gulp-spritesmith&apos;);var spriter=require(&apos;gulp-css-spriter&apos;);var condition = true;var paths = &#123; scripts: &apos;./app/js/*.js&apos;,//js存放 scss:&apos;./app/css/scss/*.scss&apos;,//scss存放 css:&apos;./app/css/*.css&apos;,//看守的css目录 cssScss:&apos;./app/css&apos;,//压缩sass存放的css目录 minCss:&apos;./app/css/minCss&apos;,//压缩的minicss rootJs:&apos;./dist/js&apos;, //打包后js rootCss:&apos;./dist/css&apos;,//打包后css minHtml:&apos;./dist&apos;,//打包后html&#125;;// 检查脚本gulp.task(&apos;lint&apos;, function() &#123; return gulp.src(paths.scripts) .pipe(jshint()) .pipe(jshint.reporter(&apos;default&apos;));&#125;);// 编译Sassgulp.task(&apos;sass&apos;, function() &#123; gulp.src(paths.scss) .pipe(sass()) .pipe(gulp.dest(paths.cssScss));&#125;);// 合并，压缩文件gulp.task(&apos;scripts&apos;, function() &#123; gulp.src(paths.scripts) .pipe(concat(&apos;app.js&apos;)) .pipe(gulp.dest(paths.rootJs)) .pipe(rename(&apos;app.min.js&apos;)) .pipe(uglify()) .pipe(gulp.dest(paths.rootJs));&#125;);//浏览器监听刷新gulp.task(&apos;reload&apos;,function()&#123; gulp.src(&apos;./*.html&apos;).pipe(connect.reload());&#125;);//服务器自动刷新gulp.task(&apos;connect&apos;,function()&#123; connect.server(&#123; port:3000, livereload:true &#125;)&#125;)//压缩Html/更新引入文件版本gulp.task(&apos;miniHtml&apos;, function () &#123; return gulp.src(&apos;./*.html&apos;) //.pipe(revCollector()) .pipe(gulpif( condition, minifyHtml(&#123; empty: true, spare: true, quotes: true &#125;) )) .pipe(gulp.dest(paths.minHtml));&#125;);//压缩/合并CSSgulp.task(&apos;miniCss&apos;, function () &#123; gulp.src(paths.css) .pipe(minifyCss(&#123; advanced: false,//类型：Boolean 默认：true [是否开启高级优化（合并选择器等）] compatibility: &apos;ie7&apos;,//保留ie7及以下兼容写法 类型：String 默认：&apos;&apos;or&apos;*&apos; [启用兼容模式； &apos;ie7&apos;：IE7兼容模式，&apos;ie8&apos;：IE8兼容模式，&apos;*&apos;：IE9+兼容模式] keepBreaks: true,//类型：Boolean 默认：false [是否保留换行] keepSpecialComments: &apos;*&apos; //保留所有特殊前缀 当你用autoprefixer生成的浏览器前缀，如果不加这个参数，有可能将会删除你的部分前缀 &#125;)) .pipe(cssver()) .pipe(gulp.dest(paths.minCss));&#125;);gulp.task(&apos;minImage&apos;, function () &#123; return gulp.src(&apos;./app/images/*&apos;) .pipe(imagemin(&#123; progressive: true, use: [pngquant()] //使用pngquant来压缩png图片 &#125;)) .pipe(gulp.dest(&apos;./dist/images&apos;));&#125;);gulp.task(&apos;sprite&apos;,function()&#123; var timestamp =+ new Date(); //需要自动合并雪碧图的样式文件 return gulp.src(&apos;./app/css/*.css&apos;) .pipe(spriter(&#123; //生成的spriter的位置 &apos;spriteSheet&apos;:&apos;./dist/images/sprite/sprite&apos;+timestamp+&apos;.png&apos;, //生成样式文件图片引用地址的路径 //如下将生产：backgound:url(../images/sprite20324232.png) &apos;pathToSpriteSheetFromCSS&apos;:&apos;../images/sprite&apos;+timestamp+&apos;.png&apos; &#125;)) .pipe(minifyCss()) //产出路径 .pipe(gulp.dest(&apos;./dist/css/sprite&apos;));&#125;);//监听文件状态gulp.task(&apos;watch&apos;, function() &#123; gulp.watch(&quot;./*.html&quot;,[&apos;reload&apos;]);&#125;);gulp.task(&apos;default&apos;,[&apos;watch&apos;,&apos;scripts&apos;,&apos;sass&apos;,&apos;lint&apos;,&apos;connect&apos;,&apos;miniHtml&apos;,&apos;miniCss&apos;,&apos;minImage&apos;,&apos;sprite&apos;]);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端功能代码块]]></title>
      <url>%2F2017%2F04%2F17%2F%E5%89%8D%E7%AB%AF%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81%E5%9D%97%2F</url>
      <content type="text"><![CDATA[摇一摇123456789101112131415161718192021222324var speed = 15;//摇动速度var flag=true;var x = y = z = lastX = lastY = lastZ = 0;$(function()&#123; if(window.DeviceMotionEvent) &#123; window.addEventListener(&apos;devicemotion&apos;, shakeHandler, false); &#125;&#125;);function shakeHandler(event)&#123; var acceleration =event.accelerationIncludingGravity;//将传感值赋给acceleration x = acceleration.x; y = acceleration.y; z = acceleration.z; if(Math.abs(x-lastX) &gt; speed || Math.abs(y-lastY) &gt; speed ) &#123; if(flag==true)&#123; flag=false; &#125; &#125; lastX = x; lastY = y; lastZ = z;&#125; 计算rem123456789101112(function (doc, win) &#123; var docEl = doc.documentElement, resizeEvt = &apos;orientationchange&apos; in window ? &apos;orientationchange&apos; : &apos;resize&apos;, recalc = function () &#123; var clientWidth = docEl.clientWidth; if (!clientWidth) return; docEl.style.fontSize = 20 * (clientWidth / 320) + &apos;px&apos;; &#125;; if (!doc.addEventListener) return; win.addEventListener(resizeEvt, recalc, false); doc.addEventListener(&apos;DOMContentLoaded&apos;, recalc, false);&#125;)(document, window); 禁止连续点击123456789101112131415161718192021checkscroll();function checkscroll()&#123; var agent = navigator.userAgent.toLowerCase(); //检测是否是ios var iLastTouch = null; //缓存上一次tap的时间 if (agent.indexOf(&apos;iphone&apos;) &gt;= 0 || agent.indexOf(&apos;ipad&apos;) &gt;= 0) &#123; document.body.addEventListener(&apos;touchend&apos;, function(event) &#123; var iNow = new Date() .getTime(); iLastTouch = iLastTouch || iNow + 1 /** 第一次时将iLastTouch设为当前时间+1 */ ; var delta = iNow - iLastTouch; if (delta &lt; 500 &amp;&amp; delta &gt; 0) &#123; event.preventDefault(); return false; &#125; iLastTouch = iNow; &#125;, false); &#125;&#125; node删除文件遍历文件12345678910111213141516//遍历文件const deleteFolder = function(path) &#123; let files = [] if(fs.existsSync(path)) &#123; files = fs.readdirSync(path) files.forEach(function(file,index)&#123; let curPath = path + &quot;/&quot; + file if(fs.statSync(curPath).isDirectory()) &#123; // recurse deleteFolder(curPath) &#125; else &#123; // delete file fs.unlinkSync(curPath) &#125; &#125;); fs.rmdirSync(path) &#125;&#125; 执行系统命令1234var exec = require(&apos;child_process&apos;).exec,child;child = exec(&apos;rm -rf test&apos;,function(err,out) &#123; console.log(out); err &amp;&amp; console.log(err);&#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[正则]]></title>
      <url>%2F2017%2F04%2F17%2F%E6%AD%A3%E5%88%99%2F</url>
      <content type="text"><![CDATA[1 . 校验密码强度密码的强度必须是包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间。 ^(?=.\d)(?=.[a-z])(?=.*[A-Z]).{8,10}$ 2. 校验中文字符串仅能是中文。 ^[\u4e00-\u9fa5]{0,}$ 3. 由数字、26个英文字母或下划线组成的字符串^\w+$ 4. 校验E-Mail 地址同密码一样，下面是E-mail地址合规性的正则检查语句。 [\w!#$%&amp;’+/=?^_`{|}~-]+(?:.[\w!#$%&amp;’+/=?^_`{|}~-]+)@(?:[\w](?:[\w-][\w])?.)+\w? 5. 校验身份证号码下面是身份证号码的正则校验。15 或 18位。 15位： ^[1-9]\d{7}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{3}$18位： ^[1-9]\d{5}[1-9]\d{3}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{3}([0-9]|X)$ 6. 校验日期“yyyy-mm-dd“ 格式的日期校验，已考虑平闰年。 ^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$ 7. 校验金额金额校验，精确到2位小数。 ^[0-9]+(.[0-9]{2})?$ 8. 校验手机号下面是国内 13、15、18开头的手机号正则表达式。（可根据目前国内收集号扩展前两位开头号码） ^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$ 9. 判断IE的版本IE目前还没被完全取代，很多页面还是需要做版本兼容，下面是IE版本检查的表达式。 ^.MSIE 5-8?(?!.Trident\/[5-9].0).*$ 10. 校验IP-v4地址IP4 正则语句。 \b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b 11. 校验IP-v6地址IP6 正则语句。 (([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])) 12. 检查URL的前缀应用开发中很多时候需要区分请求是HTTPS还是HTTP，通过下面的表达式可以取出一个url的前缀然后再逻辑判断。 if (!s.match(/^[a-zA-Z]+:\/\//)){ s = ‘http://‘ + s;} 13. 提取URL链接下面的这个表达式可以筛选出一段文本中的URL。 ^(f|ht){1}(tp|tps):\/\/([\w-]+.)+[\w-]+(\/[\w- ./?%&amp;=]*)? 14. 文件路径及扩展名校验验证windows下文件路径和扩展名（下面的例子中为.txt文件） ^([a-zA-Z]\:|\)\([^\]+\)[^\/:?”&lt;&gt;|]+.txt(l)?$ 15. 提取Color Hex Codes有时需要抽取网页中的颜色代码，可以使用下面的表达式。 ^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$ 16. 提取网页图片假若你想提取网页中所有图片信息，可以利用下面的表达式。 \&lt; [img][^\&gt;][src] = [\”\’]{0,1}([^\”\’\ &gt;]*) 17. 提取页面超链接提取html中的超链接。 (])(href=”https?:\/\/)((?!(?:(?:www.)?’.implode(‘|(?:www.)?’, $follow_list).’))[^”]+)”((?!.\brel=)[^&gt;])(?:[^&gt;])&gt; 18. 查找CSS属性通过下面的表达式，可以搜索到相匹配的CSS属性。 ^\s[a-zA-Z-]+\s[:]{1}\s[a-zA-Z0-9\s.#]+[;]{1} 19. 抽取注释如果你需要移除HMTL中的注释，可以使用如下的表达式。 20. 匹配HTML标签通过下面的表达式可以匹配出HTML中的标签属性。 &lt;\/?\w+((\s+\w+(\s=\s(?:”.?”|’.?’|[\^’”&gt;\s]+))?)+\s|\s)\/?&gt; Item Value 元字符 描述 \ 将下一个字符标记符、或一个向后引用、或一个八进制转义符。例如，“\n”匹配\n。“\n”匹配换行符。序列“\”匹配“\”而“(”则匹配“(”。即相当于多种编程语言中都有的“转义字符”的概念。 ^ 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\n”或“\r”之后的位置。 $ 匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\n”或“\r”之前的位置。 * 匹配前面的子表达式任意次。例如，zo能匹配“z”，“zo”以及“zoo”，但是不匹配“bo”。等价于{0,}。 + 匹配前面的子表达式一次或多次(大于等于1次）。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。 ? 匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“do”或“does”中的“do”。?等价于{0,1}。 {n} n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。 {n,} n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。 {n,m} m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。 ? 当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。 .点 匹配除“\r\n”之外的任何单个字符。要匹配包括“\r\n”在内的任何字符，请使用像“[\s\S]”的模式。 (pattern) 匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“(”或“)”。 (?:pattern) 非获取匹配，匹配pattern但不获取匹配结果，不进行存储供以后使用。这在使用或字符“(丨)”来组合一个模式的各个部分是很有用。例如“industr(?:y丨ies)”就是一个比“industry丨industries”更简略的表达式。 (?=pattern) 非获取匹配，正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如，“Windows(?=95丨98丨NT丨2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?!pattern) 非获取匹配，正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如“Windows(?!95丨98丨NT丨2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。 (?&lt;=pattern) 非获取匹配，反向肯定预查，与正向肯定预查类似，只是方向相反。例如，“(?&lt;=95丨98丨NT丨2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。 (?&lt;!pattern) 非获取匹配，反向否定预查，与正向否定预查类似，只是方向相反。例如“(?&lt;!95丨98丨NT丨2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。这个地方不正确，有问题 x丨y 匹配x或y。例如，“z丨food”能匹配“z”或“food”(此处请谨慎)。“(z丨f)ood”则匹配“zood”或“food”。 [xyz] 字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。 [^xyz] 负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“plin”。 [a-z] 字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。注意:只有连字符在字符组内部时,并且出现在两个字符之间时,才能表示字符的范围; 如果出字符组的开头,则只能表示连字符本身. [^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。 \b 匹配一个单词边界，也就是指单词和空格间的位置（即正则表达式的“匹配”有两种概念，一种是匹配字符，一种是匹配位置，这里的\b就是匹配位置的）。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。 \B 匹配非单词边界。“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。 \cx 匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。 \d 匹配一个数字字符。等价于[0-9]。 \D 匹配一个非数字字符。等价于[^0-9]。 \f 匹配一个换页符。等价于\x0c和\cL。 \n 匹配一个换行符。等价于\x0a和\cJ。 \r 匹配一个回车符。等价于\x0d和\cM。 \s 匹配任何不可见字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。 \S 匹配任何可见字符。等价于[^ \f\n\r\t\v]。 \t 匹配一个制表符。等价于\x09和\cI。 \v 匹配一个垂直制表符。等价于\x0b和\cK。 \w 匹配包括下划线的任何单词字符。类似但不等价于“[A-Za-z0-9_]”，这里的”单词”字符使用Unicode字符集。 \W 匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。 \xn 匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“\x41”匹配“A”。“\x041”则等价于“\x04&amp;1”。正则表达式中可以使用ASCII编码。 \num 匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，“(.)\1”匹配两个连续的相同字符。 \n 标识一个八进制转义值或一个向后引用。如果\n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值。 \nm 标识一个八进制转义值或一个向后引用。如果\nm之前至少有nm个获得子表达式，则nm为向后引用。如果\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\nm将匹配八进制转义值nm。 \nml 如果n为八进制数字（0-7），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。 \un 匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，\u00A9匹配版权符号（&copy;）。 \p{P} 小写 p 是 property 的意思，表示 Unicode 属性，用于 Unicode 正表达式的前缀。中括号内的“P”表示Unicode 字符集七个字符属性之一：标点字符。 其他六个属性：L：字母；M：标记符号（一般不会单独出现）；Z：分隔符（比如空格、换行等）；S：符号（比如数学符号、货币符号等）；N：数字（比如阿拉伯数字、罗马数字等）；C：其他字符。*注：此语法部分语言不支持，例：javascript。&lt; &gt; 匹配词（word）的开始（&lt;）和结束（&gt;）。例如正则表达式能够匹配字符串”for the wise”中的”the”，但是不能匹配字符串”otherwise”中的”the”。注意：这个元字符不是所有的软件都支持的。( ) 将( 和 ) 之间的表达式定义为“组”（group），并且将匹配这个表达式的字符保存到一个临时区域（一个正则表达式中最多可以保存9个），它们可以用 \1 到\9 的符号来引用。| 将两个匹配条件进行逻辑“或”（Or）运算。例如正则表达式(him|her) 匹配”it belongs to him”和”it belongs to her”，但是不能匹配”it belongs to them.”。注意：这个元字符不是所有的软件都支持的。 匹配1或多个正好在它之前的那个字符。例如正则表达式9+匹配9、99、999等。注意：这个元字符不是所有的软件都支持的。? 匹配0或1个正好在它之前的那个字符。注意：这个元字符不是所有的软件都支持的。{i} {i,j} 匹配指定数目的字符，这些字符是在它之前的表达式定义的。例如正则表达式A[0-9]{3} 能够匹配字符”A”后面跟着正好3个数字字符的串，例如A123、A348等，但是不匹配A1234。而正则表达式[0-9]{4,6} 匹配连续的任意4个、5个或者6个数字]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端疑难杂症]]></title>
      <url>%2F2017%2F04%2F17%2F%E5%89%8D%E7%AB%AF%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87%2F</url>
      <content type="text"><![CDATA[苹果手机自动播放或者控制播放苹果手机audio标签单单控制play()没声音，需要通过再次加载音效12345678910111213141516171819202122 if ($(&apos;#auidoSuccess&apos;).length) &#123; $(&apos;#auidoSuccess&apos;).attr(&apos;src&apos;, &apos;themes/audio/weixinyaoyy.mp3&apos;) function audioAutoPlay(id) &#123; var audio = document.getElementById(id); audio.load(); document.addEventListener(&quot;WeixinJSBridgeReady&quot;, function () &#123; WeixinJSBridge.invoke(&apos;getNetworkType&apos;, &#123;&#125;, function (e) &#123; audio.load(); &#125;); &#125;, false); document.addEventListener(&apos;YixinJSBridgeReady&apos;, function () &#123; audio.load(); &#125;, false); &#125; audioAutoPlay(&apos;auidoSuccess&apos;) &#125;&#125;playMusic()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端mvc框架backbone.js]]></title>
      <url>%2F2017%2F04%2F17%2F%E5%89%8D%E7%AB%AFmvc%E6%A1%86%E6%9E%B6backbone-js%2F</url>
      <content type="text"><![CDATA[简介Web 应用程序越来越关注于前端，使用客户端脚本与 Ajax 进行交互。由于 JavaScript 应用程序越来越复杂，如果没有合适的工具和模式，那么 JavaScript 代码的高效编写、非重复性和可维护性方面会面临挑战。模型-视图-控制器 (MVC) 是一个常见模式，可用于服务器端开发以生成有组织以及易维护的代码。MVC 支持将数据（比如通常用于 Ajax 交互的 JavaScript Object Notation (JSON) 对象）从表示层或从页面的文档对象模型 (document object model, DOM) 中分离出来，也可适用于客户端开发。Backbone（也称为 Backbone.js）是由 Jeremy Ashkenas 创建的一个轻量级库，可用于创建 MVC 类应用程序。Backbone：强制依赖于 Underscore.js，Underscore.js 是一个实用型库非强制依赖于 jQuery/Zepto根据模型的变更自动更新应用程序的 HTML，有助于代码维护促进客户端模板使用，避免了在 JavaScript 中嵌入 HTML 代码模型、视图、集合和路由器是 Backbone 框架中的主要组件。在 Backbone 中，模型会存储通过 RESTful JSON 接口从服务器检索到的数据。模型与视图密切关联，负责为特定 UI 组件渲染 HTML 并处理元素上触发的事件，这也是视图本身的一部分。常用缩略词DOM：文档对象模型 MVC：模型-视图-控制器 SPI：单页界面 SPI 应用程序：Backbone.Router 和 Backbone.history含有大量 Ajax 交互的应用程序越来越像那些无页面刷新的应用程序。这些应用程序常常试图限制与单个页面的交互。该 SPI 方法提高了效率和速度，并使整个应用程序变得更灵敏。状态概念代替了页面概念。散列 (Hash) 片段被用于识别一个特定状态。散列片段 是 URL 中散列标签 (#) 后的那部分，是该类应用程序的关键元素。清单 1 显示了一个 SPI 应用程序使用两个不同的散列片段产生的两个不同状态。 清单 1. SPI 或 Ajax 应用程序中的两个不同状态http://www.example.com/#/state1http://www.example.com/#/state2Backbone 提供一个称为路由器（版本 0.5 前称之为控制器）的组件来路由客户端状态。路由器可以扩展 Backbone.Router 函数，且包含一个散列映射（routes 属性）将状态与活动关联起来。当应用程序达到相关状态时，会触发一个特定活动。清单 2 展示了一个 Backbone 路由器示例。 清单 2. Backbone.Router 示例：routers.js12345678910111213141516171819202122232425262728App.Routers.Main = Backbone.Router.extend(&#123; // Hash maps for routes routes : &#123; &quot;&quot; : &quot;index&quot;, &quot;/teams&quot; : &quot;getTeams&quot;, &quot;/teams/:country&quot; : &quot;getTeamsCountry&quot;, &quot;/teams/:country/:name : &quot;getTeam&quot; &quot;*error&quot; : &quot;fourOfour&quot; &#125;, index: function()&#123; // Homepage &#125;, getTeams: function() &#123; // List all teams &#125;, getTeamsCountry: function(country) &#123; // Get list of teams for specific country &#125;, getTeam: function(country, name) &#123; // Get the teams for a specific country and with a specific name &#125;, fourOfour: function(error) &#123; // 404 page &#125;&#125;); 创建的每个状态可以为书签。当 URL 碰到类似下面情况时，会调用这 5 个活动（index、getTeams、getTeamsCountry、getTeamCountry 和 fourOfour）。http://www.example.com 触发 index()http://www.example.com/#/teams 触发 getTeams()http://www.example.com/#/teams/country1 触发 getTeamsCountry() 传递 country1 作为参数http://www.example.com/#/teams/country1/team1 触发 getTeamCountry() 传递 country1 和 team1 作为参数http://www.example.com/#/something 触发 fourOfour() 以作 * （星号）使用。要启动 Backbone，先实例化页面加载的路由器，并通过指令 Backbone.history.start() 方法监视散列片段中的任何变更，如 清单 3 所示。 清单 3. 应用程序实例化（使用 jQuery）1234$(function()&#123; var router = new App.Routers.Main(); Backbone.history.start(&#123;pushState : true&#125;);&#125;) 当实例化路由器时，会生成 Backbone.history 对象；它将自动引用 Backbone.History 函数。Backbone.History 负责匹配路由和 router 对象中定义的活动。start() 方法触发后，将创建 Backbone.history 的 fragment 属性。它包含散列片段的值。该序列在根据状态次序管理浏览器历史方面十分有用。用户如果想要返回前一状态，单击浏览器的返回按钮。在 清单 3 的示例中，通过一个启用 HTML5 特性 pushState 的配置调用 start() 方法。对于那些支持 pushState 的浏览器，Backbone 将监视 popstate 事件以触发一个新状态。如果浏览器不能支持 HTML5 特性，那么 onhashchange 活动会被监视。如果浏览器不支持该事件，轮询技术将监视 URL 散列片段的任何更改。 模型和集合模型和集合是 Backbone.js 的重要组件，模型将数据（通常是来自服务器的数据）存储在键值对中。要创建一个模型，需要扩展 Backbone.Model，如 清单 4 所示。 清单 4. Backbone.Model 创建123456App.Models.Team = Backbone.Model.extend(&#123; defaults : &#123; // default attributes &#125; // Domain-specific methods go here&#125;); App.Models.Team 函数是一个新模型函数，但是必须创建一个实例才能在应用程序中使用特定模型，如 清单 5 所示。 清单 5. 模型实例化1var team1 = new App.Models.Team(); 现在，变量 team1 有一个名为 cid 的字段名，这是一个客户端标识符，形式为 “c” 再加上一个数字（例如，c0、c1、c2）。模型是通过存储在散列映射中的属性来定义的。属性可以在实例化时进行设置，或者使用 set() 方法设置。属性值可通过 get() 方法检索。清单 6 显示了如何通过实例化或 get()/set() 方法设置和获取属性。 清单 6. 模型实例化和 get/set 方法1234567891011// &quot;name&quot; attribute is set into the modelvar team1 = new App.Models.Team(&#123; name : &quot;name1&quot;&#125;);console.log(team1.get(&quot;name&quot;)); // prints &quot;name1&quot;// &quot;name&quot; attribute is set with a new valueteam1.set(&#123; name : &quot;name2&quot;&#125;);console.log(team1.get(&quot;name&quot;)); //prints &quot;name2&quot; 当使用 JavaScript 对象时，使用 set() 方法创建或者设置属性值的原因并不是显而易见的。其中一个原因是为了更新此值，如 清单 7 所示。 清单 7. 以错误的方法更新属性1team1.attributes.name = &quot;name2&quot;; 为了避免 使用 清单 7 中的代码，使用 set() 是改变模型状态并触发其变更事件的唯一方法。使用 set() 提升封装原则。清单 8 展示了如何将一个事件处理程序绑到发生变更的事件中。该事件处理程序包含一个 alert，在调用 set() 方法时会被触发，如 清单 6 所示。但是，在使用 清单 7 中的代码时不触发 alert。 清单 8. 更改 App.Models.Team 模型中的事件处理程序12345678App.Models.Team = Backbone.Model.extend(&#123; initialize : function()&#123; this.bind(&quot;change&quot;, this.changed); &#125;, changed : function()&#123; alert(&quot;changed&quot;); &#125;&#125;); Backbone 的另一个优势是易于通过 Ajax 交互与服务器进行通信。在模型上调用一个 save() 方法会通过 REST JSON API 异步将当前状态保存到服务器。清单 9 展示了此示例。 清单 9. 在模型对象上调用 save 方法1barca.save(); save() 函数将在后台委托给 Backbone.sync，这是负责发出 RESTful 请求的组件，默认使用 jQuery 函数 $.ajax()。由于调用了 REST 风格架构，每个 Create、Read、Update 或 Delete (CRUD) 活动均会与各种不同类型的 HTTP 请求（POST、GET、PUT 和 DELETE）相关联。首先保存模型对象，使用一个 POST 请求，创建一个标识符 ID，其后，尝试发送对象到服务器，使用一个 PUT 请求。当需要从服务器检索一个模型时，请求一个 Read 活动并使用一个 Ajax GET 请求。这类请求使用 fetch() 方法。要确定导入模型数据或者从中取出模型数据的服务器的位置：如果模型属于一个 collection，那么集合对象的 url 属性将是该位置的基础，并且该模型 ID（不是 cid）会被附加以构成完整的 URL。如果模型不是在一个集合中，那么该模型的 urlroot 属性被用作该位置的基础清单 10 显示了如何获取一个模型。 清单 10. 模型对象的 Fetch() 方法12345var teamNew = new App.Models.Team(&#123; urlRoot : &apos;/specialTeams&apos;&#125;);teamNew.save(); // returns model&apos;s ID equal to &apos;222&apos;teamNew.fetch(); // Ajax request to &apos;/specialTeams/222&apos; validate() 方法被用于验证模型，如 清单 11 所示。需要重写 validate() 方法（在调用 set() 方法时触发）来包含模型的有效逻辑。传递给该函数的惟一参数是一个 JavaScript 对象，该对象包含了 set() 方法更新的属性，以便验证那些属性的条件。如果从 validate() 方法中没有返回任何内容，那么验证成功。如果返回一个错误消息，那么验证失败，将无法执行 set() 方法。 清单 11. 模型的验证方法123456789App.Models.Team = Backbone.Model.extend(&#123; validate : function(attributes)&#123; if (!!attributes &amp;&amp; attributes.name === &quot;teamX&quot;) &#123; // Error message returned if the value of the &quot;name&quot; // attribute is equal to &quot;teamX&quot; return &quot;Error!&quot;; &#125; &#125;&#125; 一组模型被分组到到集合中，这个集合是 Backbone.Collection 的扩展函数。集合具有一个模型属性的特性，定义了组成该集合的模型类型。使用 add()/remove() 方法可以将一个模型添加和移动到集合中。清单 12 显示了如何创建和填充一个集合。 清单 12. Backbone 集合1234567891011121314App.Collections.Teams = Backbone.Collection.extend(&#123; model : App.Models.Team&#125;);var teams = new App.Collections.Teams();// Add e model to the collection object &quot;teams&quot;teams.add(team1);teams.add(new App.Models.Team(&#123; name : &quot;Team B&quot;&#125;));teams.add(new App.Models.Team());teams.remove(team1);console.log(teams.length) // prints 2 创建的 teams 集合中包含一个含有两个模型的阵列，存储在模型属性中。尽管，在典型 Ajax 应用程序中，会从服务器动态（不是人工）填充该集合。fetch() 方法可以帮助完成此项任务，如 清单 13 所示，并将数据存储到模型阵列中。 清单 13. Fetch() 方法1teams.fetch(); Backbone 中的集合拥有一个 url 属性，定义了使用 Ajax GET 请求从服务器取出 JSON 数据的位置，如 清单 14 所示。 清单 14. 集合的 url 属性和 fetch() 方法12teams.url = &apos;/getTeams&apos;;teams.fetch(); //Ajax GET Request to &apos;/getTeams&apos; Fetch() 方法属于异步调用，因此，在等待服务器响应时，应用程序不会中止。在一些情况下，要操作来自服务器的原始数据，可以使用集合的 parse() 方法。正如 清单 15 所示。 清单 15. parse() 方法1234567App.Collections.Teams = Backbone.Collection.extend(&#123; model : App.Models.Team, parse : function(data) &#123; // &apos;data&apos; contains the raw JSON object console.log(data); &#125;&#125;); 集合提供的另一个有趣的方法是 reset()，它允许将多个模型设置到一个集合中。reset() 方法可以非常方便地将数据引导到集合中，比如页面加载，来避免用户等待异步调用返回。 视图和客户端模板Backbone 中的视图与典型 MVC 方法的视图不一样。Backbone 视图可以扩展 Backbone.View 函数并显示模型中存储的数据。一个视图提供一个由 el 属性定义的 HTML 元素。该属性可以是由 tagName、className 和 id 属性相组合而构成的，或者是通过其本身的 el 值形成的。清单 16 显示了使用这不同方法组合 el 属性的两个不同视图。 清单 16. Backbone 视图样例123456789// In the following view, el value is &apos;UL.team-element&apos;App.Views.Teams = Backbone.View.extend(&#123; el : &apos;UL.team-list&apos;&#125;);// In the following view, el value is &apos;div.team-element&apos;App.Views.Team = Backbone.View.extend(&#123; className : &apos;.team-element&apos;, tagName : &apos;div&apos;&#125;); 如果 el、tagName、className 和 id 属性为空，那么会默认将一个空的 DIV 分配给 el。如上所述，一个视图必须与一个模型相关联。该模型属性也很有用，如 清单 17 所示。App.View.Team 视图被绑定到一个 App.Models.Team 模型实例。 清单 17. Backbone 视图中的模型属性12345// In the following view, el value is &apos;UL.team-element&apos;App.Views.Team = Backbone.View.extend(&#123; ... model : new App.Models.Team&#125;); 要渲染数据（这是视图的主要目的），重写 render() 方法和逻辑来显示 DOM 元素（由 el 属性引用的）中的模型属性。清单 18 展示了一个 render 方法如何更新用户界面的样例。 清单 18. Render() 方法12345678910App.Views.Team = Backbone.View.extend(&#123; className : &apos;.team-element&apos;, tagName : &apos;div&apos;, model : new App.Models.Team render : function() &#123; // Render the &apos;name&apos; attribute of the model associated // inside the DOM element referred by &apos;el&apos; $(this.el).html(&quot;&lt;span&gt;&quot; + this.model.get(&quot;name&quot;) + &quot;&lt;/span&gt;&quot;); &#125;&#125;); Backbone 也可以促进客户端模板的使用，这就使得我们没有必要在 JavaScript 中嵌入 HTML 代码，如 清单 18 所示。（使用模板，模板会封装视图中常见函数；只指定此函数一次即可。）Backbone 在 underscore.js（一个必须的库）中提供一个模板引擎，尽管没有必要使用该模板引擎。清单 19 中的实例使用 underscore.js HTML 模板。 清单 19. HTML 含有模板123&lt;script id=&quot;teamTemplate&quot; type=&quot;text/template&quot;&gt; &lt;%= name %&gt;&lt;/script&gt; 清单 20 显示了另一个使用 underscore.js HTML 模板的样例。 清单 20. 使用 _.template() 函数的视图123456789101112App.Views.Team = Backbone.View.extend(&#123; className : &apos;.team-element&apos;, tagName : &apos;div&apos;, model : new App.Models.Team render : function() &#123; // Compile the template var compiledTemplate = _.template($(&apos;#teamTemplate&apos;).html()); // Model attributes loaded into the template. Template is // appended to the DOM element referred by the el attribute $(this.el).html(compiledTemplate(this.model.toJSON())); &#125;&#125;); Backbone 中最有用且最有趣的一个功能是将 render() 方法绑定到模型的变更事件中，如 清单 21 所示。 清单 21. Render() 方法绑定到模型变更事件1234567// In the following view, el value is &apos;div.team-element&apos;App.Views.Team = Backbone.View.extend(&#123; model : new App.Models.Team, initialize : function() &#123; this.model.bind(&quot;change&quot;, this.render, this); &#125;&#125;) 上述代码将 render() 方法绑定到一个模型的变更事件中。当模型发生更改时，会自动触发 render() 方法，从而节省数行代码。从 Backbone 0.5.2 开始，bind() 方法就开始接受使用第三个参数来定义回调函数的对象。（在上述示例中，当前视图是回调函数 render() 中的对象）。在 Backbone 0.5.2 之前的版本中，必须使用 underscore.js 中的 bindAll 函数，如 清单 22 所示。 清单 22. _.bindAll() usage1234567// In the following view, el value is &apos;div.team-element&apos;App.Views.Team = Backbone.View.extend(&#123; initialize : function() &#123; _.bindAll(this, &quot;render&quot;); this.model.bind(&quot;change&quot;, this.render); &#125;&#125;) Backbone 视图中，通过视图中的 DOM 对象监听事件是比较容易的。对于实现这一点，events 属性很是方便的，如 清单 23 所示。 清单 23. 事件属性12345678910App.Views.Team = Backbone.View.extend(&#123; className : &apos;.team-element&apos;, tagName : &apos;div&apos;, events : &#123; &quot;click a.more&quot; : &quot;moreInfo&quot; &#125;, moreInfo : function(e)&#123; // Logic here &#125;&#125;) events 属性的每个项均由两部分构成：左边部分指定事件类型和触发事件的选择器。右边部分定义了事件处理函数。在 清单 23 中，当用户通过 DIV 中的类 more 以及类 team-element 点击链接时，会调用函数 moreInfo。 结束语MVC 模式可以为大型 JavaScript 应用程序提供所需的组织化代码。Backbone 是一个 JavaScript MVC 框架，它属于轻量级框架，且易于学习掌握。模型、视图、集合和路由器从不同的层面划分了应用程序，并负责处理几种特定事件。处理 Ajax 应用程序或者 SPI 应用程序时，Backbone 可能是最好的解决方案。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[用webpack做vue热加载]]></title>
      <url>%2F2017%2F04%2F15%2Fwebpack%E7%83%AD%E5%8A%A0%E8%BD%BD%2F</url>
      <content type="text"><![CDATA[介绍使用 webpack 有一段时间了，其中的模块热加载加快了开发的速度。它无需刷新，只要修改了文件，客户端就立刻做热加载webpack.config.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244const webpack = require(&apos;webpack&apos;)const glob = require(&apos;glob&apos;)const fs = require(&apos;fs&apos;)const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)const colors = require(&apos;colors&apos;)const path = require(&apos;path&apos;)const TransferWebpackPlugin = require(&apos;transfer-webpack-plugin&apos;)const express = require(&apos;express&apos;)const WebpackDevMiddleware = require(&apos;webpack-dev-middleware&apos;)const WebpackHotMiddleware = require(&apos;webpack-hot-middleware&apos;)const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;)const argv = require(&apos;minimist&apos;)(process.argv.slice(2))const bs = require(&apos;browser-sync&apos;).create();let bsFlag = falseconst gulp = require(&apos;gulp&apos;)/** * 编译配置 * @type &#123;Object&#125; */const setting = &#123; src:&apos;./src&apos;, // 源文件目录 release:&apos;./dist&apos; // 编译后文件&#125;/** * 获取配置 * @return &#123;[type]&#125; [description] */const getConf = function()&#123; let config = &#123; entry:&#123; &#125;, output: &#123; path:path.resolve(__dirname, &apos;dist&apos;), publicPath: &apos;/&apos;, filename: &apos;[name]-[hash].js&apos;, chunkFilename:&quot;[id].chunk.js&quot; &#125;, module: &#123; loaders: [ &#123; test: /\.vue$/, exclude: /node_modules/, loader: &apos;vue&apos; &#125;, &#123; test: /\.html$/, loader: &apos;html&apos; &#125;, &#123; test: /\.(js|jsx)$/, loader: &apos;babel&apos;, query: &#123; presets: [ require.resolve(&apos;babel-preset-react&apos;), require.resolve(&apos;babel-preset-es2015&apos;) ] &#125;, include: path.resolve(process.cwd(), &apos;./&apos;), exclude: /node_modules/ &#125;, &#123; test: /\.(png|jpg|gif|svg|mp3|wav|ogg|json)$/, loaders: [ &apos;url?limit=1024&amp;hash=sha512&amp;digest=hex&amp;name=[name]-[hash].[ext]&apos; ] &#125; ] &#125;, resolve: &#123; extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.json&apos;, &apos;.scss&apos;,&apos;.hbs&apos;,&apos;.html&apos;], alias: &#123; &apos;vue&apos;: &apos;vue/dist/vue.js&apos; &#125; &#125;, plugins:[ // new MyPlugin(&#123;options: &apos;&apos;&#125;), new webpack.HotModuleReplacementPlugin(), new webpack.optimize.OccurenceOrderPlugin(), new webpack.NoErrorsPlugin() ], &#125; config.entry = entries() // 处理html config.plugins = config.plugins.concat(htmlPlugins()) // 处理版本控制 if(checkEnvPro())&#123; config.plugins.push( new webpack.DefinePlugin(&#123; &apos;process.env&apos;: &#123; NODE_ENV: &apos;&quot;production&quot;&apos; &#125; &#125;), new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; warnings: false &#125; &#125;) ) &#125;else&#123; // config.devtool = &apos;#source-map&apos; &#125; return config&#125;/** * 获取入口文件 * @return &#123;[type]&#125; [description] */const entries = function()&#123; let targetJs = path.resolve(setting.src, &apos;entries&apos;) console.log(colors.red(targetJs)) let entryFiles = glob.sync(targetJs + &apos;/*.&#123;js,jsx&#125;&apos;) let map = &#123;&#125; let targetFiles = glob.sync(setting.release + &apos;/*.&#123;js,css,html&#125;&apos;) entryFiles.forEach(function (entry) &#123; let fileName = entry.substring(entry.lastIndexOf(&apos;\/&apos;) + 1, entry.lastIndexOf(&apos;.&apos;)) map[fileName] = path.resolve(__dirname,entry) /** * 清理上个版本文件 * @type &#123;[type]&#125; */ targetFiles.forEach(function(file)&#123; let sourceName = file.substring(file.lastIndexOf(&apos;\/&apos;) + 1, file.lastIndexOf(&apos;-&apos;)) let htmlName = file.substring(file.lastIndexOf(&apos;\/&apos;) + 1, file.lastIndexOf(&apos;.&apos;)) if(sourceName == fileName || htmlName == fileName)&#123; !argv.hot &amp;&amp; fs.existsSync(file) &amp;&amp; fs.unlinkSync(file) &#125; &#125;) &#125;) return map&#125;/** * 处理html-views * @return &#123;[type]&#125; [description] */const htmlPlugins = function () &#123; let entryHtml = glob.sync(setting.src + &apos;/views/*.html&apos;) let plugins = [] entryHtml.forEach(function(entry)&#123; let filePath = path.join(__dirname, entry) let fileName = filePath.substring(filePath.lastIndexOf(&apos;\/&apos;) + 1, filePath.lastIndexOf(&apos;.&apos;)); plugins.push(new HtmlWebpackPlugin(&#123; chunks: [fileName], cache:false, filename: fileName + &apos;.html&apos;, inject:true, hash:true, template:filePath, minify:checkEnvPro() ? &#123; removeAttributeQuotes: true &#125; : false, // templateContent: function(templateParams, compilation)&#123; // let contentStr = fs.readFileSync(filePath).toString() // return contentStr // &#125; &#125;)) &#125;) return plugins&#125;/** * 检查版本，增加版本功能控制 * @return &#123;[type]&#125; [description] */const checkEnvPro = function()&#123; if (process.env.NODE_ENV === &apos;production&apos;) &#123; return true &#125; else &#123; return false &#125;&#125;/** * 监听html * @return &#123;[type]&#125; [description] */const browserSync = function()&#123; if(bsFlag)&#123; return &#125; bsFlag = true bs.init(&#123; server: &#123; baseDir: setting.release &#125;, files: [&apos;./src/**&apos;], port: 8090, files: [ &#123; match: [&apos;./src/**&apos;], fn: function (event, file) &#123; if (event === &apos;change&apos;) &#123; webpack(getConf(),function()&#123; bs.reload(); &#125;) &#125; &#125; &#125; ] &#125;);&#125;function MyPlugin(options) &#123;&#125;MyPlugin.prototype.apply = function(compiler) &#123; compiler.plugin(&apos;compilation&apos;, function(compilation) &#123; // console.log(colors.red(&apos;compilation&apos;)) // browserSync() &#125;);&#125;;module.exports = getConf() webpack.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465const webpack = require(&apos;webpack&apos;)const webpackDevServer = require(&apos;webpack-dev-server&apos;)const webpackDevMiddleware = require(&apos;webpack-dev-middleware&apos;)const webpackHotMiddleware = require(&apos;webpack-hot-middleware&apos;)const colors = require(&apos;colors&apos;)const bs = require(&apos;browser-sync&apos;).create();const express = require(&apos;express&apos;)const app = express()const opn = require(&apos;opn&apos;)const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;)const connectHistoryApiFallBack = require(&apos;connect-history-api-fallback&apos;)const path = require(&apos;path&apos;)const config = require(path.join(__dirname, &apos;webpack.config&apos;))const port = process.env.PORT || 8090/** * 设置confg，hot参数 */const setConfig = function()&#123; var extras = [&apos;./dev-client&apos;];// var extras = [&apos;webpack-hot-middleware/client?path=/__webpack_hmr&amp;reload=true&apos;] Object.keys(config.entry).forEach(function(name) &#123; config.entry[name] = extras.concat(config.entry[name]) &#125;) config.plugins.push( new webpack.HotModuleReplacementPlugin(), new webpack.optimize.OccurenceOrderPlugin(), new webpack.NoErrorsPlugin() ) return config&#125;var compiler = webpack(setConfig())var proxyMiddleware = require(&apos;http-proxy-middleware&apos;)var devMiddleware = require(&apos;webpack-dev-middleware&apos;)(compiler, &#123; publicPath: config.output.publicPath, stats: &#123; colors: true, chunks: false &#125;,&#125;)var hotMiddleware = require(&apos;webpack-hot-middleware&apos;)(compiler)compiler.plugin(&apos;compilation&apos;, function(compilation) &#123; compilation.plugin(&apos;html-webpack-plugin-after-emit&apos;, function(data, cb) &#123; hotMiddleware.publish(&#123; action: &apos;reload&apos; &#125;) cb() &#125;)&#125;)app.use(devMiddleware)app.use(hotMiddleware)app.use(express.static(config.output.path))app.use(require(&apos;connect-history-api-fallback&apos;)())app.listen(port, function(err) &#123; if (err) &#123; console.log(err) return &#125; console.log(colors.green(&apos;服务已开启，端口:&apos;+port))// opn(&apos;http://localhost:&apos;+port)&#125;) package.json 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&#123; &quot;name&quot;: &quot;back&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack-dev-server --inline --hot&quot;, &quot;build&quot;: &quot;export NODE_ENV=production &amp;&amp; webpack --progress --hide-modules&quot;, &quot;hot&quot;: &quot;node webpack.js --hot&quot; &#125;, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: &#123; &quot;autoprefixer&quot;: &quot;^6.7.7&quot;, &quot;babel-core&quot;: &quot;^6.2.1&quot;, &quot;babel-loader&quot;: &quot;^6.2.0&quot;, &quot;babel-plugin-transform-runtime&quot;: &quot;^6.1.18&quot;, &quot;babel-preset-es2015&quot;: &quot;^6.1.18&quot;, &quot;babel-preset-react&quot;: &quot;^6.23.0&quot;, &quot;babel-preset-stage-0&quot;: &quot;^6.1.18&quot;, &quot;babel-runtime&quot;: &quot;^6.2.0&quot;, &quot;browser-sync&quot;: &quot;^2.18.8&quot;, &quot;connect-history-api-fallback&quot;: &quot;^1.3.0&quot;, &quot;css-loader&quot;: &quot;^0.23.1&quot;, &quot;express&quot;: &quot;^4.15.2&quot;, &quot;extract-text-webpack-plugin&quot;: &quot;^2.1.0&quot;, &quot;file-loader&quot;: &quot;^0.8.5&quot;, &quot;fs&quot;: &quot;0.0.1-security&quot;, &quot;glob&quot;: &quot;^7.1.1&quot;, &quot;gulp&quot;: &quot;^3.9.1&quot;, &quot;html-loader&quot;: &quot;^0.4.5&quot;, &quot;html-webpack-plugin&quot;: &quot;^2.28.0&quot;, &quot;http-proxy-middleware&quot;: &quot;^0.17.4&quot;, &quot;jade&quot;: &quot;^1.11.0&quot;, &quot;minimist&quot;: &quot;^1.2.0&quot;, &quot;node-sass&quot;: &quot;^3.4.2&quot;, &quot;opn&quot;: &quot;^4.0.2&quot;, &quot;postcss-loader&quot;: &quot;^1.3.3&quot;, &quot;sass-loader&quot;: &quot;^3.2.3&quot;, &quot;style-loader&quot;: &quot;^0.13.0&quot;, &quot;stylus-loader&quot;: &quot;^1.4.2&quot;, &quot;template-html-loader&quot;: &quot;0.0.3&quot;, &quot;transfer-webpack-plugin&quot;: &quot;^0.1.4&quot;, &quot;vue&quot;: &quot;^2.1.0&quot;, &quot;vue-loader&quot;: &quot;^10.0.0&quot;, &quot;vue-resource&quot;: &quot;^1.0.3&quot;, &quot;vue-router&quot;: &quot;^2.1.1&quot;, &quot;vue-scroll&quot;: &quot;^2.0.1&quot;, &quot;vue-style-loader&quot;: &quot;^1.0.0&quot;, &quot;vue-template-compiler&quot;: &quot;^2.1.0&quot;, &quot;vuex&quot;: &quot;^2.1.1&quot;, &quot;webpack&quot;: &quot;^1.13.1&quot;, &quot;webpack-dev-middleware&quot;: &quot;^1.8.3&quot;, &quot;webpack-hot-middleware&quot;: &quot;^2.12.2&quot; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[koa2搭建接口服务器实践]]></title>
      <url>%2F2017%2F04%2F15%2Fkoa2%E6%90%AD%E5%BB%BA%E6%8E%A5%E5%8F%A3%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E8%B7%B5%2F</url>
      <content type="text"><![CDATA[准备工作 安装新版node，es7需要高版本node支持， 并且需要babel转换es7语法 async/await是异步流程控制更好的解决方案 .babelrc1234567 &#123; &quot;presets&quot;: [&quot;es2015-node5&quot;], &quot;plugins&quot;: [ &quot;transform-async-to-generator&quot;, &quot;syntax-async-functions&quot; ]&#125; 入口index12require(&apos;babel-register&apos;);require(&apos;./server/index.js&apos;) 目录结构 doc 数据库文件，项目文档 .doc .sql backEnd 后台文件 Semantic UI （样式框架） vue／angular （mvc框架） frontEnd 前端文件 vue/ng/react app 原文件 release 编译文件 bower.json 引用 server 服务端文件 config 配置模块（数据库配置，环境配置） index.js controller 控制器，统一入口模块 routers 路由文件 (user) 接口处理模块 index.js 入口文件 codes code编码模块 code.js index.js models 数据库模型模块Sequelize services 业务模块，处理封装数据库models upload 文件上传目录 utils 工具类 views node模版引擎 handlebars logs 日志模块 todo`中间件 session redis 缓存处理 package.json12345678910111213141516171819202122232425262728&#123; &quot;name&quot;: &quot;server&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: &#123; &quot;babel-plugin-syntax-async-functions&quot;: &quot;^6.13.0&quot;, &quot;babel-plugin-transform-async-to-generator&quot;: &quot;^6.24.1&quot;, &quot;babel-preset-es2015-node5&quot;: &quot;^1.2.0&quot;, &quot;babel-register&quot;: &quot;^6.24.1&quot;, &quot;colors&quot;: &quot;^1.1.2&quot;, &quot;fs&quot;: &quot;0.0.1-security&quot;, &quot;koa&quot;: &quot;^2.0.0-alpha.8&quot;, &quot;koa-body&quot;: &quot;^2.0.0&quot;, &quot;koa-logger&quot;: &quot;^2.0.1&quot;, &quot;koa-router&quot;: &quot;^7.1.1&quot;, &quot;koa-views&quot;: &quot;^6.0.2&quot;, &quot;mysql&quot;: &quot;^2.13.0&quot;, &quot;node.extend&quot;: &quot;^1.1.6&quot;, &quot;path&quot;: &quot;^0.12.7&quot;, &quot;sequelize&quot;: &quot;^3.30.4&quot; &#125;&#125; services模块入口123456789101112131415161718const fs = require(&apos;fs&apos;)const path = require(&apos;path&apos;)const Sequelize = require(&apos;sequelize&apos;)const env = process.env.NODE_ENV || &apos;development&apos;const config = require(&apos;../config/index&apos;)[env]const utils = require(&apos;../utils/index&apos;)const sequelize = new Sequelize(config.database, config.username, config.password, config);const dbStorage = []const modelRoot = process.cwd() + &apos;/models&apos;const models = utils.getFiles(modelRoot)models.map(function(file)&#123; let model = sequelize.import(path.join(modelRoot,file)) dbStorage[model.name] = model&#125;)module.exports = dbStorage 控制器1234567891011121314151617181920212223242526272829/*============================================================================ * 控制器入口 ============================================================================*/const Koa = require(&apos;koa&apos;);const router = require(&apos;../routers/index&apos;)const app = new Koa();const http = require(&apos;http&apos;)const views = require(&apos;koa-views&apos;)const colors = require(&apos;colors&apos;)// const cors = require(&apos;koa-cors&apos;)const config = require(&apos;../config&apos;)const logger = require(&apos;koa-logger&apos;)// 引入模版views// app.use(views(__dirname + &apos;/views&apos;, &#123; extension: &apos;jade&apos; &#125;))app.use(views( __dirname + &apos;/views&apos;, &#123; extension: &apos;hbs&apos;, map: &#123; hbs: &apos;handlebars&apos; &#125;&#125;));// 引入路由app.use(router.routes()) .use(router.allowedMethods());// 跨域// app.use(cors())// 日志app.use(logger())// 开启服务let server = http.createServer(app.callback());server.listen(config.base.port);console.log(colors.red(&apos;服务已开启：端口&apos;+ config.base.port)) 路由入口文件12345678910111213141516171819202122232425262728/*============================================================================ * 接口路由入口 ============================================================================*/const colors = require(&apos;colors&apos;)const fs = require(&apos;fs&apos;)const path = require(&apos;path&apos;)const Router = require(&apos;koa-router&apos;)const router = new Router()const utils = require(&apos;../utils&apos;)/** * 遍历路由文件夹，注册路由 * @type &#123;String&#125; */let routesArray = utils.getFiles(__dirname)routesArray.map(function(item)&#123; let fileName = &apos;./&apos; + item if(fs.existsSync(path.resolve(__dirname, fileName)))&#123; let routesInstance = require(fileName) router.use(routesInstance.routes()) .use(routesInstance.allowedMethods()); &#125;else&#123; console.log(&apos;路由 ----&apos; + path.resolve(__dirname, fileName) + &apos; not found&apos;) &#125;&#125;)module.exports = router 某路由文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869const Router = require(&apos;koa-router&apos;)const router = new Router()const body = require(&apos;koa-body&apos;)()const colors = require(&apos;colors&apos;)const modules = require(process.cwd() + &apos;/services/index&apos;)const codes = require(process.cwd() + &apos;/codes/index&apos;)const utils = require(process.cwd() + &apos;/utils/index&apos;)/** * 检查用户存在 * @param &#123;[type]&#125; userName [description] * @return &#123;[type]&#125; [description] */const checkUserExit = async (username) =&gt; &#123; if(!username)&#123; return &#125; return new Promise((resolve, reject) =&gt; &#123; modules.users.findAll(&#123; where: &#123; username: username, &#125; &#125;).then((result)=&gt;&#123; if(result &amp;&amp; result.length &gt; 0)&#123; resolve(true) &#125;else&#123; resolve(false) &#125; &#125;) &#125;)&#125;router.post(&apos;/login&apos;,body, async (ctx) =&gt; &#123; ctx.set(&apos;Access-Control-Allow-Method&apos;, &apos;POST&apos;); ctx.set(&apos;Access-Control-Allow-Origin&apos;, &apos;*&apos;) let username = ctx.request.body.username let password = ctx.request.body.password if(!username || !password)&#123; ctx.body = codes.set(&apos;2&apos;) return &#125; // 是否存在用户 let isExit = await checkUserExit(username) let data = &#123;isExit:isExit&#125; ctx.body = utils.extend(codes.set(&apos;0&apos;),data)&#125;)router.get(&apos;/getUser/:id&apos;, async (ctx,next) =&gt; &#123; let id = ctx.params.id; await modules.users.findAll(&#123; where: &#123; id: id, &#125; &#125;).then((result)=&gt;&#123; let params = JSON.stringify(result) ctx.body = JSON.stringify(result) &#125;)&#125;);module.exports = router utils12345678910111213141516171819202122232425262728const fs = require(&apos;fs&apos;)const path = require(&apos;path&apos;)const colors = require(&apos;colors&apos;)const utils = require(&apos;./utils&apos;)utils.prototype.getFiles = function(root)&#123; let fileArray = [] const getDeepFiles = function(fileRoot,parentRoot)&#123; fs.readdirSync(fileRoot) .forEach(function (file) &#123; if(file == &apos;index.js&apos;)&#123; return &#125; let curPath = fileRoot + &apos;/&apos; + file if(fs.statSync(curPath).isDirectory())&#123; getDeepFiles(curPath,file) &#125;else&#123; if(parentRoot)&#123; fileArray.push(parentRoot + &apos;/&apos; + file) &#125;else&#123; fileArray.push(file) &#125; &#125; &#125;) &#125; getDeepFiles(root) return fileArray&#125; 以上是部分文件显示，如果需要详细框架搭建，留言或QQ联系博主我]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[react知识点]]></title>
      <url>%2F2017%2F04%2F15%2Freact%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
      <content type="text"><![CDATA[调用 setState 之后发生了什么？在代码中调用setState函数之后，React 会将传入的参数对象与组件当前的状态合并，然后触发所谓的调和过程（Reconciliation）。经过调和过程，React 会以相对高效的方式根据新的状态构建 React 元素树并且着手重新渲染整个UI界面。在 React 得到元素树之后，React 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染。在差异计算算法中，React 能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。 React 中 Element 与 Component 的区别是？简单而言，React Element 是描述屏幕上所见内容的数据结构，是对于 UI 的对象表述。典型的 React Element 就是利用 JSX 构建的声明式代码片然后被转化为createElement的调用组合。而 React Component 则是可以接收参数输入并且返回某个 React Element 的函数或者类。更多介绍可以参考React Elements vs React Components。 在什么情况下你会优先选择使用 Class Component 而不是 Functional Component？在组件需要包含内部状态或者使用到生命周期函数的时候使用 Class Component ，否则使用函数式组件。 React 中 refs 的作用是什么？Refs 是 React 提供给我们的安全访问 DOM 元素或者某个组件实例的句柄。我们可以为元素添加ref属性然后在回调函数中接受该元素在 DOM 树中的句柄，该值会作为回调函数的第一个参数返回： 1234567891011121314151617181920212223242526272829class CustomForm extends Component &#123; handleSubmit = () =&gt; &#123; console.log(&quot;Input Value: &quot;, this.input.value) &#125; render () &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;input type=&apos;text&apos; ref=&#123;(input) =&gt; this.input = input&#125; /&gt; &lt;button type=&apos;submit&apos;&gt;Submit&lt;/button&gt; &lt;/form&gt; ) &#125;&#125; 上述代码中的input域包含了一个ref属性，该属性声明的回调函数会接收input对应的 DOM 元素，我们将其绑定到this指针以便在其他的类函数中使用。另外值得一提的是，refs 并不是类组件的专属，函数式组件同样能够利用闭包暂存其值： 123456789101112131415161718192021function CustomForm (&#123;handleSubmit&#125;) &#123; let inputElement return ( &lt;form onSubmit=&#123;() =&gt; handleSubmit(inputElement.value)&#125;&gt; &lt;input type=&apos;text&apos; ref=&#123;(input) =&gt; inputElement = input&#125; /&gt; &lt;button type=&apos;submit&apos;&gt;Submit&lt;/button&gt; &lt;/form&gt; )&#125; React 中 keys 的作用是什么？Keys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。 1234567891011121314151617render () &#123; return ( &lt;ul&gt; &#123;this.state.todoItems.map((&#123;task, uid&#125;) =&gt; &#123; return &lt;li key=&#123;uid&#125;&gt;&#123;task&#125;&lt;/li&gt; &#125;)&#125; &lt;/ul&gt; )&#125; 在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有唯一性。在 React Diff 算法中 React 会借助元素的 Key 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染。此外，React 还需要借助 Key 值来判断元素与本地状态的关联关系，因此我们绝不可忽视转换函数中 Key 的重要性。 如果你创建了类似于下面的Twitter元素，那么它相关的类定义是啥样子的？12345678910111213141516171819202122232425&lt;Twitter username=&apos;tylermcginnis33&apos;&gt; &#123;(user) =&gt; user === null ? &lt;Loading /&gt; : &lt;Badge info=&#123;user&#125; /&gt;&#125;&lt;/Twitter&gt;import React, &#123; Component, PropTypes &#125; from &apos;react&apos;import fetchUser from &apos;twitter&apos;// fetchUser take in a username returns a promise// which will resolve with that username&apos;s data.class Twitter extends Component &#123; // finish this&#125; 如果你还不熟悉回调渲染模式（Render Callback Pattern），这个代码可能看起来有点怪。这种模式中，组件会接收某个函数作为其子组件，然后在渲染函数中以props.children进行调用： 123456789101112131415161718192021222324252627282930313233import React, &#123; Component, PropTypes &#125; from &apos;react&apos;import fetchUser from &apos;twitter&apos;class Twitter extends Component &#123; state = &#123; user: null, &#125; static propTypes = &#123; username: PropTypes.string.isRequired, &#125; componentDidMount () &#123; fetchUser(this.props.username) .then((user) =&gt; this.setState(&#123;user&#125;)) &#125; render () &#123; return this.props.children(this.state.user) &#125;&#125; 这种模式的优势在于将父组件与子组件解耦和，父组件可以直接访问子组件的内部状态而不需要再通过Props传递，这样父组件能够更为方便地控制子组件展示的UI界面。譬如产品经理让我们将原本展示的Badge替换为Profile，我们可以轻易地修改下回调函数即可： 12345678910&lt;Twitter username=&apos;tylermcginnis33&apos;&gt; &#123;(user) =&gt; user === null ? &lt;Loading /&gt; : &lt;Profile info=&#123;user&#125; /&gt;&#125;&lt;/Twitter&gt; Controlled Component 与 Uncontrolled Component 之间的区别是什么？React 的核心组成之一就是能够维持内部状态的自治组件，不过当我们引入原生的HTML表单元素时（input,select,textarea 等），我们是否应该将所有的数据托管到 React 组件中还是将其仍然保留在 DOM 元素中呢？这个问题的答案就是受控组件与非受控组件的定义分割。受控组件（Controlled Component）代指那些交由 React 控制并且所有的表单数据统一存放的组件。譬如下面这段代码中username变量值并没有存放到DOM元素中，而是存放在组件状态数据中。任何时候我们需要改变username变量值时，我们应当调用setState函数进行修改。 12345678910111213141516171819202122232425262728293031323334353637383940414243class ControlledForm extends Component &#123; state = &#123; username: &apos;&apos; &#125; updateUsername = (e) =&gt; &#123; this.setState(&#123; username: e.target.value, &#125;) &#125; handleSubmit = () =&gt; &#123;&#125; render () &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;input type=&apos;text&apos; value=&#123;this.state.username&#125; onChange=&#123;this.updateUsername&#125; /&gt; &lt;button type=&apos;submit&apos;&gt;Submit&lt;/button&gt; &lt;/form&gt; ) &#125;&#125; 而非受控组件（Uncontrolled Component）则是由DOM存放表单数据，并非存放在 React 组件中。我们可以使用 refs 来操控DOM元素： 1234567891011121314151617181920212223242526272829class UnControlledForm extends Component &#123; handleSubmit = () =&gt; &#123; console.log(&quot;Input Value: &quot;, this.input.value) &#125; render () &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;input type=&apos;text&apos; ref=&#123;(input) =&gt; this.input = input&#125; /&gt; &lt;button type=&apos;submit&apos;&gt;Submit&lt;/button&gt; &lt;/form&gt; ) &#125;&#125; 竟然非受控组件看上去更好实现，我们可以直接从 DOM 中抓取数据，而不需要添加额外的代码。不过实际开发中我们并不提倡使用非受控组件，因为实际情况下我们需要更多的考虑表单验证、选择性的开启或者关闭按钮点击、强制输入格式等功能支持，而此时我们将数据托管到 React 中有助于我们更好地以声明式的方式完成这些功能。引入 React 或者其他 MVVM 框架最初的原因就是为了将我们从繁重的直接操作 DOM 中解放出来。 在生命周期中的哪一步你应该发起 AJAX 请求？我们应当将AJAX 请求放到 componentDidMount 函数中执行，主要原因有下： React 下一代调和算法 Fiber 会通过开始或停止渲染的方式优化应用性能，其会影响到 componentWillMount 的触发次数。对于 componentWillMount 这个生命周期函数的调用次数会变得不确定，React 可能会多次频繁调用 componentWillMount。如果我们将 AJAX 请求放到 componentWillMount 函数中，那么显而易见其会被触发多次，自然也就不是好的选择。如果我们将 AJAX 请求放置在生命周期的其他函数中，我们并不能保证请求仅在组件挂载完毕后才会要求响应。如果我们的数据请求在组件挂载之前就完成，并且调用了setState函数将数据添加到组件状态中，对于未挂载的组件则会报错。而在 componentDidMount 函数中进行 AJAX 请求则能有效避免这个问题。 shouldComponentUpdate 的作用是啥以及为何它这么重要？shouldComponentUpdate 允许我们手动地判断是否要进行组件更新，根据组件的应用场景设置函数的合理返回值能够帮我们避免不必要的更新。 如何告诉 React 它应该编译生产环境版本？通常情况下我们会使用 Webpack 的 DefinePlugin 方法来将 NODE_ENV 变量值设置为 production。编译版本中 React 会忽略 propType 验证以及其他的告警信息，同时还会降低代码库的大小，React 使用了 Uglify 插件来移除生产环境下不必要的注释等信息。 为什么我们需要使用 React 提供的 Children API 而不是 JavaScript 的 map？props.children并不一定是数组类型，譬如下面这个元素： 12345&lt;Parent&gt; &lt;h1&gt;Welcome.&lt;/h1&gt;&lt;/Parent&gt; 如果我们使用props.children.map函数来遍历时会受到异常提示，因为在这种情况下props.children是对象（object）而不是数组（array）。React 当且仅当超过一个子元素的情况下会将props.children设置为数组，就像下面这个代码片： 1234567&lt;Parent&gt; &lt;h1&gt;Welcome.&lt;/h1&gt; &lt;h2&gt;props.children will now be an array&lt;/h2&gt;&lt;/Parent&gt; 这也就是我们优先选择使用React.Children.map函数的原因，其已经将props.children不同类型的情况考虑在内了。 概述下 React 中的事件处理逻辑为了解决跨浏览器兼容性问题，React 会将浏览器原生事件（Browser Native Event）封装为合成事件（SyntheticEvent）传入设置的事件处理器中。这里的合成事件提供了与原生事件相同的接口，不过它们屏蔽了底层浏览器的细节差异，保证了行为的一致性。另外有意思的是，React 并没有直接将事件附着到子元素上，而是以单一事件监听器的方式将所有的事件发送到顶层进行处理。这样 React 在更新 DOM 的时候就不需要考虑如何去处理附着在 DOM 上的事件监听器，最终达到优化性能的目的。 createElement 与 cloneElement 的区别是什么？createElement 函数是 JSX 编译之后使用的创建 React Element 的函数，而 cloneElement 则是用于复制某个元素并传入新的 Props。 传入 setState 函数的第二个参数的作用是什么？该函数会在setState函数调用完成并且组件开始重渲染的时候被调用，我们可以用该函数来监听渲染是否完成： 12345678this.setState( &#123; username: &apos;tylermcginnis33&apos; &#125;, () =&gt; console.log(&apos;setState has finished and the component has re-rendered.&apos;)) 下述代码有错吗？ 123456789this.setState((prevState, props) =&gt; &#123; return &#123; streak: prevState.streak + props.count &#125;&#125;) 这段代码没啥问题，不过只是不太常用罢了，详细可以参考React中setState同步更新策略]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端文件断点续传]]></title>
      <url>%2F2017%2F04%2F11%2F%E5%89%8D%E7%AB%AF%E6%96%87%E4%BB%B6%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0%2F</url>
      <content type="text"><![CDATA[本文通过断点续传的简单例子（前端文件提交+后端PHP文件接收），理解其大致的实现过程 还是先以图片为例，看看最后的样子 一、一些知识准备断点续传，既然有断，那就应该有文件分割的过程，一段一段的传。 以前文件无法分割，但随着HTML5新特性的引入，类似普通字符串、数组的分割，我们可以可以使用slice方法来分割文件。 所以断点续传的最基本实现也就是：前端通过FileList对象获取到相应的文件，按照指定的分割方式将大文件分段，然后一段一段地传给后端，后端再按顺序一段段将文件进行拼接。 而我们需要对FileList对象进行修改再提交，在之前的文章中知晓了这种提交的一些注意点，因为FileList对象不能直接更改，所以不能直接通过表单的.submit()方法上传提交，需要结合FormData对象生成一个新的数据，通过Ajax进行上传操作。 二、实现过程 这个例子实现了文件断点续传的基本功能，不过手动的“暂停上传”操作还未实现成功，可以在上传过程中刷新页面来模拟上传的中断，体验“断点续传”、 有可能还有其他一些小bug，但基本逻辑大致如此。 前端实现 首先选择文件，列出选中的文件列表信息，然后可以自定义的做上传操作 （1）所以先设置好页面DOM结构 这里一并将CSS样式扔出来 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849body &#123; font-family: Arial;&#125;form &#123; margin: 50px auto; width: 600px;&#125;input[type=&quot;button&quot;] &#123; cursor: pointer;&#125;table &#123; display: none; margin-top: 15px; border: 1px solid #ddd; border-collapse: collapse;&#125;table th &#123; color: #666;&#125;table td, table th &#123; padding: 5px; border: 1px solid #ddd; text-align: center; font-size: 14px;&#125; （2）接下来是JS的实现解析 通过FileList对象我们能获取到文件的一些信息 其中的size就是文件的大小，文件的分分割分片需要依赖这个 这里的size是字节数，所以在界面显示文件大小时，可以这样转化 12345678910111213141516// 计算文件大小size = file.size &gt; 1024 ? file.size / 1024 &gt; 1024 ? file.size / (1024 * 1024) &gt; 1024 ? (file.size / (1024 * 1024 * 1024)).toFixed(2) + &apos;GB&apos; : (file.size / (1024 * 1024)).toFixed(2) + &apos;MB&apos; : (file.size / 1024).toFixed(2) + &apos;KB&apos; : (file.size).toFixed(2) + &apos;B&apos;; 选择文件后显示文件的信息，在模版中替换一下数据 // 更新文件信息列表123456789101112131415uploadItem.push(uploadItemTpl .replace(/&#123;&#123;fileName&#125;&#125;/g, file.name) .replace(&apos;&#123;&#123;fileType&#125;&#125;&apos;, file.type || file.name.match(/\.\w+$/) + &apos;文件&apos;) .replace(&apos;&#123;&#123;fileSize&#125;&#125;&apos;, size) .replace(&apos;&#123;&#123;progress&#125;&#125;&apos;, progress) .replace(&apos;&#123;&#123;totalSize&#125;&#125;&apos;, file.size) .replace(&apos;&#123;&#123;uploadVal&#125;&#125;&apos;, uploadVal)); 不过，在显示文件信息的时候，可能这个文件之前之前已经上传过了，为了断点续传，需要判断并在界面上做出提示 通过查询本地看是否有相应的数据（这里的做法是当本地记录的是已经上传100%时，就直接是重新上传而不是继续上传了） // 初始通过本地记录，判断该文件是否曾经上传过1234567891011percent = window.localStorage.getItem(file.name + &apos;_p&apos;);if (percent &amp;&amp; percent !== &apos;100.0&apos;) &#123; progress = &apos;已上传 &apos; + percent + &apos;%&apos;; uploadVal = &apos;继续上传&apos;;&#125; 显示了文件信息列表 点击开始上传，可以上传相应的文件 上传文件的时候需要就将文件进行分片分段 比如这里配置的每段1024B，总共chunks段（用来判断是否为末段），第chunk段，当前已上传的百分比percent等 需要提一下的是这个暂停上传的操作，其实我还没实现出来，暂停不了无奈ing… 接下来是分段过程 // 上传之前查询是否以及上传过分片123chunk = window.localStorage.getItem(fileName + &apos;_chunk&apos;) || 0;chunk = parseInt(chunk, 10); 文件应该支持覆盖上传，所以如果文件以及上传完了，现在再上传，应该重置数据以支持覆盖（不然后端就直接追加blob数据了） 1234567891011// 如果第一次上传就为末分片，即文件已经上传完成，则重新覆盖上传if (times === &apos;first&apos; &amp;&amp; isLastChunk === 1) &#123; window.localStorage.setItem(fileName + &apos;_chunk&apos;, 0); chunk = 0; isLastChunk = 0;&#125; 这个times其实就是个参数，因为要在上一分段传完之后再传下一分段，所以这里的做法是在回调中继续调用这个上传操作 接下来就是真正的文件上传操作了，用Ajax上传，因为用到了FormData对象，所以不要忘了在$.ajax({}加上这个配置processData: false 上传了一个分段，通过返回的结果判断是否上传完毕，是否继续上传 继续下一分段的上传时，就进行了递归操作，按顺序地上传下一分段 截个图.. 这是完整的JS逻辑，代码有点儿注释了应该不难看懂吧哈哈 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387// 全部上传操作$(document).on(&apos;click&apos;, &apos;#upload-all-btn&apos;, function () &#123; // 未选择文件 if (!$(&apos;#myFile&apos;).val()) &#123; $(&apos;#myFile&apos;).focus(); &#125; // 模拟点击其他可上传的文件 else &#123; $(&apos;#upload-list .upload-item-btn&apos;).each(function () &#123; $(this).click(); &#125;); &#125;&#125;);// 选择文件-显示文件信息$(&apos;#myFile&apos;).change(function (e) &#123; var file, uploadItem = [], uploadItemTpl = $(&apos;#file-upload-tpl&apos;).html(), size, percent, progress = &apos;未上传&apos;, uploadVal = &apos;开始上传&apos;; for (var i = 0, j = this.files.length; i &lt; j; ++i) &#123; file = this.files[i]; percent = undefined; progress = &apos;未上传&apos;; uploadVal = &apos;开始上传&apos;; // 计算文件大小 size = file.size &gt; 1024 ? file.size / 1024 &gt; 1024 ? file.size / (1024 * 1024) &gt; 1024 ? (file.size / (1024 * 1024 * 1024)).toFixed(2) + &apos;GB&apos; : (file.size / (1024 * 1024)).toFixed(2) + &apos;MB&apos; : (file .size / 1024).toFixed(2) + &apos;KB&apos; : (file.size).toFixed(2) + &apos;B&apos;; // 初始通过本地记录，判断该文件是否曾经上传过 percent = window.localStorage.getItem(file.name + &apos;_p&apos;); if (percent &amp;&amp; percent !== &apos;100.0&apos;) &#123; progress = &apos;已上传 &apos; + percent + &apos;%&apos;; uploadVal = &apos;继续上传&apos;; &#125; // 更新文件信息列表 uploadItem.push(uploadItemTpl .replace(/&#123;&#123;fileName&#125;&#125;/g, file.name) .replace(&apos;&#123;&#123;fileType&#125;&#125;&apos;, file.type || file.name.match(/\.\w+$/) + &apos;文件&apos;) .replace(&apos;&#123;&#123;fileSize&#125;&#125;&apos;, size) .replace(&apos;&#123;&#123;progress&#125;&#125;&apos;, progress) .replace(&apos;&#123;&#123;totalSize&#125;&#125;&apos;, file.size) .replace(&apos;&#123;&#123;uploadVal&#125;&#125;&apos;, uploadVal)); &#125; $(&apos;#upload-list&apos;).children(&apos;tbody&apos;).html(uploadItem.join(&apos;&apos;)) .end().show();&#125;);/*** 上传文件时，提取相应匹配的文件项* @param &#123;String&#125; fileName 需要匹配的文件名* @return &#123;FileList&#125; 匹配的文件项目*/function findTheFile(fileName) &#123; var files = $(&apos;#myFile&apos;)[0].files, theFile; for (var i = 0, j = files.length; i &lt; j; ++i) &#123; if (files[i].name === fileName) &#123; theFile = files[i]; break; &#125; &#125; return theFile ? theFile : [];&#125;// 上传文件$(document).on(&apos;click&apos;, &apos;.upload-item-btn&apos;, function () &#123; var $this = $(this), state = $this.attr(&apos;data-state&apos;), msg = &#123; done: &apos;上传成功&apos;, failed: &apos;上传失败&apos;, in : &apos;上传中...&apos;, paused: &apos;暂停中...&apos; &#125;, fileName = $this.attr(&apos;data-name&apos;), $progress = $this.closest(&apos;tr&apos;).find(&apos;.upload-progress&apos;), eachSize = 1024, totalSize = $this.attr(&apos;data-size&apos;), chunks = Math.ceil(totalSize / eachSize), percent, chunk, // 暂停上传操作 isPaused = 0; // 进行暂停上传操作 // 未实现，这里通过动态的设置isPaused值并不能阻止下方ajax请求的调用 if (state === &apos;uploading&apos;) &#123; $this.val(&apos;继续上传&apos;).attr(&apos;data-state&apos;, &apos;paused&apos;); $progress.text(msg[&apos;paused&apos;] + percent + &apos;%&apos;); isPaused = 1; console.log(&apos;暂停：&apos;, isPaused); &#125; // 进行开始/继续上传操作 else if (state === &apos;paused&apos; || state === &apos;default&apos;) &#123; $this.val(&apos;暂停上传&apos;).attr(&apos;data-state&apos;, &apos;uploading&apos;); isPaused = 0; &#125; // 第一次点击上传 startUpload(&apos;first&apos;); // 上传操作 times: 第几次 function startUpload(times) &#123; // 上传之前查询是否以及上传过分片 chunk = window.localStorage.getItem(fileName + &apos;_chunk&apos;) || 0; chunk = parseInt(chunk, 10); // 判断是否为末分片 var isLastChunk = (chunk == (chunks - 1) ? 1 : 0); // 如果第一次上传就为末分片，即文件已经上传完成，则重新覆盖上传 if (times === &apos;first&apos; &amp;&amp; isLastChunk === 1) &#123; window.localStorage.setItem(fileName + &apos;_chunk&apos;, 0); chunk = 0; isLastChunk = 0; &#125; // 设置分片的开始结尾 var blobFrom = chunk * eachSize, // 分段开始 blobTo = (chunk + 1) * eachSize &gt; totalSize ? totalSize : (chunk + 1) * eachSize, // 分段结尾 percent = (100 * blobTo / totalSize).toFixed(1), // 已上传的百分比 timeout = 5000, // 超时时间 fd = new FormData($(&apos;#myForm&apos;)[0]); fd.append(&apos;theFile&apos;, findTheFile(fileName).slice(blobFrom, blobTo)); // 分好段的文件 fd.append(&apos;fileName&apos;, fileName); // 文件名 fd.append(&apos;totalSize&apos;, totalSize); // 文件总大小 fd.append(&apos;isLastChunk&apos;, isLastChunk); // 是否为末段 fd.append(&apos;isFirstUpload&apos;, times === &apos;first&apos; ? 1 : 0); // 是否是第一段（第一次上传） // 上传 $.ajax(&#123; type: &apos;post&apos;, url: &apos;/fileTest.php&apos;, data: fd, processData: false, contentType: false, timeout: timeout, success: function (rs) &#123; rs = JSON.parse(rs); // 上传成功 if (rs.status === 200) &#123; // 记录已经上传的百分比 window.localStorage.setItem(fileName + &apos;_p&apos;, percent); // 已经上传完毕 if (chunk === (chunks - 1)) &#123; $progress.text(msg[&apos;done&apos;]); $this.val(&apos;已经上传&apos;).prop(&apos;disabled&apos;, true).css(&apos;cursor&apos;, &apos;not-allowed&apos;); if (!$(&apos;#upload-list&apos;).find(&apos;.upload-item-btn:not(:disabled)&apos;).length) &#123; $(&apos;#upload-all-btn&apos;).val(&apos;已经上传&apos;).prop(&apos;disabled&apos;, true).css(&apos;cursor&apos;, &apos;not-allowed&apos;); &#125; &#125; else &#123; // 记录已经上传的分片 window.localStorage.setItem(fileName + &apos;_chunk&apos;, ++chunk); $progress.text(msg[&apos;in&apos;] + percent + &apos;%&apos;); // 这样设置可以暂停，但点击后动态的设置就暂停不了.. // if (chunk == 10) &#123; // isPaused = 1; // &#125; console.log(isPaused); if (!isPaused) &#123; startUpload(); &#125; &#125; &#125; // 上传失败，上传失败分很多种情况，具体按实际来设置 else if (rs.status === 500) &#123; $progress.text(msg[&apos;failed&apos;]); &#125; &#125;, error: function () &#123; $progress.text(msg[&apos;failed&apos;]); &#125; &#125;); &#125;&#125;); 后端实现 这里的后端实现还是比较简单的，主要用依赖了 file_put_contents、file_get_contents 这两个方法 要注意一下，通过FormData对象上传的文件对象，在PHP中也是通过$_FILES全局对象获取的，还有为了避免上传后文件中文的乱码，用一下iconv 断点续传支持文件的覆盖，所以如果已经存在完整的文件，就将其删除 1234567// 如果第一次上传的时候，该文件已经存在，则删除文件重新上传if ($isFirstUpload == &apos;1&apos; &amp;&amp; file_exists(&apos;upload/&apos;.$fileName) &amp;&amp; filesize(&apos;upload/&apos;.$fileName) == $totalSize) &#123; unlink(&apos;upload/&apos;.$fileName);&#125; 使用上述的两个方法，进行文件信息的追加，别忘了加上 FILE_APPEND 这个参数~ 一般在传完后都需要进行文件的校验吧，所以这里简单校验了文件大小是否一致 根据实际需求的不同有不同的错误处理方法，这里就先不多处理了 完整的PHP部分]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浅析前端渲染机制]]></title>
      <url>%2F2017%2F04%2F10%2F%E6%B5%85%E6%9E%90%E5%89%8D%E7%AB%AF%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%2F</url>
      <content type="text"><![CDATA[作为一个前端开发，最常见的运行环境应该是浏览器吧，为了更好的通过浏览器把优秀的产品带给用户，也为了更好的发展自己的前端职业之路，有必要了解从我们在浏览器地址栏输入网址到看到页面这期间浏览器是如何进行工作的,进而了解如何更好的优化实践，本篇主要围绕这两点展开阐述。前端页面渲染机制可谓是老生常谈，但又很有必要再谈的话题，于是还是决定写一篇，即是对知识的回顾总结，又能与大家分享，何乐而不为。网上相关类型的文章也很多，有兴趣的可以多学习一下。 浏览器在介绍浏览器工作流程之前，先了解一下主流浏览器的基础结构，本文所介绍的浏览器主要为开源的Chrome，FireFox及部分开源的Safari，这也是目前市场占比最高的几大浏览器，以本人博客网站为例，可以大致看出各浏览器使用比例： 浏览器占比浏览器基础结构 浏览器基础结构主要包括如下7部分： 1.用户界面（User Interface）:用户所看到及与之交互的功能组件，如地址栏，返回，前进按钮等； 2.浏览器引擎（Browser engine）:负责控制和管理下一级的渲染引擎； 3.渲染引擎（Rendering engine）:负责解析用户请求的内容（如HTML或XML，渲染引擎会解析HTML或XML，以及相关CSS，然后返回解析后的内容）； 4.网络（Networking）:负责处理网络相关的事务，如HTTP请求等； 5.UI后端（UI backend）:负责绘制提示框等浏览器组件，其底层使用的是操作系统的用户接口； 6.JavaScript解释器（JavaScript interpreter）:负责解析和执行JavaScript代码； 7.数据存储（Data storage）:负责持久存储诸如cookie和缓存等应用数据。浏览器基础结构浏览器内核 各大主要浏览器使用内核也是有差别的，大致可以分为以下几类： Trident内核： IEWebkit内核：Chrome,SafariGecko内核：FireFox 网络当用户访问页面时，浏览器需要获取用户请求内容，这个过程主要涉及浏览器网络模块： 1.用户在地址栏输入域名，如baidu.com，DNS（Domain Name System，域名解析系统）服务器根据输入的域名查找对应IP，然后向该IP地址发起请求；DNS 2.浏览器获得并解析服务器的返回内容(HTTP response)；3.浏览器加载HTML文件及文件内包含的外部引用文件及图片，多媒体等资源。DNS预解析（DNS PREFETCH） 浏览器DNS解析大多时候较快，且会缓存常用域名的解析值，但是如果网站涉及多域名，在对每一个域名访问时都需要先解析出IP地址，而我们希望在跳转或者请求其他域名资源时尽量快，则可以开启域名预解析，浏览器会在空闲时提前解析声明需要预解析的域名，如： 域名预解析多进程 我们通常说JavaScript执行是单进程的，但是浏览器网络部分通常是有几个平行进程同时开启，但是也会有限制，一般为2-6个。 渲染引擎及关键渲染路径（Critical Rendering Path）渲染引擎所做的事是将请求内容展现给我们，默认支持HTML,XML和图片类型，对于其他诸如PDF等类型的内容则需要安装相应插件，但浏览器的展示工作流程基本是一样的。 通过网络模块加载到HTML文件后渲染引擎渲染流程如下，这也通常被称作关键渲染路径（Critical Rendering Path）： 1.构建DOM树(DOM tree)：从上到下解析HTML文档生成DOM节点树（DOM tree），也叫内容树（content tree）； 2.构建CSSOM(CSS Object Model)树：加载解析样式生成CSSOM树； 3.执行JavaScript：加载并执行JavaScript代码（包括内联代码或外联JavaScript文件）； 4.构建渲染树(render tree)：根据DOM树和CSSOM树,生成渲染树(render tree)；渲染树：按顺序展示在屏幕上的一系列矩形，这些矩形带有字体，颜色和尺寸等视觉属性。 5.布局（layout）：根据渲染树将节点树的每一个节点布局在屏幕上的正确位置； 6.绘制（painting）：遍历渲染树绘制所有节点，为每一个节点适用对应的样式，这一过程是通过UI后端模块完成；关键渲染路径为了更友好的用户体验，浏览器会尽可能快的展现内容，而不会等到文档所有内容到达才开始解析和构建/布局渲染树，而是每次处理一部分，并展现在屏幕上，这也是为什么我们经常可以看到页面加载的时候内容是从上到下一点一点展现的。 流程图Webkit渲染引擎流程如下图： Gecko渲染引擎流程如下图： 如上图，Webkit浏览器和Gecko浏览器渲染流程大致相同,不同的是：1231.Webkit浏览器中的渲染树(render tree)，在Gecko浏览器中对应的则是框架树（frame tree）,渲染对象(render object)对应的是框架（frame）;2.Webkit中的布局（Layout）过程，在Gecko中称为回流（Reflow）,本质是一样的，后文会解释回流的另一层含义–重新布局；3.Gecko中HTML和DOM树中间多了一层内容池（Content sink）,可以理解成生成DOM元素的工厂。 单进程不同于网络部分的多进程渲染引擎是单线程工作的，意味着渲染流程是一步一步渐进完成的。 解析文档(PARSER HTML)在详细介绍浏览器渲染文档之前，先应该理解浏览器如何解析文档：解析文档的顺序，对于CSS和JavaScript如何处理等。 解析顺序浏览器按从上到下的顺序扫描解析文档； 解析样式和脚本脚本 或许是由于通常会在JavaScript脚本中改变文档DOM结构，于是浏览器以同步方式解析，加载和执行脚本，浏览器在解析文档时，当解析到标签时，会解析其中的脚本（对于外链的JavaScript文件，需要先加载该文件内容，再进行解析），然后立即执行，这整个过程都会阻塞文档解析，直到脚本执行完才会继续解析文档。就是说由于脚本是同步加载和执行的，它会阻塞文档解析，这也解释了为什么现在通常建议将标签放在标签前面，而不是放在标签里。现在HTML5提供defer和async两个属性支持延迟和异步加载JavaScript文件，如：1&lt;script defer src=&quot;script.js&quot;&gt; 改进 针对上文说的脚本阻塞文档解析，主流浏览器如Chrome和FireFox等都有一些优化，比如在执行脚本时，开启另一个进程解析剩余的文档以找出并加载其他的待下载外部资源（不改变主进程的DOM树，仅优化加载外部资源）。 样式 不同于脚本，浏览器对样式的处理并不会阻塞文档解析，大概是因为样式表并不会改变DOM结构。 样式表与脚本 你可能想问样式是否会阻塞脚本文件的加载执行呢？正常情况是不会的，但是存在一个问题是通常我们会在脚本中请求样式信息，但是在文档解析时，如果样式尚未加载或解析，将会得到错误信息，对于这一问题，FireFox浏览器和Webkit浏览器处理策略不同： 当存在有样式文件未被加载和解析时，FireFox浏览器会阻塞所有脚本；而Webkit浏览器只会阻塞操作了改文件内声明的样式属性的脚本。构建DOM树 DOM，即文档对象模型（Document Object Model）,DOM树，即文档内所有节点构成的一个树形结构。 假设浏览器获取返回的如下HTML文档： 12345678910111213&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./theme.css&quot;&gt;&lt;/link&gt; &lt;script src=&quot;./config.js&quot;&gt;&lt;/script&gt; &lt;title&gt;关键渲染路径&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 class=&quot;title&quot;&gt;关键渲染路径&lt;/h1&gt; &lt;p&gt;关键渲染路径介绍&lt;/p&gt; &lt;footer&gt;@copyright2017&lt;/footer&gt;&lt;/body&gt;&lt;/html&gt; 首先浏览器从上到下依次解析文档构建DOM树，如下： 构建CSSOM树 CSSOM，即CSS对象模型（CSS Object Model），CSSOM树，与DOM树结构相似，只是另外为每一个节点关联了样式信息。 theme.css样式内容如下： 123456789101112html, body &#123;width: 100%;height: 100%;background-color: #fcfcfc;&#125;.title &#123;font-size: 20px;&#125;.footer &#123;font-size: 12px;color: #aaa;&#125; 构建CSSOM树如图： 执行JAVASCRIPT 上文已经阐述了文档解析时对脚本的处理，我们得知脚本加载，解析和执行会阻塞文档解析，而在特殊情况下样式的加载和解析也会阻塞脚本，所以现在推荐的实践是标签放在标签前面。 构建渲染树(RENDER TREE) DOM树和CSSOM树都构建完了，接着浏览器会构建渲染树： 渲染树，代表一个文档的视觉展示，浏览器通过它将文档内容绘制在浏览器窗口，展示给用户，它由按顺序展示在屏幕上的一系列矩形对象组成，这些矩形对象都带有字体，颜色和尺寸，位置等视觉样式属性。对于这些矩对象，FireFox称之为框架（frame）,Webkit浏览器称之为渲染对象（render object, renderer），后文统称为渲染对象。这里把渲染树节点称为矩形对象，是因为，每一个渲染对象都代表着其对应DOM节点的CSS盒子,该盒子包含了尺寸，位置等几何信息，同时它指向一个样式对象包含其他视觉样式信息。 渲染树与DOM树每一个渲染对象都对应着DOM节点，但是非视觉（隐藏，不占位）DOM元素不会插入渲染树，如元素或声明display: none;的元素，渲染对象与DOM节点不是简单的一对一的关系，一个DOM可以对应一个渲染对象，但一个DOM元素也可能对应多个渲染对象，因为有很多元素不止包含一个CSS盒子，如当文本被折行时，会产生多个行盒，这些行会生成多个渲染对象；又如行内元素同时包含块元素和行内元素，则会创建一个匿名块级盒包含内部行内元素，此时一个DOM对应多个矩形对象（渲染对象）。 渲染树及其对应DOM树如图： 图中渲染树viewport即视口，是文档的初始包含块，scroll代表滚动区域，详见CSS之视觉格式化模型(Visual Formatting Model)渲染树并不会包含显式或隐式地display：none;的标签元素。布局（LAYOUT）或回流（REFLOW，RELAYOUT） 创建渲染树后，下一步就是布局（Layout）,或者叫回流（reflow,relayout），这个过程就是通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸，将其安置在浏览器窗口的正确位置，而有些时候我们会在文档布局完成后对DOM进行修改，这时候可能需要重新进行布局，也可称其为回流，本质上还是一个布局的过程，每一个渲染对象都有一个布局或者回流方法，实现其布局或回流。 流（flow）HTML采用的是基于流的方式定位布局，其按照从左到右，从上到下的顺序进行排列，详见CSS定位机制。 全局布局与局部布局对渲染树的布局可以分为全局和局部的，全局即对整个渲染树进行重新布局，如当我们改变了窗口尺寸或方向或者是修改了根元素的尺寸或者字体大小等；而局部布局可以是对渲染树的某部分或某一个渲染对象进行重新布局。 脏位系统（dirty bit system）大多数web应用对DOM的操作都是比较频繁，这意味着经常需要对DOM进行布局和回流，而如果仅仅是一些小改变，就触发整个渲染树的回流，这显然是不好的，为了避免这种情况，浏览器使用了脏位系统，只有一个渲染对象改变了或者某渲染对象及其子渲染对象脏位值为”dirty”时，说明需要回流。 表示需要布局的脏位值有两种： “dirty”–自身改变，需要回流“children are dirty”–子节点改变，需要回流布局过程布局是一个从上到下，从外到内进行的递归过程，从根渲染对象，即对应着HTML文档根元素，然后下一级渲染对象，如对应着元素，如此层层递归，依次计算每一个渲染对象的几何信息（位置和尺寸）。 几何信息-位置和尺寸，即相对于窗口的坐标和尺寸，如根渲染对象，其坐标为（0， 0），尺寸即是视口尺寸（浏览器窗口的可视区域）。 每一个渲染对象的布局流程基本如： 1.计算此渲染对象的宽度（width）；2.遍历此渲染对象的所有子级，依次：2.1设置子级渲染对象的坐标2.2判断是否需要触发子渲染对象的布局或回流方法，计算子渲染对象的高度（height）3.设置此渲染对象的高度：根据子渲染对象的累积高，margin和padding的高度设置其高度；4.设置此渲染对象脏位值为false。强制回流在渲染树布局完成后，再次操作文档，改变文档的内容或结构，或者元素定位时，会触发回流，即需要重新布局，如请求某DOM的”offsetHeight”样式信息等诸多情况： DOM操作，如增加，删除，修改或移动；变更内容；激活伪类；访问或改变某些CSS属性（包括修改样式表或元素类名或使用JavaScript操作等方式）；浏览器窗口变化（滚动或尺寸变化） $(&apos;body&apos;).css(&apos;padding&apos;); // reflow 有过CSS3动画开发经验的同学可能会有经历，如下入场动画： .slide-left { -webkit-transition: margin-left 1s ease-out; -moz-transition: margin-left 1s ease-out; -o-transition: margin-left 1s ease-out; transition: margin-left 1s ease-out; } 然后执行如下脚本： var $slide = $(&apos;.slide-left&apos;); $slide.css({ &quot;margin-left&quot;: &quot;100px&quot; }).addClass(&apos;slide-left&apos;); $slide.css({ &quot;margin-left&quot;: &quot;10px&quot; }); 我们会发现并没有效果，为什么呢？因为对margin-left的修改并没有触发回流，元素margin-left值的改变被缓存，如果我们在中间强制触发回流： var $slide = $(&apos;.slide-left&apos;); $slide.css({ &quot;margin-left&quot;: &quot;100px&quot; }); console.log($slide.css(&apos;padding&apos;); $slide.addClass(&apos;slide-left&apos;); $slide.css({ &quot;margin-left&quot;: &quot;10px&quot; }); 再看就达到了预期效果。 绘制（PAINTING） 最后是绘制(paint)阶段或重绘（repaint）阶段，浏览器UI组件将遍历渲染树并调用渲染对象的绘制（paint）方法，将内容展现在屏幕上，也有可能在之后对DOM进行修改，需要重新绘制渲染对象，也就是重绘，绘制和重绘的关系可以参考布局和回流的关系。 全局与局部绘制与布局相似，绘制也分为全局和局部绘制，即对整个渲染树或某些渲染对象进行绘制。 触发重绘我们已经知道很多操作可能会触发回流，那么什么时候可能触发重绘呢，通常，当改变元素的视觉样式，如background-color,visibility，margin，padding或字体颜色时会触发全局或局部重绘，如： $(&apos;body&apos;).css(&apos;color&apos;, &apos;red&apos;); // repaint $(&apos;body&apos;).css(&apos;margin&apos;, &apos;2px&apos;); // reflow, repaint 页面渲染优化浏览器对上文介绍的关键渲染路径进行了很多优化，针对每一次变化产生尽量少的操作，还有优化判断重新绘制或布局的方式等等。 在改变文档根元素的字体颜色等视觉性信息时，会触发整个文档的重绘，而改变某元素的字体颜色则只触发特定元素的重绘；改变元素的位置信息会同时触发此元素（可能还包括其兄弟元素或子级元素）的布局和重绘。某些重大改变，如更改文档根元素的字体尺寸，则会触发整个文档的重新布局和重绘，据此及上文所述，推荐以下优化和实践：` 1.HTML文档结构层次尽量少，最好不深于六层； 2.脚本尽量后放，放在前即可； 3.少量首屏样式内联放在标签内； 4.样式结构层次尽量简单； 5.在脚本中尽量减少DOM操作，尽量缓存访问DOM的样式信息，避免过度触发回流； 6.减少通过JavaScript代码修改元素样式，尽量使用修改class名方式操作样式或动画； 7.动画尽量使用在绝对定位或固定定位的元素上； 8.隐藏在屏幕外，或在页面滚动时，尽量停止动画； 9.尽量缓存DOM查找，查找器尽量简洁； 10.涉及多域名的网站，可以开启域名预解析` 实例当我们访问一个页面时，浏览器渲染事件详细日志图如下：浏览器渲染事件日志 1.发起请求；2.解析HTML；3.解析样式；4.执行JavaScript；5.布局；6.绘制]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[移动端知识点整理]]></title>
      <url>%2F2017%2F04%2F08%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%B5%84%E6%BA%90%E6%95%B4%E7%90%86%2F</url>
      <content type="text"><![CDATA[meta基础知识 H5页面窗口自动调整到设备宽度，并禁止用户缩放页面 &lt;meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no" /&gt; 忽略将页面中的数字识别为电话号码 &lt;meta name="format-detection" content="telephone=no" /&gt; 忽略Android平台中对邮箱地址的识别 &lt;meta name="format-detection" content="email=no" /&gt; 当网站添加到主屏幕快速启动方式，可隐藏地址栏，仅针对ios的safari &lt;meta name="apple-mobile-web-app-capable" content="yes" /&gt; &lt;!-- ios7.0版本以后，safari上已看不到效果 --&gt; 将网站添加到主屏幕快速启动方式，仅针对ios的safari顶端状态条的样式 &lt;meta name="apple-mobile-web-app-status-bar-style" content="black" /&gt; &lt;!-- 可选default、black、black-translucent --&gt; viewport模板 viewport模板&mdash;&mdash;通用 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" name="viewport"&gt; &lt;meta content="yes" name="apple-mobile-web-app-capable"&gt; &lt;meta content="black" name="apple-mobile-web-app-status-bar-style"&gt; &lt;meta content="telephone=no" name="format-detection"&gt; &lt;meta content="email=no" name="format-detection"&gt; &lt;title&gt;标题&lt;/title&gt; &lt;link rel="stylesheet" href="index.css"&gt; &lt;/head&gt; &lt;body&gt; 这里开始内容 &lt;/body&gt; &lt;/html&gt; &nbsp; viewport模板 -&nbsp;target-densitydpi=device-dpi，android 2.3.5以下版本不支持 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=750, user-scalable=no, target-densitydpi=device-dpi"&gt;&lt;!-- width取值与页面定义的宽度一致 --&gt; &lt;meta content="yes" name="apple-mobile-web-app-capable"&gt; &lt;meta content="black" name="apple-mobile-web-app-status-bar-style"&gt; &lt;meta content="telephone=no" name="format-detection"&gt; &lt;meta content="email=no" name="format-detection"&gt; &lt;title&gt;标题&lt;/title&gt; &lt;link rel="stylesheet" href="index.css"&gt; &lt;/head&gt; &lt;body&gt; 这里开始内容 &lt;/body&gt; &lt;/html&gt; &nbsp; 常见问题 移动端如何定义字体font-family 中文字体使用系统默认即可，英文用Helvetica /* 移动端定义字体的代码 */ body{font-family:Helvetica;} 参考《移动端使用字体的思考》 移动端字体单位font-size选择px还是rem 对于只需要适配少部分手机设备，且分辨率对页面影响不大的，使用px即可 对于需要适配各种移动设备，使用rem，例如只需要适配iPhone和iPad等分辨率差别比较挺大的设备 rem配置参考： html{font-size:10px} @media screen and (min-width:321px) and (max-width:375px){html{font-size:11px}} @media screen and (min-width:376px) and (max-width:414px){html{font-size:12px}} @media screen and (min-width:415px) and (max-width:639px){html{font-size:15px}} @media screen and (min-width:640px) and (max-width:719px){html{font-size:20px}} @media screen and (min-width:720px) and (max-width:749px){html{font-size:22.5px}} @media screen and (min-width:750px) and (max-width:799px){html{font-size:23.5px}} @media screen and (min-width:800px){html{font-size:25px}} 体验demo：http://1.peunzhang.sinaapp.com/demo/rem/index.html 移动端touch事件(区分webkit 和 winphone) 当用户手指放在移动设备在屏幕上滑动会触发的touch事件 以下支持webkit touchstart&mdash;&mdash;当手指触碰屏幕时候发生。不管当前有多少只手指 touchmove&mdash;&mdash;当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用event的preventDefault()可以阻止默认情况的发生：阻止页面滚动 touchend&mdash;&mdash;当手指离开屏幕时触发 touchcancel&mdash;&mdash;系统停止跟踪触摸时候会触发。例如在触摸过程中突然页面alert()一个提示框，此时会触发该事件，这个事件比较少用 TouchEvent touches：屏幕上所有手指的信息 targetTouches：手指在目标区域的手指信息 changedTouches：最近一次触发该事件的手指信息 touchend时，touches与targetTouches信息会被删除，changedTouches保存的最后一次的信息，最好用于计算手指信息 参数信息(changedTouches[0]) clientX、clientY在显示区的坐标 target：当前元素 参考：https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent 以下支持winphone 8 MSPointerDown&mdash;&mdash;当手指触碰屏幕时候发生。不管当前有多少只手指 MSPointerMove&mdash;&mdash;当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用css的html{-ms-touch-action: none;}可以阻止默认情况的发生：阻止页面滚动 MSPointerUp&mdash;&mdash;当手指离开屏幕时触发 移动端click屏幕产生200-300 ms的延迟响应 移动设备上的web网页是有300ms延迟的，玩玩会造成按钮点击延迟甚至是点击失效。 以下是历史原因，来源一个公司内一个同事的分享： 2007年苹果发布首款iphone上IOS系统搭载的safari为了将适用于PC端上大屏幕的网页能比较好的展示在手机端上，使用了双击缩放(double tap to zoom)的方案，比如你在手机上用浏览器打开一个PC上的网页，你可能在看到页面内容虽然可以撑满整个屏幕，但是字体、图片都很小看不清，此时可以快速双击屏幕上的某一部分，你就能看清该部分放大后的内容，再次双击后能回到原始状态。 双击缩放是指用手指在屏幕上快速点击两次，iOS 自带的 Safari 浏览器会将网页缩放至原始比例。 原因就出在浏览器需要如何判断快速点击上，当用户在屏幕上单击某一个元素时候，例如跳转链接&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;，此处浏览器会先捕获该次单击，但浏览器不能决定用户是单纯要点击链接还是要双击该部分区域进行缩放操作，所以，捕获第一次单击后，浏览器会先Hold一段时间t，如果在t时间区间里用户未进行下一次点击，则浏览器会做单击跳转链接的处理，如果t时间里用户进行了第二次单击操作，则浏览器会禁止跳转，转而进行对该部分区域页面的缩放操作。那么这个时间区间t有多少呢？在IOS safari下，大概为300毫秒。这就是延迟的由来。造成的后果用户纯粹单击页面，页面需要过一段时间才响应，给用户慢体验感觉，对于web开发者来说是，页面js捕获click事件的回调函数处理，需要300ms后才生效，也就间接导致影响其他业务逻辑的处理。 解决方案： fastclick可以解决在手机上点击事件的300ms延迟 zepto的touch模块，tap事件也是为了解决在click的延迟问题 触摸事件的响应顺序 1、ontouchstart 2、ontouchmove 3、ontouchend 4、onclick 解决300ms延迟的问题，也可以通过绑定ontouchstart事件，加快对事件的响应 什么是Retina 显示屏，带来了什么问题 retina：一种具备超高像素密度的液晶屏，同样大小的屏幕上显示的像素点由1个变为多个，如在同样带下的屏幕上，苹果设备的retina显示屏中，像素点1个变为4个 在高清显示屏中的位图被放大，图片会变得模糊，因此移动端的视觉稿通常会设计为传统PC的2倍 那么，前端的应对方案是： 设计稿切出来的图片长宽保证为偶数，并使用backgroud-size把图片缩小为原来的1/2 //例如图片宽高为：200px*200px，那么写法如下 .css{width:100px;height:100px;background-size:100px 100px;} 其它元素的取值为原来的1/2，例如视觉稿40px的字体，使用样式的写法为20px .css{font-size:20px} 参考《高清显示屏原理及设计方案》 ios系统中元素被触摸时产生的半透明灰色遮罩怎么去掉 ios用户点击一个链接，会出现一个半透明灰色遮罩,&nbsp;如果想要禁用，可设置-webkit-tap-highlight-color的alpha值为0，也就是属性值的最后一位设置为0就可以去除半透明灰色遮罩 a,button,input,textarea{-webkit-tap-highlight-color: rgba(0,0,0,0;)} 部分android系统中元素被点击时产生的边框怎么去掉 android用户点击一个链接，会出现一个边框或者半透明灰色遮罩,&nbsp;不同生产商定义出来额效果不一样，可设置-webkit-tap-highlight-color的alpha值为0去除部分机器自带的效果 a,button,input,textarea{ -webkit-tap-highlight-color: rgba(0,0,0,0;) -webkit-user-modify:read-write-plaintext-only; } -webkit-user-modify有个副作用，就是输入法不再能够输入多个字符 另外，有些机型去除不了，如小米2 对于按钮类还有个办法，不使用a或者input标签，直接用div标签 参考《如何去除android上a标签产生的边框》 winphone系统a、input标签被点击时产生的半透明灰色背景怎么去掉 &lt;meta name="msapplication-tap-highlight" content="no"&gt; webkit表单元素的默认外观怎么重置 .css{-webkit-appearance:none;} webkit表单输入框placeholder的颜色值能改变么 input::-webkit-input-placeholder{color:#AAAAAA;} input:focus::-webkit-input-placeholder{color:#EEEEEE;} webkit表单输入框placeholder的文字能换行么 ios可以，android不行~ 在textarea标签下都可以换行~ IE10（winphone8）表单元素默认外观如何重置 禁用&nbsp;select&nbsp;默认下拉箭头 ::-ms-expand&nbsp;适用于表单选择控件下拉箭头的修改，有多个属性值，设置它隐藏&nbsp;(display:none)&nbsp;并使用背景图片来修饰可得到我们想要的效果。 select::-ms-expand { display: none; } 禁用&nbsp;radio&nbsp;和&nbsp;checkbox&nbsp;默认样式 ::-ms-check&nbsp;适用于表单复选框或单选按钮默认图标的修改，同样有多个属性值，设置它隐藏&nbsp;(display:none)&nbsp;并使用背景图片来修饰可得到我们想要的效果。 input[type=radio]::-ms-check,input[type=checkbox]::-ms-check{ display: none; } 禁用PC端表单输入框默认清除按钮 当表单文本输入框输入内容后会显示文本清除按钮，::-ms-clear&nbsp;适用于该清除按钮的修改，同样设置使它隐藏&nbsp;(display:none)&nbsp;并使用背景图片来修饰可得到我们想要的效果。 input[type=text]::-ms-clear,input[type=tel]::-ms-clear,input[type=number]::-ms-clear{ display: none; } 禁止ios 长按时不触发系统的菜单，禁止ios&amp;android长按时下载图片 .css{-webkit-touch-callout: none} 禁止ios和android用户选中文字 .css{-webkit-user-select:none} 参考《如何改变表单元素的外观(for Webkit and IE10)》 打电话发短信写邮件怎么实现 打电话 &lt;a href="tel:0755-10086"&gt;打电话给:0755-10086&lt;/a&gt; 发短信，winphone系统无效 &lt;a href="sms:10086"&gt;发短信给: 10086&lt;/a&gt; 写邮件，可参考《移动web页面给用户发送邮件的方法》 &lt;a href="mailto:peun@foxmail.com"&gt;peun@foxmail.com&lt;/a&gt; 模拟按钮hover效果 移动端触摸按钮的效果，可明示用户有些事情正要发生，是一个比较好体验，但是移动设备中并没有鼠标指针，使用css的hover并不能满足我们的需求，还好国外有个激活css的active效果，代码如下， &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" name="viewport"&gt; &lt;meta content="yes" name="apple-mobile-web-app-capable"&gt; &lt;meta content="black" name="apple-mobile-web-app-status-bar-style"&gt; &lt;meta content="telephone=no" name="format-detection"&gt; &lt;meta content="email=no" name="format-detection"&gt; &lt;style type="text/css"&gt; a{-webkit-tap-highlight-color: rgba(0,0,0,0);} .btn-blue{display:block;height:42px;line-height:42px;text-align:center;border-radius:4px;font-size:18px;color:#FFFFFF;background-color: #4185F3;} .btn-blue:active{background-color: #357AE8;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="btn-blue"&gt;按钮&lt;/div&gt; &lt;script type="text/javascript"&gt; document.addEventListener("touchstart", function(){}, true) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 兼容性ios5+、部分android 4+、winphone 8 要做到全兼容的办法，可通过绑定ontouchstart和ontouchend来控制按钮的类名 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" name="viewport"&gt; &lt;meta content="yes" name="apple-mobile-web-app-capable"&gt; &lt;meta content="black" name="apple-mobile-web-app-status-bar-style"&gt; &lt;meta content="telephone=no" name="format-detection"&gt; &lt;meta content="email=no" name="format-detection"&gt; &lt;style type="text/css"&gt; a{-webkit-tap-highlight-color: rgba(0,0,0,0);} .btn-blue{display:block;height:42px;line-height:42px;text-align:center;border-radius:4px;font-size:18px;color:#FFFFFF;background-color: #4185F3;} .btn-blue-on{background-color: #357AE8;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="btn-blue"&gt;按钮&lt;/div&gt; &lt;script type="text/javascript"&gt; var btnBlue = document.querySelector(".btn-blue"); btnBlue.ontouchstart = function(){this.className = "btn-blue btn-blue-on" } btnBlue.ontouchend = function(){this.className = "btn-blue" } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 屏幕旋转的事件和样式 事件 window.orientation，取值：正负90表示横屏模式、0和180表现为竖屏模式； window.onorientationchange = function(){ switch(window.orientation){ case -90: case 90: alert("横屏:" + window.orientation); case 0: case 180: alert("竖屏:" + window.orientation); break; } } 样式 //竖屏时使用的样式 @media all and (orientation:portrait) { .css{} } //横屏时使用的样式 @media all and (orientation:landscape) { .css{} } audio元素和video元素在ios和andriod中无法自动播放 应对方案：触屏即播 $('html').one('touchstart',function(){audio.play() }) 可参考《无法自动播放的audio元素》 摇一摇功能 HTML5 deviceMotion：封装了运动传感器数据的事件，可以获取手机运动状态下的运动加速度等数据。 var SHAKE_THRESHOLD = 2000; var last_update = 0; var x = y = z = last_x = last_y = last_z = 0; function init() { if (window.DeviceMotionEvent) { window.addEventListener('devicemotion', deviceMotionHandler, false); } else { alert('not support mobile event'); } } function deviceMotionHandler(eventData) { var acceleration = eventData.accelerationIncludingGravity; var curTime = new Date().getTime(); if ((curTime - last_update) &gt; 100) { var diffTime = curTime - last_update; last_update = curTime; x = acceleration.x; y = acceleration.y; z = acceleration.z; var speed = Math.abs(x + y + z - last_x - last_y - last_z) / diffTime * 10000; if (speed &gt; SHAKE_THRESHOLD) { //alert("摇动了"+SHAKE_THRESHOLD); } last_x = x; last_y = y; last_z = z; } } &nbsp; 手机拍照和上传图片 &lt;input type=&quot;file&quot;&gt;的accept 属性 &lt;!-- 选择照片 --&gt; &lt;input type=file accept="image/*"&gt; &lt;!-- 选择视频 --&gt; &lt;input type=file accept="video/*"&gt; 使用总结： ios 有拍照、录像、选取本地图片功能 部分android只有选取本地图片功能 winphone不支持 input控件默认外观丑陋 微信浏览器用户调整字体大小后页面矬了，怎么阻止用户调整 原因 android侧是复写了layoutinflater 对textview做了统一处理 ios侧是修改了body.style.webkitTextSizeAdjust值 解决方案： android使用以下代码，该接口只在微信浏览器下有效(感谢jationhuang同学提供) /** * 页面加入这段代码可使Android机器页面不再受到用户字体缩放强制改变大小 * 但是会有一个1秒左右的延迟，期间可以考虑通过loading展示 * 仅供参考 */ (function(){ if (typeof(WeixinJSBridge) == "undefined") { document.addEventListener("WeixinJSBridgeReady", function (e) { setTimeout(function(){ WeixinJSBridge.invoke('setFontSizeCallback',{"fontSize":0}, function(res) { alert(JSON.stringify(res)); }); },0); }); } else { setTimeout(function(){ WeixinJSBridge.invoke('setFontSizeCallback',{"fontSize":0}, function(res) { alert(JSON.stringify(res)); }); },0); } })(); &nbsp; ios使用-webkit-text-size-adjust禁止调整字体大小 body{-webkit-text-size-adjust: 100%!important;} 最好的解决方案： 整个页面用rem或者百分比布局 消除transition闪屏 网络都是这么写的，但我并没有测试出来 .css{ /*设置内嵌的元素在 3D 空间如何呈现：保留 3D*/ -webkit-transform-style: preserve-3d; /*（设置进行转换的元素的背面在面对用户时是否可见：隐藏）*/ -webkit-backface-visibility: hidden; } 开启硬件加速 解决页面闪白 保证动画流畅 .css { -webkit-transform: translate3d(0, 0, 0); -moz-transform: translate3d(0, 0, 0); -ms-transform: translate3d(0, 0, 0); transform: translate3d(0, 0, 0); } 参考《用CSS开启硬件加速来提高网站性能》 取消input在ios下，输入的时候英文首字母的默认大写 &lt;input autocapitalize="off" autocorrect="off" /&gt; android 上去掉语音输入按钮 input::-webkit-input-speech-button {display: none} android 2.3 bug @-webkit-keyframes 需要以0%开始100%结束，0%的百分号不能去掉 after和before伪类无法使用动画animation border-radius不支持%单位 translate百分比的写法和scale在一起会导致失效，例如-webkit-transform: translate(-50%,-50%) scale(-0.5, 1) android 4.x bug 三星 Galaxy S4中自带浏览器不支持border-radius缩写 同时设置border-radius和背景色的时候，背景色会溢出到圆角以外部分 部分手机(如三星)，a链接支持鼠标:visited事件，也就是说链接访问后文字变为紫色 android无法同时播放多音频audio 参考《border-radius 移动之伤》 设计高性能CSS3动画的几个要素 尽可能地使用合成属性transform和opacity来设计CSS3动画，不使用position的left和top来定位 利用translate3D开启GPU加速 参考《High Performance Animations》 fixed bug ios下fixed元素容易定位出错，软键盘弹出时，影响fixed元素定位 android下fixed表现要比iOS更好，软键盘弹出时，不会影响fixed元素定位 ios4下不支持position:fixed 解决方案 可用isroll.js，暂无完美方案 参考 《移动端web页面使用position:fixed问题总结》 《使用iScroll.js解决ios4下不支持position:fixed的问题》 &nbsp;如何阻止windows Phone的默认触摸事件 winphone下默认触摸事件事件使用e.preventDefault是无效的 目前解决方法是使用样式来禁用 html{-ms-touch-action: none;}/* 禁止winphone默认触摸事件 */ 参考 《Windows phone 8 touch support》 播放视频不全屏 &lt;!-- 1.目前只有ios7+、winphone8+支持自动播放 2.支持Airplay的设备（如：音箱、Apple TV)播放 x-webkit-airplay="true" 3.播放视频不全屏，ios7+、winphone8+支持，部分android4+支持（含华为、小米、魅族） webkit-playsinline="true" --&gt; &lt;video x-webkit-airplay="true" webkit-playsinline="true" preload="auto" autoplay src="http://"&gt;&lt;/video&gt; 体验demo：http://1.peunzhang.sinaapp.com/demo/video/index.html 常用的移动端框架 zepto.js 语法与jquery几乎一样，会jquery基本会zepto~ 最新版本已经更新到1.16 官网：http://zeptojs.com/ 中文(非官网)：http://www.css88.com/doc/zeptojs_api/ 常使用的扩展模块： 浏览器检测：https://github.com/madrobby/zepto/blob/master/src/detect.js tap事件：https://github.com/madrobby/zepto/blob/master/src/touch.js iscroll.js 解决页面不支持弹性滚动，不支持fixed引起的问题~ 实现下拉刷新，滑屏，缩放等功能~ 最新版本已经更新到5.0 官网：http://cubiq.org/iscroll-5 underscore.js 笔者没用过，不过听说好用，推荐给大家~ 该库提供了一整套函数式编程的实用功能，但是没有扩展任何JavaScript内置对象。 最新版本已经更新到1.8.2 官网：http://underscorejs.org/ 滑屏框架 适合上下滑屏、左右滑屏等滑屏切换页面的效果 slip.js iSlider.js fullpage.js swiper.js flex布局 使用注意： flex下的子元素必须为块级元素，非块级元素在android2.3机器下flex失效 flex下的子元素宽度和高度不能超过父元素，否则会导致子元素定位错误，例如水平垂直居中 FastClick 消除在移动浏览器上触发click事件与一个物理Tap(敲击)之间的300延迟 参考《FastClick》 Sea.js&nbsp; 提供简单、极致的模块化开发体验 简单友好的模块定义规范：Sea.js 遵循&nbsp;CMD&nbsp;规范，可以像&nbsp;Node.js&nbsp;一般书写模块代码。 自然直观的代码组织方式：依赖的自动加载、配置的简洁清晰，可以让我们更多地享受编码的乐趣。 地址：http://seajs.org/docs/ &nbsp;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[排序算法整理]]></title>
      <url>%2F2017%2F04%2F08%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%2F</url>
      <content type="text"><![CDATA[插入排序插入排序的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增1的有序表排序过程大概如下：从第一个元素开始，该元素可以认为已经被排序；取出下一个元素，在已经排序的元素序列中从后向前扫描；如果该元素（已排序）大于新元素，将该元素移到下一位置；重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；将新元素插入到该位置后；重复步骤2~5。 /** * 插入排序算法 * @param {Array} arr 需要排序的数组 * @return {Array} 从小到大排序好的数组 */ function insertSort(arr){ var len = arr.length; for (var i = 1; i &lt; len; i++) { var key = arr[i]; var j = i - 1; while (j &gt;= 0 &amp;&amp; arr[j] &gt; key) { arr[j + 1] = arr[j]; j--; } arr[j + 1] = key; } return arr; } 算法分析 最佳情况：输入数组按升序排列。T(n) = O(n)最坏情况：输入数组按降序排列。T(n) = O(n2)平均情况：T(n) = O(n2) 二分插入排序从第一个元素开始，该元素可以认为已经被排序；取出下一个元素，在已经排序的元素序列中二分查找到第一个比它大的数的位置；将新元素插入到该位置后；重复上述两步 /** * 二分法插入排序 * @param {array} arr 需要排序的数组 * @return {array} 排序后悔的数组 */ function binaryInsertSort(arr){ for (var i = 1; i &lt; arr.length; i++) { var key = arr[i], left = 0, right = i - 1; while (left &lt;= right) { var middle = parseInt((left + right) / 2); if (key &lt; arr[middle]) { right = middle - 1; } else { left = middle + 1; } } for (var j = i - 1; j &gt;= left; j--) { arr[j + 1] = arr[j]; } arr[left] = key; } return arr; } 算法分析 最佳情况：T(n) = O(nlogn)最差情况：T(n) = O(n2)平均情况：T(n) = O(n2) 选择排序选择排序就是通过n-i次关键字间的比较，从n-i-1个记录中选出关键字最小的记录，并和第i个记录进行交换。选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。1234567891011121314function selectSort(arr)&#123; for(var i = 0; i &lt; arr.length - 1; i++)&#123; var min = arr[i]; for(var j = i + 1; j &lt; arr.length - 1; j++)&#123; if(min &gt; arr[j])&#123; var temp = min; min = arr[j]; arr[j] = temp; &#125; &#125; arr[i] = min; &#125; return arr; &#125; 算法分析 最佳情况：T(n) = O(n2)最差情况：T(n) = O(n2)平均情况：T(n) = O(n2) 冒泡排序冒泡排序是一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 function bubbleSort(arr) { var len = arr.length; for (var i = 0; i &lt; len - 1; i++) { var n = 0; for (var j = 0; j &lt; len - i ; j++) { if(arr[j] &lt; arr[j-1]){ n++; console.log(n); var temp = arr[j]; arr[j] = arr[j-1]; arr[j-1] = temp; } } if( n &lt; 1){ break; } } return arr; } 最佳情况：T(n) = O(n)最差情况：T(n) = O(n2)平均情况：T(n) = O(n2) 快速排序（1）在数据集之中，选择一个元素作为”基准”（pivot）。（2）所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。（3）对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。 function quickSort(arr){ if (arr.length &lt;= 1){return arr}; var pivotIndex = Math.floor(arr.length / 2); var pivot = arr.splice(pivotIndex,1)[0]; var left = []; var right = []; for (var i = 0; i &lt; arr.length; i++){ if(arr[i] &lt; pivot) { left.push(arr[i]); }else{ right.push(arr[i]); } } return quickSort(left).concat([pivot],quickSort(right)); } 算法分析 最佳情况：T(n) = O(nlogn)最差情况：T(n) = O(n2)平均情况：T(n) = O(nlogn) 希尔排序希尔排序的实质是分组插入排序，该方法又称缩小增量排序。该方法的基本思想是：先将整个待排元素序列分割为若干个子序列（由相隔某个‘增量’的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，带这个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。因为直接插入排序在元素基本有序的情况下（接近最好情况）效率是很高的，因此希尔排序在时间效率上有较大的提高。希尔排序算法实现 function shallSort(array) { var increment = array.length; var i var temp; //暂存 var count = 0; do { //设置增量 increment = Math.floor(increment / 3) + 1; for (i = increment ; i &lt; array.length; i++) { console.log(increment); if (array[i] &lt; array[i - increment]) { temp = array[i]; for (var j = i - increment; j &gt;= 0 &amp;&amp; temp &lt; array[j]; j -= increment) { array[j + increment] = array[j]; } array[j + increment] = temp; } } } while (increment &gt; 1) return array; }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[借助nodejs探究websocket]]></title>
      <url>%2F2017%2F04%2F08%2F%E5%80%9F%E5%8A%A9nodejs%E6%8E%A2%E7%A9%B6websocket%2F</url>
      <content type="text"><![CDATA[文章导读： 一、概述-what’s WebSocket? 二、运行在浏览器中的WebSocket客户端+使用ws模块搭建的简单服务器 三、Node中的WebSocket 四、socket.io 五、扩展阅读一、概述-what’s WebSocket? 1.1 为什么我们需要WebSocket这样的实时的通信协议？WebSocket是web通信方式的一种，像我们熟知的HTTP协议也是web通信方式的一种。但是我们知道HTTP协议是一种无状态的协议，其服务端本身不具备识别客户端的能力，必须借助外部的一些信息比如说session和cookie，才能与特定的客户端保持通信。也就是说我们所发送的每一个HTTP的请求都会带上请求头中一些相应的信息还有cookie，这明显会增加我们传输的信息的体量从而带来一定的网络延迟，对于一些对通信的实时性要求比较高的应用来说就是不可忍受的了，比如说聊天程序或者是运行在浏览器中的实时小游戏。最郁闷的却还是这些头信息和cookie往往对于服务器响应客户端的请求来说是多余的，也就是说虽然我每个请求都带了这些信息，但是服务器与客户端的交互过程中可能根本用不上这些信息。 为了改善HTTP请求的这种网络延迟的情况，也出现了一些适应不同需求的其他的[web通信]方式，比如说：轮询，长轮询( long-polling )，数据流，EventSouce等等，WebSocket便是其中一种。 实际上大多数基于因特网（或者局域网）的网络链接通常都包含长连接和基于TCP套接字的双向消息交换。但是TCP协议是属于最底层的网络通信协议了，让一些不能信任的客户端脚本去访问底层的TCP套接字显然是不太安全的，因此WebSocket实现了一种较为安全的方案，它允许客户端脚本在客户端和支持WebSocket协议的服务器之间创建双向的套接字连接。从而使实时通信的某些网络操作变得简单。 1.2 WebSocket是如何工作的？我们知道了WebSocket的主要作用是，允许服务器端与客户端进行全双工（full-duplex）的实时通信。这里有个例子特别好：HTTP协议像发电子邮件，发出后必须等待对方回信；WebSocket则是像打电话，服务器端和客户端可以同时向对方发送数据，它们之间存着一条持续打开的数据通道。 我们先看一下一个基于WebSocket协议通信的请求头和响应头(下面简单实例中的一个消息头)： 其中与WebSocket协议相关的信息： 1 Upgrade:websocket——-HTTP1.1协议规定，Upgrade头信息表示将通信协议从HTTP/1.1转向该项所指定的协议； 2 Connection:Upgrade——表示浏览器通知服务器，如果允许，就将通信协议升级到websocket协议； 3 Origin——————用于验证浏览器域名是否在服务器许可的范围内; 4 Sec-WebSocket-Key——-则是用于握手协议的密钥，是base64编码的16字节随机字符串; 5 Sec-WebSocket-Accept—-是服务器在浏览器提供的Sec-WebSocket-Key字符串后面，添加“258EAFA5-E914-47DA-95CA-C5AB0DC85B11” 字符串，然后再取sha-1的hash值。浏览器将对这个值进行验证，以证明确实是目标服务器回应了webSocket请求； 6.Sec-WebSocket-Location–一般情况下还有这个响应消息头用来表示进行通信的WebSocket网址，这里面可能是因为我例子中设置了127.0.0.1，所以这个信息省略掉了。客户端通过一个WebSocket握手的过程建立一个WebSocket连接。整个过程看起来是这个样子的： 完成握手以后，WebSocket协议就在TCP协议之上，客户端和服务器端就可以开始传送数据了。 websocket协议用ws表示，加密的websocket协议用wss协议，就像普通的HTTP协议用http表示，加密的HTTP协议用https表示一样。 下面我们就通过一些实例看一下websocket的不同实现是如何应用的。 二、 运行在浏览器中的WebSocket客户端+使用ws模块搭建的简单服务器我们可以通过跑起来这个简单的实例看一下如何编写运行在浏览器中的WebSocket客户端，并且看它是怎样与服务器端交互的。 2.1 运行实例我们把客户端代码和服务端代码准备好，然后启动服务器监听端口，比如说8080，再然后运行我们的客户端代码即可看到效果。 我们的客户端代码写在html文件中： 12345678910111213141516171819202122232425261 var onOpen = function() &#123;2 console.log(&quot;Socket opened.&quot;);3 socket.send(&quot;Hi, Server!&quot;);4 &#125;,5 onClose = function() &#123;6 console.log(&quot;Socket closed.&quot;);7 &#125;,8910 onMessage = function(data) &#123;11 console.log(&quot;We get signal:&quot;);12 console.log(data);13 &#125;,141516 onError = function() &#123;17 console.log(&quot;We got an error.&quot;);18 &#125;,1920 21 socket = new WebSocket(&quot;ws://127.0.0.1:8080/&quot;);2223 socket.onopen = onOpen;24 socket.onclose = onClose;25 socket.onerror = onError;26 socket.onmessage = onMessage; 我们通过它建立连接并且监听open和messege等事件，与此同时，我们想要得到服务器的响应。服务器端的js代码： 123456789101 var WebSocketServer = require(&apos;ws&apos;).Server; 2 var wss = new WebSocketServer(&#123; port: 8080 &#125;); 3 4 wss.on(&apos;connection&apos;, function connection(ws) &#123; 5 ws.on(&apos;message&apos;, function incoming(message) &#123; 6 console.log(&apos;received: %s&apos;, message); 7 &#125;); 8 9 ws.send(&apos;something&apos;);10 &#125;); 这个简单的websocket服务器使用了[ ws模块 ]，如果没有安装过，要先安装一下： 1 sudo npm install ws然后在我们的命令行执行： 1 node simpleWSserver.js我们的服务器启动之后，我们运行客户端代码可以看到： 浏览器： 命令行： 整个过程看起来是这个样子的： 2.2 运行在浏览器中的websocket客户端 我们在浏览器中的websocket主要做的事情无非是以下几个： 1 建立连接和关闭连接2 发送数据和接收数据3 处理错误对应的会触发以下的事件： 1onopen2onmessage3onclose4onerror2.2.1 建立连接和关闭连接 通常我们新建了一个WebSocket的实例就可以建立一个连接：1231 if(window.WebSocket != undefined) &#123;2 var socket = new WebSocket(&quot;ws://127.0.0.1:8080/&quot;);3 &#125; 建立连接之后的WebSocket实例有一个readyState属性，用来标识当前的状态： 0-正在连接1-连接成功2-正在关闭3-关闭成功连接成功后会触发onopen事件，这时我们就可以向服务器发送数据了：123451 var onOpen = function() &#123;2 console.log(&quot;Socket opened.&quot;);3 socket.send(&quot;Hi, Server!&quot;);4 &#125;5 socket.onopen = onOpen; 要是关闭连接的话就会出发onclose事件：12341 var onClose = function() &#123;2 console.log(&quot;Socket closed.&quot;);3 &#125;4 socket.onclose = onClose; 2.2.2 发送数据和接收数据 在连接建立成功后触发的onopen事件中我们通过send()方法发送数据给服务器： 1 socket.send(&quot;Hi, Server!&quot;);除了发送字符串类型的数据，也可以使用 Blob 或 ArrayBuffer 对象发送二进制数据。不仅如此，我们还可以发送JSON数据：1234567891011121 var onOpen = function() &#123; 2 var msg = &#123; 3 type: &quot;message&quot;, 4 text: &quot;something&quot;, 5 id: &quot;number&quot;, 6 date: Date.now() 7 &#125;; 8 9 // Send the msg object as a JSON-formatted string.10 socket.send(JSON.stringify(msg));11 &#125;12 socket.onopen = onOpen; 这时会触发服务器端的message事件：1231 ws.on(&apos;message&apos;, function incoming(message) &#123;2 console.log(&apos;received: %s&apos;, message);3 &#125;); 同时，服务器端发来信息的时候： 1 ws.send(&#39;something&#39;);也会触发客户端的onmessage事件：123451 var onMessage = function(data) &#123;2 console.log(&quot;We get signal:&quot;);3 console.log(data);4 &#125;5 socket.onmessage = onMessage; 2.2.3 处理错误 发生的错误会触发onerror事件：12341 var onError = function() &#123;2 console.log(&quot;We got an error.&quot;);3 &#125;4 socket.onerror = onError; 三、Node中的WebSocket WebSocket在Node中的实现[ WebSocket-Node ]使我们可以在Nodejs中使用websokcet开发客户端和服务器端实时交互的应用程序。我们可以运行客户端和服务器实时交换随机数的例子看看它是怎么工作的：node socketserver.js node socketclient.js 四、socket.io现在很流行的websocket的实现socket.io同样包括客户端和服务器端两部分。它不仅简化了接口，使得操作更容易，而且对于那些不支持WebSocket的浏览器，会自动降为Ajax连接，最大限度地保证了兼容性。它的目标是统一通信机制，使得所有浏览器和移动设备都可以进行实时通信。 4.1 socket.io与WebSocket的区别在哪里呢？websocket是浏览器对象，websocket api是浏览器提供给我们的用于浏览器和服务器实时通信的接口。 websocket在node中的实现使我们可以开发服务端程序时使用websocket的特性。 在我们使用websocket的时候，因为他是浏览器提供的接口，所以会涉及到一些兼容性和支持性的问题。如果我们对程序所运行的环境或局限不是那么了解的化，那么可能会出现问题： [ Differences between socket.io and websocket ] 。而socket.io则是进化了的websocket api。socket.io建立在websocket之上，它在合适的时候使用websocket。 4.2 socket.io实现聊天室 使用websocket或socket.io可以从一个简单的聊天室程序开始。对于socket.io来说，这非常容易。 基于 node ，这里使用express和socket.io： 1 npm install --save express@4.10.22 npm install --save socket.io那么我们就可以开始写聊天程序了。它需要的就是一个客户端的聊天窗口和一个用来接收消息和分发消息的服务器。 我们需要三个文件，分别新建：package.json,index.js,index.html. package.json: 1234567891 &#123;2 &quot;name&quot;: &quot;chat-application&quot;,3 &quot;version&quot;: &quot;0.0.1&quot;,4 &quot;description&quot;: &quot;my first socket.io app&quot;,5 &quot;dependencies&quot;: &#123;6 &quot;socket.io&quot;: &quot;^1.3.5&quot;7 &#125;8 &#125; index.js: 12345678910111213141516171819202122231 var app = require(&apos;express&apos;)(); 2 var http = require(&apos;http&apos;).Server(app); 3 var io = require(&apos;socket.io&apos;)(http); 4 5 app.get(&apos;/&apos;, function(req, res)&#123; 6 res.sendfile(&apos;index.html&apos;); 7 &#125;); 8 9 io.on(&apos;connection&apos;, function(socket)&#123;10 console.log(&apos;a user connected&apos;);11 //监听客户端的消息12 socket.on(&apos;chat message&apos;, function(msg)&#123;13 //用于将消息发送给每个人，包括发送者14 io.emit(&apos;chat message&apos;, msg);15 &#125;);16 socket.on(&apos;disconnect&apos;, function()&#123;17 console.log(&apos;user disconnected&apos;);18 &#125;);19 &#125;);2021 http.listen(3000, function()&#123;22 console.log(&apos;listening on *:3000&apos;);23 &#125;); index.html: 1234567891011121314151617181920212223242526272829303132333435361 &lt;!doctype html&gt; 2 &lt;html&gt; 3 &lt;head&gt; 4 &lt;title&gt;Socket.IO chat&lt;/title&gt; 5 &lt;style&gt; 6 * &#123; margin: 0; padding: 0; box-sizing: border-box; &#125; 7 body &#123; font: 13px Helvetica, Arial; &#125; 8 form &#123; background: #000; padding: 3px; position: fixed; bottom: 0; width: 100%; &#125; 9 form input &#123; border: 0; padding: 10px; width: 90%; margin-right: .5%; &#125;10 form button &#123; width: 9%; background: rgb(130, 224, 255); border: none; padding: 10px; &#125;11 #messages &#123; list-style-type: none; margin: 0; padding: 0; &#125;12 #messages li &#123; padding: 5px 10px; &#125;13 #messages li:nth-child(odd) &#123; background: #eee; &#125;14 &lt;/style&gt;15 &lt;/head&gt;16 &lt;body&gt;17 &lt;ul id=&quot;messages&quot;&gt;&lt;/ul&gt;18 &lt;form action=&quot;&quot;&gt;19 &lt;input id=&quot;m&quot; autocomplete=&quot;off&quot; /&gt;&lt;button&gt;Send&lt;/button&gt;20 &lt;/form&gt;21 &lt;script src=&quot;https://cdn.socket.io/socket.io-1.2.0.js&quot;&gt;&lt;/script&gt;22 &lt;script src=&quot;http://code.jquery.com/jquery-1.11.1.js&quot;&gt;&lt;/script&gt;23 &lt;script&gt;24 var socket = io();25 $(&apos;form&apos;).submit(function()&#123;26 //io.emit提供给我们可以发送给所有人的事件io.emit(&apos;some event&apos;, &#123; for: &apos;everyone&apos; &#125;);27 socket.emit(&apos;chat message&apos;, $(&apos;#m&apos;).val());28 $(&apos;#m&apos;).val(&apos;&apos;);29 return false;30 &#125;);31 socket.on(&apos;chat message&apos;, function(msg)&#123;32 $(&apos;#messages&apos;).append($(&apos;&lt;li&gt;&apos;).text(msg));33 &#125;);34 &lt;/script&gt;35 &lt;/body&gt;36 &lt;/html&gt; 先运行： node index.js在打开两个http://localhost:3000的窗口就可以开始聊天了： socket.io官网上有很详细的使用方法和教程：[ socket.io doc ] 五、扩展阅读 [ 浏览器对象-WebSocket ] [web通信] [细说WebSocket] [ WebSocket MDN ] [ WebSocket-Node implementation ] [ A Guide For WebSocket ] [ socket.IO ] [ writing websocket client ] [ deferences between socket.io and websocket ] [ websocket and socketio ] [ socket.io application ]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[nodejs模版引擎]]></title>
      <url>%2F2017%2F04%2F08%2Fnodejs%E6%A8%A1%E7%89%88%E5%BC%95%E6%93%8E%2F</url>
      <content type="text"><![CDATA[1.ejs （写法有点类jsp／php)Node 开源模板的选择很多，但推荐像我这样的老人去用 EJS，有 Classic ASP/PHP/JSP 的经验用起 EJS 来的确可以很自然，也就是说，你能够在 &lt;%…%&gt; 块中安排 JavaScript 代码，利用最传统的方式 &lt;%=输出变量%&gt;（另外 &lt;%-输出变量是不会对 &amp; 等符号进行转义的）1234567&lt;% if (names.length) &#123; %&gt; &lt;ul&gt; &lt;% names.forEach(function(name)&#123; %&gt; &lt;li foo=&apos;&lt;%= name + &quot;&apos;&quot; %&gt;&apos;&gt;&lt;%= name %&gt;&lt;/li&gt; &lt;% &#125;) %&gt; &lt;/ul&gt; &lt;% &#125; %&gt; 2. jadejade全新的Jade有两点是超出传统模板技术的。 第一、简洁。注意，简洁并非单指更少的符号，而是看是否能match你的需要。Jade强制的缩进格式能凸显html的结构，而对于前端来说，最重要的任务恰恰是处理结构，而不像一般的html author那样是处理内容。反过来说，假如你的主要任务是处理内容，比如写作blog之类的，那你应该用wiki或者markdown之类的，而不应该用Jade。 第二、html-aware传统模板技术其实是通用模板，即模板引擎并不care你输出的是html还是其他格式的文本。而Jade专为HTML设计，因此可以做许多传统模板做不到的专门针对html的优化。举个几个简单的例子： 决定如何输出属性（当属性赋值为null/false时不输出属性，为true时只需属性不需要值，这在传统模板里写起来很麻烦、代码难看易出错） 自动产生well-formed结构（甚至可决定是否要输出结束标签，而传统模板理论上也做不到这点，除非引入额外的html parse或tidy） 换行处理，避免产生额外的空白节点 对输出的变量自动进行特殊字符的encode123456789101112!!!html head title #&#123;title&#125; meta(charset=&quot;UTF-8&quot;) body div.description #&#123;description&#125; ul - each data in datas li.item(id=&apos;item_&apos;+data.index) span= data.time a.art(href=data.url)= data.title 3.handlebars123456789101112131415&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&#123;&#123;title&#125;&#125; - Page Test&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;description&quot;&gt;&#123;&#123;description&#125;&#125;&lt;/div&gt; &lt;ul&gt;&#123;&#123;#datas&#125;&#125; &lt;li class=&quot;item&quot; id=&quot;item_&#123;&#123;index&#125;&#125;&quot;&gt;&lt;span&gt;&#123;&#123;time&#125;&#125;&lt;/span&gt;&lt;a href=&quot;&#123;&#123;url&#125;&#125;&quot; class=&quot;art&quot;&gt;&#123;&#123;title&#125;&#125;&lt;/a&gt;&lt;/li&gt;&#123;&#123;/datas&#125;&#125; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 总结：Jade 很简洁，表达能力也很强，但不够直观，学习和适应成本不低。Jade 处理模板时计算量大，在没有缓存的情况下性能低是肯定的。Jade 对于一个不擅长前端、喜欢Bootstrap和Ctrl c + v 实在不能提高开发效， 性能瓶颈 Ejs 适用于写JSP/PHP后台的人使用，上手快 Handlebars 更接近前端的模版引擎，使用方便顺手]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac命令大全]]></title>
      <url>%2F2017%2F04%2F07%2FMac%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8%2F</url>
      <content type="text"><![CDATA[1.目录操作 命令名 功能描述 使用举例 mkdir 创建一个目录 mkdir dirname rmdir 删除一个目录 rmdir dirname mvdir 移动或重命名一个目录 mvdir dir1 dir2 cd 改变当前目录 cd dirname pwd 显示当前目录的路径名 pwd ls 显示当前目录的内容 ls -la dircmp 比较两个目录的内容 dircmp dir1 dir2 2.文件操作 命令名 功能描述 使用举例 cat 显示或连接文件 cat filename pg 分页格式化显示文件内容 pg filename more 分屏显示文件内容 more filename od 显示非文本文件的内容 od -c filename cp 复制文件或目录 cp file1 file2 rm 删除文件或目录 rm filename mv 改变文件名或所在目录 mv file1 file2 ln 联接文件 ln -s file1 file2 find 使用匹配表达式查找文件 find . -name “*.c” -print file 显示文件类型 file filename open 使用默认的程序打开文件 open filename 3.选择操作 命令名 功能描述 使用举例 tail 显示文件的最后几行 tail -15 filename cut 显示文件每行中的某些域 cut -f1,7 -d: /etc/passwd colrm 从标准输入中删除若干列 colrm 8 20 file2 paste 横向连接文件 paste file1 file2 diff 比较并显示两个文件的差异 diff file1 file2 sed 非交互方式流编辑器 sed “s/red/green/g” filename grep 在文件中按模式查找 grep “^[a-zA-Z]” filename awk 在文件中查找并处理模式 awk ‘{print $1 $1}’ filename sort 排序或归并文件 sort -d -f -u file1 uniq 去掉文件中的重复行 uniq file1 file2 comm 显示两有序文件的公共和非公共行 comm file1 file2 wc 统计文件的字符数、词数和行数 wc filename nl 给文件加上行号 nl file1 &gt;file2 4.安全操作 命令名 功能描述 使用举例 passwd 修改用户密码 passwd chmod 改变文件或目录的权限 chmod ug+x filename umask 定义创建文件的权限掩码 umask 027 chown 改变文件或目录的属主 chown newowner filename chgrp 改变文件或目录的所属组 chgrp staff filename xlock 给终端上锁 xlock -remote 5.编程操作 命令名 功能描述 使用举例 make 维护可执行程序的最新版本 make touch 更新文件的访问和修改时间 touch -m 05202400 filename dbx 命令行界面调试工具 dbx a.out xde 图形用户界面调试工具 xde a.out 6.进程操作 命令名 功能描述 使用举例 ps 显示进程当前状态 ps u kill 终止进程 kill -9 30142 nice 改变待执行命令的优先级 nice cc -c *.c renice 改变已运行进程的优先级 renice +20 32768 7.时间操作 命令名 功能描述 使用举例 date 显示系统的当前日期和时间 date cal 显示日历 cal 8 1996 time 统计程序的执行时间 time a.out 8.网络与通信操作 命令名 功能描述 使用举例 telnet 远程登录 telnet hpc.sp.net.edu.cn rlogin 远程登录 rlogin hostname -l username rsh 在远程主机执行指定命令 rsh f01n03 date ftp 在本地主机与远程主机之间传输文件 ftp ftp.sp.net.edu.cn rcp 在本地主机与远程主机 之间复制文件 rcp file1 host1:file2 ping 给一个网络主机发送 回应请求 ping hpc.sp.net.edu.cn mail 阅读和发送电子邮件 mail write 给另一用户发送报文 write username pts/1 mesg 允许或拒绝接收报文 mesg n 9.Korn Shell 命令 命令名 功能描述 使用举例 history 列出最近执行过的 几条命令及编号 history r 重复执行最近执行过的 某条命令 r -2 alias 给某个命令定义别名 alias del=rm -i unalias 取消对某个别名的定义 unalias del 10.其它命令 命令名 功能描述 使用举例 uname 显示操作系统的有关信息 uname -a clear 清除屏幕或窗口内容 clear env 显示当前所有设置过的环境变量 env who 列出当前登录的所有用户 who whoami 显示当前正进行操作的用户名 whoami tty 显示终端或伪终端的名称 tty stty 显示或重置控制键定义 stty -a du 查询磁盘使用情况 du -k subdir df 显示文件系统的总空间和可用空间 df /tmp w 显示当前系统活动的总信息 w]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[gogs 自动化部署]]></title>
      <url>%2F2017%2F04%2F07%2Fgogs-%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%2F</url>
      <content type="text"><![CDATA[1.创建仓库 服务器上需要配置两个 git 仓库，一个用于代码版本管理的远程仓库，一个用于用户访问的本地仓库。这里的「远程仓库」并不等同于托管代码的「中央仓库」，这两个仓库都是为了自动同步代码并部署网站而存在。在存放远程仓库的目录中（假设是 /home/ourai/repos）执行 git init –bare bridge.git 会创建一个包含 git 各种配置文件的「裸仓库」。 切换到存放用户所访问文件的目录（假设为 /home/ourai/www，如果不存在则在 /home/ourai 中执行mkdir www）：1234git initgit remote add origin /root/gogs-repositories/seateam/wxoauth.gitgit fetchgit checkout master 2.配置 Git Hook将目录切换至 xx.git/hooks，用cp post-receive.sample post-receive 拷贝并 cd /root/gogs-repositories/seateam/xx.git/hooks 用vim post-receive 修改。其内容大致如下：123456789101112#!/bin/shunset GIT_DIRNowPath=`pwd`DeployPath=&quot;/alidata/www/wxoauth&quot;cd $DeployPathgit pull origin mastercd $NowPathexit 0 使用 chmod +x post-receive 改变一下权限后，服务器端的配置就基本完成了。 3.上线与测试分开1234567891011121314151617181920212223while read oldrev newrev refnamedo if [[ $refname =~ .*/deploy$ ]]; then #!/bin/sh unset GIT_DIR NowPath=&apos;pwd&apos; DeployPath=&quot;/alidata/deploy/wxci&quot; cd $DeployPath git pull origin deploy cd $NowPath exit 0 else #!/bin/sh unset GIT_DIR NowPath=&apos;pwd&apos; DeployPath=&quot;/alidata/www/wxci&quot; cd $DeployPath git pull origin master cd $NowPath exit 0 fidone 4.挂起进程cd /alidata/gogsnohup ./gogs web &amp; 守护进程git hook 钩子，监听操作自动下载资源＝自动部署]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[shell 命令大全]]></title>
      <url>%2F2017%2F04%2F07%2Fshell-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8%2F</url>
      <content type="text"><![CDATA[1.系统信息arch 显示机器的处理器架构(1)uname -m 显示机器的处理器架构(2)uname -r 显示正在使用的内核版本dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI)hdparm -i /dev/hda 罗列一个磁盘的架构特性hdparm -tT /dev/sda 在磁盘上执行测试性读取操作cat /proc/cpuinfo 显示CPU info的信息cat /proc/interrupts 显示中断cat /proc/meminfo 校验内存使用cat /proc/swaps 显示哪些swap被使用cat /proc/version 显示内核的版本cat /proc/net/dev 显示网络适配器及统计cat /proc/mounts 显示已加载的文件系统lspci -tv 罗列 PCI 设备lsusb -tv 显示 USB 设备date 显示系统日期cal 2007 显示2007年的日历表date 041217002007.00 设置日期和时间 - 月日时分年.秒clock -w 将时间修改保存到 BIOS 2.关机 (系统的关机、重启以及登出 )shutdown -h now 关闭系统(1)init 0 关闭系统(2)telinit 0 关闭系统(3)shutdown -h hours:minutes &amp; 按预定时间关闭系统shutdown -c 取消按预定时间关闭系统shutdown -r now 重启(1)reboot 重启(2)logout 注销 3.文件和目录cd /home 进入 ‘/ home’ 目录’cd .. 返回上一级目录cd ../.. 返回上两级目录cd 进入个人的主目录cd ~user1 进入个人的主目录cd - 返回上次所在的目录pwd 显示工作路径ls 查看目录中的文件ls -F 查看目录中的文件ls -l 显示文件和目录的详细资料ls -a 显示隐藏文件ls [0-9] 显示包含数字的文件名和目录名tree 显示文件和目录由根目录开始的树形结构(1)lstree 显示文件和目录由根目录开始的树形结构(2)mkdir dir1 创建一个叫做 ‘dir1’ 的目录’mkdir dir1 dir2 同时创建两个目录mkdir -p /tmp/dir1/dir2 创建一个目录树rm -f file1 删除一个叫做 ‘file1’ 的文件’rmdir dir1 删除一个叫做 ‘dir1’ 的目录’rm -rf dir1 删除一个叫做 ‘dir1’ 的目录并同时删除其内容rm -rf dir1 dir2 同时删除两个目录及它们的内容mv dir1 new_dir 重命名/移动 一个目录cp file1 file2 复制一个文件cp dir/ . 复制一个目录下的所有文件到当前工作目录cp -a /tmp/dir1 . 复制一个目录到当前工作目录cp -a dir1 dir2 复制一个目录ln -s file1 lnk1 创建一个指向文件或目录的软链接ln file1 lnk1 创建一个指向文件或目录的物理链接touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm)file file1 outputs the mime type of the file as texticonv -l 列出已知的编码iconv -f fromEncoding -t toEncoding inputFile &gt; outputFile creates a new from the given input file by assuming it is encoded in fromEncoding and converting it to toEncoding.find . -maxdepth 1 -name .jpg -print -exec convert “{}” -resize 80x60 “thumbs/{}” \; batch resize files in the current directory and send them to a thumbnails directory (requires convert from Imagemagick) 4.文件搜索find / -name file1 从 ‘/‘ 开始进入根文件系统搜索文件和目录find / -user user1 搜索属于用户 ‘user1’ 的文件和目录find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件find / -name *.rpm -exec chmod 755 ‘{}’ \; 搜索以 ‘.rpm’ 结尾的文件并定义其权限find / -xdev -name *.rpm 搜索以 ‘.rpm’ 结尾的文件，忽略光驱、捷盘等可移动设备locate *.ps 寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令whereis halt 显示一个二进制文件、源码或man的位置which halt 显示一个二进制文件或可执行文件的完整路径 5.挂载一个文件系统mount /dev/hda2 /mnt/hda2 挂载一个叫做hda2的盘 - 确定目录 ‘/ mnt/hda2’ 已经存在umount /dev/hda2 卸载一个叫做hda2的盘 - 先从挂载点 ‘/ mnt/hda2’ 退出fuser -km /mnt/hda2 当设备繁忙时强制卸载umount -n /mnt/hda2 运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用mount /dev/fd0 /mnt/floppy 挂载一个软盘mount /dev/cdrom /mnt/cdrom 挂载一个cdrom或dvdrommount /dev/hdc /mnt/cdrecorder 挂载一个cdrw或dvdrommount /dev/hdb /mnt/cdrecorder 挂载一个cdrw或dvdrommount -o loop file.iso /mnt/cdrom 挂载一个文件或ISO镜像文件mount -t vfat /dev/hda5 /mnt/hda5 挂载一个Windows FAT32文件系统mount /dev/sda1 /mnt/usbdisk 挂载一个usb 捷盘或闪存设备mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 挂载一个windows网络共享 6.磁盘空间df -h 显示已经挂载的分区列表ls -lSr |more 以尺寸大小排列文件和目录du -sh dir1 估算目录 ‘dir1’ 已经使用的磁盘空间’du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小rpm -q -a –qf ‘%10{SIZE}t%{NAME}n’ | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统)dpkg-query -W -f=’${Installed-Size;10}t${Package}n’ | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统) 返回顶部索引 ^ 7.用户和群组groupadd group_name 创建一个新用户组groupdel group_name 删除一个用户组groupmod -n new_group_name old_group_name 重命名一个用户组useradd -c “Name Surname “ -g admin -d /home/user1 -s /bin/bash user1 创建一个属于 “admin” 用户组的用户useradd user1 创建一个新用户userdel -r user1 删除一个用户 ( ‘-r’ 排除主目录)usermod -c “User FTP” -g system -d /ftp/user1 -s /bin/nologin user1 修改用户属性passwd 修改口令passwd user1 修改一个用户的口令 (只允许root执行)chage -E 2005-12-31 user1 设置用户口令的失效期限pwck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的用户grpck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的群组newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组 8.文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消ls -lh 显示权限ls /tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限chown user1 file1 改变一个文件的所有人属性chown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性chgrp group1 file1 改变文件的群组chown user1:group1 file1 改变一个文件的所有人和群组属性find / -perm -u+s 罗列一个系统中所有使用了SUID控制的文件chmod u+s /bin/file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限chmod u-s /bin/file1 禁用一个二进制文件的 SUID位chmod g+s /home/public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的chmod g-s /home/public 禁用一个目录的 SGID 位chmod o+t /home/public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件chmod o-t /home/public 禁用一个目录的 STIKY 位 9.文件的特殊属性 - 使用 “+” 设置权限，使用 “-“ 用于取消chattr +a file1 只允许以追加方式读写文件chattr +c file1 允许这个文件能被内核自动压缩/解压chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接chattr +s file1 允许一个文件被安全地删除chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件lsattr 显示特殊的属性 10.打包和压缩文件bunzip2 file1.bz2 解压一个叫做 ‘file1.bz2’的文件bzip2 file1 压缩一个叫做 ‘file1’ 的文件gunzip file1.gz 解压一个叫做 ‘file1.gz’的文件gzip file1 压缩一个叫做 ‘file1’的文件gzip -9 file1 最大程度压缩rar a file1.rar test_file 创建一个叫做 ‘file1.rar’ 的包rar a file1.rar file1 file2 dir1 同时压缩 ‘file1’, ‘file2’ 以及目录 ‘dir1’rar x file1.rar 解压rar包unrar x file1.rar 解压rar包tar -cvf archive.tar file1 创建一个非压缩的 tarballtar -cvf archive.tar file1 file2 dir1 创建一个包含了 ‘file1’, ‘file2’ 以及 ‘dir1’的档案文件tar -tf archive.tar 显示一个包中的内容tar -xvf archive.tar 释放一个包tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包tar -xvfj archive.tar.bz2 解压一个bzip2格式的压缩包tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包tar -xvfz archive.tar.gz 解压一个gzip格式的压缩包zip file1.zip file1 创建一个zip格式的压缩包zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包unzip file1.zip 解压一个zip格式压缩包 11.RPM 包 - （Fedora, Redhat及类似系统）rpm -ivh package.rpm 安装一个rpm包rpm -ivh –nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告rpm -U package.rpm 更新一个rpm包但不改变其配置文件rpm -F package.rpm 更新一个确定已经安装的rpm包rpm -e package_name.rpm 删除一个rpm包rpm -qa 显示系统中所有已经安装的rpm包rpm -qa | grep httpd 显示所有名称中包含 “httpd” 字样的rpm包rpm -qi package_name 获取一个已安装包的特殊信息rpm -qg “System Environment/Daemons” 显示一个组件的rpm包rpm -ql package_name 显示一个已经安装的rpm包提供的文件列表rpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表rpm -q package_name –whatrequires 显示与一个rpm包存在依赖关系的列表rpm -q package_name –whatprovides 显示一个rpm包所占的体积rpm -q package_name –scripts 显示在安装/删除期间所执行的脚本lrpm -q package_name –changelog 显示一个rpm包的修改历史rpm -qf /etc/httpd/conf/httpd.conf 确认所给的文件由哪个rpm包所提供rpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表rpm –import /media/cdrom/RPM-GPG-KEY 导入公钥数字证书rpm –checksig package.rpm 确认一个rpm包的完整性rpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性rpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间rpm -Va 检查系统中所有已安装的rpm包- 小心使用rpm -Vp package.rpm 确认一个rpm包还未安装rpm2cpio package.rpm | cpio –extract –make-directories bin 从一个rpm包运行可执行文件rpm -ivh /usr/src/redhat/RPMS/arch/package.rpm 从一个rpm源码安装一个构建好的包rpmbuild –rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包 12.YUM 软件包升级器 - （Fedora, RedHat及类似系统）yum install package_name 下载并安装一个rpm包yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系yum update package_name.rpm 更新当前系统中所有安装的rpm包yum update package_name 更新一个rpm包yum remove package_name 删除一个rpm包yum list 列出当前系统中安装的所有包yum search package_name 在rpm仓库中搜寻软件包yum clean packages 清理rpm缓存删除下载的包yum clean headers 删除所有头文件yum clean all 删除所有缓存的包和头文件 13.DEB 包 (Debian, Ubuntu 以及类似系统)dpkg -i package.deb 安装/更新一个 deb 包dpkg -r package_name 从系统删除一个 deb 包dpkg -l 显示系统中所有已经安装的 deb 包dpkg -l | grep httpd 显示所有名称中包含 “httpd” 字样的deb包dpkg -s package_name 获得已经安装在系统中一个特殊包的信息dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表dpkg –contents package.deb 显示尚未安装的一个包所提供的文件列表dpkg -S /bin/ping 确认所给的文件由哪个deb包提供 14.APT 软件工具 (Debian, Ubuntu 以及类似系统)apt-get install package_name 安装/更新一个 deb 包apt-cdrom install package_name 从光盘安装/更新一个 deb 包apt-get update 升级列表中的软件包apt-get upgrade 升级所有已安装的软件apt-get remove package_name 从系统删除一个deb包apt-get check 确认依赖的软件仓库正确apt-get clean 从下载的软件包中清理缓存apt-cache search searched-package 返回包含所要搜索字符串的软件包名称 15.查看文件内容cat file1 从第一个字节开始正向查看文件的内容tac file1 从最后一行开始反向查看一个文件的内容more file1 查看一个长文件的内容less file1 类似于 ‘more’ 命令，但是它允许在文件中和正向操作一样的反向操作head -2 file1 查看一个文件的前两行tail -2 file1 查看一个文件的最后两行tail -f /var/log/messages 实时查看被添加到一个文件中的内容 16.文本处理cat file1 file2 … | command &lt;&gt; file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUTcat file1 | command( sed, grep, awk, grep, etc…) &gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中cat file1 | command( sed, grep, awk, grep, etc…) &gt;&gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中grep Aug /var/log/messages 在文件 ‘/var/log/messages’中查找关键词”Aug”grep ^Aug /var/log/messages 在文件 ‘/var/log/messages’中查找以”Aug”开始的词汇grep [0-9] /var/log/messages 选择 ‘/var/log/messages’ 文件中所有包含数字的行grep Aug -R /var/log/ 在目录 ‘/var/log’ 及随后的目录中搜索字符串”Aug”sed ‘s/stringa1/stringa2/g’ example.txt 将example.txt文件中的 “string1” 替换成 “string2”sed ‘/^$/d’ example.txt 从example.txt文件中删除所有空白行sed ‘/ #/d; /^$/d’ example.txt 从example.txt文件中删除所有注释和空白行echo ‘esempio’ | tr ‘[:lower:]’ ‘[:upper:]’ 合并上下单元格内容sed -e ‘1d’ result.txt 从文件example.txt 中排除第一行sed -n ‘/stringa1/p’ 查看只包含词汇 “string1”的行sed -e ‘s/ $//‘ example.txt 删除每一行最后的空白字符sed -e ‘s/stringa1//g’ example.txt 从文档中只删除词汇 “string1” 并保留剩余全部sed -n ‘1,5p;5q’ example.txt 查看从第一行到第5行内容sed -n ‘5p;5q’ example.txt 查看第5行sed -e ‘s/00/0/g’ example.txt 用单个零替换多个零cat -n file1 标示文件的行数cat example.txt | awk ‘NR%2==1’ 删除example.txt文件中的所有偶数行echo a b c | awk ‘{print $1}’ 查看一行第一栏echo a b c | awk ‘{print $1,$3}’ 查看一行的第一和第三栏paste file1 file2 合并两个文件或两栏的内容paste -d ‘+’ file1 file2 合并两个文件或两栏的内容，中间用”+”区分sort file1 file2 排序两个文件的内容sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份)sort file1 file2 | uniq -u 删除交集，留下其他的行sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件)comm -1 file1 file2 比较两个文件的内容只删除 ‘file1’ 所包含的内容comm -2 file1 file2 比较两个文件的内容只删除 ‘file2’ 所包含的内容comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分 17.字符设置和文件格式转换dos2unix filedos.txt fileunix.txt 将一个文本文件的格式从MSDOS转换成UNIXunix2dos fileunix.txt filedos.txt 将一个文本文件的格式从UNIX转换成MSDOSrecode ..HTML &lt; page.txt &gt; page.html 将一个文本文件转换成htmlrecode -l | more 显示所有允许的转换格式 18.文件系统分析badblocks -v /dev/hda1 检查磁盘hda1上的坏磁块fsck /dev/hda1 修复/检查hda1磁盘上linux文件系统的完整性fsck.ext2 /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性e2fsck /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性e2fsck -j /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性fsck.ext3 /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性fsck.vfat /dev/hda1 修复/检查hda1磁盘上fat文件系统的完整性fsck.msdos /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性dosfsck /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性 19.初始化一个文件系统mkfs /dev/hda1 在hda1分区创建一个文件系统mke2fs /dev/hda1 在hda1分区创建一个linux ext2的文件系统mke2fs -j /dev/hda1 在hda1分区创建一个linux ext3(日志型)的文件系统mkfs -t vfat 32 -F /dev/hda1 创建一个 FAT32 文件系统fdformat -n /dev/fd0 格式化一个软盘mkswap /dev/hda3 创建一个swap文件系统 20.SWAP文件系统mkswap /dev/hda3 创建一个swap文件系统swapon /dev/hda3 启用一个新的swap文件系统swapon /dev/hda2 /dev/hdb3 启用两个swap分区 21.备份dump -0aj -f /tmp/home0.bak /home 制作一个 ‘/home’ 目录的完整备份dump -1aj -f /tmp/home0.bak /home 制作一个 ‘/home’ 目录的交互式备份restore -if /tmp/home0.bak 还原一个交互式备份rsync -rogpav –delete /home /tmp 同步两边的目录rsync -rogpav -e ssh –delete /home ip_address:/tmp 通过SSH通道rsyncrsync -az -e ssh –delete ip_addr:/home/public /home/local 通过ssh和压缩将一个远程目录同步到本地目录rsync -az -e ssh –delete /home/local ip_addr:/home/public 通过ssh和压缩将本地目录同步到远程目录dd bs=1M if=/dev/hda | gzip | ssh user@ip_addr ‘dd of=hda.gz’ 通过ssh在远程主机上执行一次备份本地磁盘的操作dd if=/dev/sda of=/tmp/file1 备份磁盘内容到一个文件tar -Puf backup.tar /home/user 执行一次对 ‘/home/user’ 目录的交互式备份操作( cd /tmp/local/ &amp;&amp; tar c . ) | ssh -C user@ip_addr ‘cd /home/share/ &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个目录内容( tar c /home ) | ssh -C user@ip_addr ‘cd /home/backup-home &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个本地目录tar cf - . | (cd /tmp/backup ; tar xf - ) 本地将一个目录复制到另一个地方，保留原有权限及链接find /home/user1 -name ‘.txt’ | xargs cp -av –target-directory=/home/backup/ –parents 从一个目录查找并复制所有以 ‘.txt’ 结尾的文件到另一个目录find /var/log -name ‘.log’ | tar cv –files-from=- | bzip2 &gt; log.tar.bz2 查找所有以 ‘.log’ 结尾的文件并做成一个bzip包dd if=/dev/hda of=/dev/fd0 bs=512 count=1 做一个将 MBR (Master Boot Record)内容复制到软盘的动作dd if=/dev/fd0 of=/dev/hda bs=512 count=1 从已经保存到软盘的备份中恢复MBR内容 22.光盘cdrecord -v gracetime=2 dev=/dev/cdrom -eject blank=fast -force 清空一个可复写的光盘内容mkisofs /dev/cdrom &gt; cd.iso 在磁盘上创建一个光盘的iso镜像文件mkisofs /dev/cdrom | gzip &gt; cd_iso.gz 在磁盘上创建一个压缩了的光盘iso镜像文件mkisofs -J -allow-leading-dots -R -V “Label CD” -iso-level 4 -o ./cd.iso data_cd 创建一个目录的iso镜像文件cdrecord -v dev=/dev/cdrom cd.iso 刻录一个ISO镜像文件gzip -dc cd_iso.gz | cdrecord dev=/dev/cdrom - 刻录一个压缩了的ISO镜像文件mount -o loop cd.iso /mnt/iso 挂载一个ISO镜像文件cd-paranoia -B 从一个CD光盘转录音轨到 wav 文件中cd-paranoia – “-3” 从一个CD光盘转录音轨到 wav 文件中（参数-3）cdrecord –scanbus 扫描总线以识别scsi通道dd if=/dev/hdc | md5sum 校验一个设备的md5sum编码，例如一张 CD 23.网络 - （以太网和WIFI无线）ifconfig eth0 显示一个以太网卡的配置ifup eth0 启用一个 ‘eth0’ 网络设备ifdown eth0 禁用一个 ‘eth0’ 网络设备ifconfig eth0 192.168.1.1 netmask 255.255.255.0 控制IP地址ifconfig eth0 promisc 设置 ‘eth0’ 成混杂模式以嗅探数据包 (sniffing)dhclient eth0 以dhcp模式启用 ‘eth0’route -n show routing tableroute add -net 0/0 gw IP_Gateway configura default gatewayroute add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1 configure static route to reach network ‘192.168.0.0/16’route del 0/0 gw IP_gateway remove static routeecho “1” &gt; /proc/sys/net/ipv4/ip_forward activate ip routinghostname show hostname of systemhost www.example.com lookup hostname to resolve name to ip address and viceversa(1)nslookup www.example.com lookup hostname to resolve name to ip address and viceversa(2)ip link show show link status of all interfacesmii-tool eth0 show link status of ‘eth0’ethtool eth0 show statistics of network card ‘eth0’netstat -tup show all active network connections and their PIDnetstat -tupl show all network services listening on the system and their PIDtcpdump tcp port 80 show all HTTP trafficiwlist scan show wireless networksiwconfig eth1 show configuration of a wireless network cardhostname show hostnamehost www.example.com lookup hostname to resolve name to ip address and viceversanslookup www.example.com lookup hostname to resolve name to ip address and viceversawhois www.example.com lookup on Whois database Microsoft Windows networks (SAMBA)nbtscan ip_addr netbios name resolutionnmblookup -A ip_addr netbios name resolutionsmbclient -L ip_addr/hostname show remote shares of a windows hostsmbget -Rr smb://ip_addr/share like wget can download files from a host windows via smbmount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share mount a windows network share]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CI常用函数]]></title>
      <url>%2F2017%2F04%2F07%2FCI%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%2F</url>
      <content type="text"><![CDATA[选择数据$this-&gt;db-&gt;select();允许你在SQL查询中写 SELECT 部分。$this-&gt;db-&gt;where();$this-&gt;db-&gt;or_where();$this-&gt;db-&gt;where_in();允许你在SQL查询中写 WHERE部分，其余各种where语句请看手册。$this-&gt;db-&gt;get();运行选择查询语句并且返回结果集。可以获取一个表的全部数据。$this-&gt;db-&gt;like();$this-&gt;db-&gt;or_like();$this-&gt;db-&gt;not_like();本函数允许你生成 LIKE 子句，在做查询时非常有用，其余语法请看手册。$this-&gt;db-&gt;order_by();帮助你设置一个 ORDER BY 子句。$this-&gt;db-&gt;group_by();允许你编写查询语句中的 GROUP BY 部分:$this-&gt;db-&gt;distinct();为查询语句添加 “DISTINCT” 关键字:$this-&gt;db-&gt;having();允许你为你的查询语句编写 HAVING 部分。$this-&gt;db-&gt;limit();限制查询所返回的结果数量:$this-&gt;db-&gt;select_max();为你的查询编写一个 “SELECT MAX(field)”。$this-&gt;db-&gt;select_min();为你的查询编写一个 “SELECT MIN(field)” 。$this-&gt;db-&gt;select_avg();为你的查询编写一个 “SELECT AVG(field)” 。$this-&gt;db-&gt;select_sum();为你的查询编写一个 “SELECT SUM(field)” 。$this-&gt;db-&gt;join();允许你编写查询中的JOIN部分。$this-&gt;db-&gt;count_all_results();允许你获得某个特定的Active Record查询所返回的结果数量。可以使用Active Record限制函数，例如 where(), or_where(), like(), or_like() 等等。 插入数据$this-&gt;db-&gt;insert();生成一条基于你所提供的数据的SQL插入字符串并执行查询。你可以向函数传递 数组 或一个 对象。$this-&gt;db-&gt;insert_batch();一次插入多条数据，生成一条基于你所提供的数据的SQL插入字符串并执行查询。你可以向函数传递 数组 或一个 对象。$this-&gt;db-&gt;set();本函数使您能够设置inserts(插入)或updates(更新)值。它可以用来代替那种直接传递数组给插入和更新函数的方式。 更新数据$this-&gt;db-&gt;update();根据你提供的数据生成并执行一条update(更新)语句。你可以将一个数组或者对象传递给本函数。$this-&gt;db-&gt;update_batch();Generates an update string based on the data you supply, and runs the query. You can either pass an array or an object to the function. Here is an example using an array: 删除数据$this-&gt;db-&gt;delete();生成并执行一条DELETE(删除)语句。$this-&gt;db-&gt;empty_table();生成并执行一条DELETE(删除)语句。$this-&gt;db-&gt;truncate();生成并执行一条TRUNCATE(截断)语句。 链式方法 链式方法允许你以连接多个函数的方式简化你的语法。考虑一下这个范例:$this-&gt;db-&gt;select(‘title’)-&gt;from(‘mytable’)-&gt;where(‘id’, $id)-&gt;limit(10, 20);$query = $this-&gt;db-&gt;get();说明: 链式方法只能在PHP 5下面运行。 查询 $this-&gt;db-&gt;query();要提交一个查询，用以下函数：$this-&gt;db-&gt;query(‘YOUR QUERY HERE’);query() 函数以object(对象)的形式返回一个数据库结果集。 当使用 “read” 模式来运行查询时, 你可以使用“显示你的结果集”来显示查询结果; 当使用 “write” 模式来运行查询时, 将会仅根据执行的成功或失败来返回 TRUE 或 FALSE. 转义查询$this-&gt;db-&gt;escape()这个函数将会确定数据类型，以便仅对字符串类型数据进行转义。并且，它也会自动把数据用单引号括起来，所以你不必手动添加单引号，用法如下： $sql = “INSERT INTO table (title) VALUES(“.$this-&gt;db-&gt;escape($title).”)”; 查询辅助函数$this-&gt;db-&gt;insert_id()这个ID号是执行数据插入时的ID。$this-&gt;db-&gt;affected_rows()当执行写入操作（insert,update等）的查询后，显示被影响的行数。$this-&gt;db-&gt;count_all();计算出指定表的总行数并返回。在第一个参数中写入被提交的表名。 生成查询记录集result()该方法执行成功返回一个object 数组，失败则返回一个空数组。result_array()该方法执行成功时将记录集作为关联数组返回。失败时返回空数组。row()该函数将当前请求的第一行数据作为 object 返回。 你可以传递参数(参数是行的索引)以便获得某一行的数据。比如我们要获得第 5 行的数据： $row = $query-&gt;row(4); row_array()功能与 row() 一样, 区别在于该函数返回的是一个数组。除此以外, 我们还可以使用下面的方法通过游标的方式获取记录：$row = $query-&gt;first_row()$row = $query-&gt;last_row()$row = $query-&gt;next_row()$row = $query-&gt;previous_row()默认情况下他们将返回一个 object，同时你也可以传递参数 “array” 以便使用 array 的方式获取数据 $row = $query-&gt;first_row(‘array’)$row = $query-&gt;last_row(‘array’)$row = $query-&gt;next_row(‘array’)$row = $query-&gt;previous_row(‘array’) 结果集辅助函数$query-&gt;num_rows()该函数将会返回当前请求的行数。$query-&gt;num_fields()该函数返回当前请求的字段数（列数）：$query-&gt;free_result()该函数将会释放当前查询所占用的内存并删除其关联的资源标识。 自动连接 “自动连接” 功能将在每个一页面加载时被自动实例化数据库类。要启用“自动连接”，可在application/config/autoload.php中的 library 数组里添加 database：$autoload[‘libraries’] = array(‘database’); 手动连接 如果仅仅是一部分页面要求数据库连接，你可以在你有需要的函数里手工添加如下代码或者在你的类里手工添加以供该类使用。$this-&gt;load-&gt;database(); 连接多数据库 如果你需要同时连接多于一个的数据库，你可以用以下方式来实现：$DB1 = $this-&gt;load-&gt;database(‘group_one’, TRUE);$DB2 = $this-&gt;load-&gt;database(‘group_two’, TRUE); 表数据 $this-&gt;db-&gt;list_tables();返回一个包含当前连接数据库中所有表名称的数组。$this-&gt;db-&gt;table_exists();有时，在对某个表执行操作之前，使用该函数判断指定表是否存在很有用。返回一个布尔值。 数据库工具类 重要提示： 初始化数据库工具类之前，你的数据库驱动必须已经运行,因为工具类依赖于此。加载工具类： $this-&gt;load-&gt;dbutil()一旦初始化完毕，你可以通过 $this-&gt;dbutil 对象来访问成员函数：$this-&gt;dbutil-&gt;list_databases()$this-&gt;dbutil-&gt;database_exists();$this-&gt;dbutil-&gt;xml_from_result($db_result)$this-&gt;dbutil-&gt;backup() 数据库缓存类 激活缓存需要三步：1、在服务器上创建一个可写的目录以便保存缓存文件。2、在文件 application/config/database.php 中$db[‘xxxx’][‘cachedir’]设置其目录。3、激活缓存特性，可以在文件 application/config/database.php 中设置全局选项$db[‘xxxx’][‘cache_on’]=’TRUE’，也可以用以本页下面的方法手动设置。一旦被激活，每一次含有数据库查询的页面被加载时缓存就会自动发生。 当有数据库更新，我们需要删除缓存文件$this-&gt;db-&gt;cache_delete()删除缓存文件与特定网页。如果你需要清除缓存后，更新您的数据库$this-&gt;db-&gt;cache_delete(‘/blog’, ‘comments’);注意，手册上写的是 $this-&gt;db-&gt;cache_delete(‘blog’, ‘comments’);但根据实际测试应该在控制器名字前加斜杠’/‘才能正确执行。$this-&gt;db-&gt;cache_delete_all()清除所有所有的缓存文件。 数据库维护类 注意: 欲初始化数据库维护类，请确保你的数据库驱动已经运行，因为该类依赖于数据库驱动。使用如下方法载入数据库维护类:$this-&gt;load-&gt;dbforge()一旦初始化，就可以使用$this-&gt;dbforge 对象访问类中函数:$this-&gt;dbforge-&gt;create_database(‘db_name’)允许你创建由第一个参数指定的数据库。$this-&gt;dbforge-&gt;drop_database(‘db_name’)允许你删除由第一个参数指定的数据库。$this-&gt;dbforge-&gt;create_table(‘table_name’);声明了字段和键之后，你就可以创建一个表。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端知识点2]]></title>
      <url>%2F2017%2F04%2F07%2F%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B92%2F</url>
      <content type="text"><![CDATA[1,将url的查询参数解析成字典对象这个题目不约而同的出现在了多家公司的面试题中，当然也是因为太过于典型，解决方案无非就是拆字符或者用正则匹配来解决，我个人强烈建议用正则匹配，因为url允许用户随意输入，如果用拆字符的方式，有任何一处没有考虑到容错，就会导致整个js都报错。而正则就没有这个问题，他只匹配出正确的配对，非法的全部过滤掉，简单，方便。实现代码：123456789101112131415function getQueryObject(url) &#123; url = url == null ? window.location.href : url; var search = url.substring(url.lastIndexOf(&quot;?&quot;) + 1); var obj = &#123;&#125;; var reg = /([^?&amp;=]+)=([^?&amp;=]*)/g; search.replace(reg, function (rs, $1, $2) &#123; var name = decodeURIComponent($1); var val = decodeURIComponent($2); val = String(val); obj[name] = val; return rs; &#125;); return obj;&#125;getQueryObject(&quot;http://www.cnblogs.com/leee/p/4456840.html?name=1&amp;dd=ddd**&quot;) Object {name: &quot;1&quot;, dd: &quot;ddd**&quot;} 2.console.log(1+ +”2”);输出的是3等同于: 1+(+’2’)：+’2’ 的 + 是一元操作符，对 ‘2’ 进行Number()操作，转为数字的2，所以等于312console.log(&quot;A&quot;-&quot;B&quot;+&quot;2&quot;) NaN2console.log(&quot;A&quot;-&quot;B&quot;+2) NaN 3. 算法12345678910function test(a,b)&#123; console.log(b); return&#123; test:function(x)&#123; return test(x,a); &#125; &#125; &#125; var a=test(0);a.test(1);a.test(2);a.test(3); // underfined 0 0 0 4. 三次握手第一次第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。 第二次第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。完成三次握手，客户端与服务器开始传送数据，在上述过程中，还有一些重要的概念： 5. http 状态码一、HTTP状态码如果某项请求发送到您的服务器要求显示您网站上的某个网页（例如，用户通过浏览器访问您的网页或 Googlebot 抓取网页时），服务器将会返回 HTTP 状态代码以响应请求。 此状态代码提供关于请求状态的信息， 告诉 Googlebot 关于您的网站和请求的网页的信息。一些常见的状态代码包括：200 – 服务器成功返回网页404 – 请求的网页不存在503 – 服务器暂时不可用 下面提供 HTTP 状态代码的完整列表。 点击链接可了解详情。 您也可以访问有关 HTTP 状态代码的 W3C 网页以获得更多信息 。 1xx：请求收到，继续处理2xx：操作成功收到，分析、接受3xx：完成此请求必须进一步处理4xx：请求包含一个错误语法或不能完成5xx：服务器执行一个完全有效请求失败1xx （临时响应）表示临时响应并需要请求者继续执行操作的状态代码。 代码 说明100（继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。101（切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。 2xx （成功）表示服务器成功处理了请求的状态代码。 代码 说明200（成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。 如果针对您的 robots.txt 文件显示此状态，则表示 Googlebot 已成功检索到该文件。201（已创建） 请求成功并且服务器创建了新的资源。202（已接受） 服务器已接受请求，但尚未处理。203（非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。204（无内容） 服务器成功处理了请求，但没有返回任何内容。205（重置内容） 服务器成功处理了请求，但没有返回任何内容。 与 204 响应不同，此响应要求请求者重置文档视图（例如，清除表单内容以输入新内容）。206（部分内容） 服务器成功处理了部分 GET 请求。 3xx （重定向）要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。 Google 建议您在每次请求中使用重定向不要超过 5 次。 您可以使用网站管理员工具查看一下 Googlebot 在抓取重定向网页时是否遇到问题。 诊断 下的网 络抓取 页面列出了由于重定向错误而导致 Googlebot 无法抓取的网址。 代码 说明300（多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者（用户代理）选择一项操作，或提供操作列表供请求者选择。301（永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。 您应使用此代码告诉 Googlebot 某个网页或网站已永久移动到新位置。302（暂时移动） 服 务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 此代码与响应 GET 或 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个网页或网站已经移动，因为 Googlebot 会继续抓取原有位置并编入索引。303（查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。 对于除 HEAD 之外的所有请求，服务器会自动转到其他位置。304（未修改） 自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。如果网页自请求者上次请求后再也没有更改 过，您应当将服务器配置为返回此响应（称为 If-Modified-Since HTTP 标头）。 由于服务器可以告诉 Googlebot 自从上次抓取后网页没有更改过，因此可节省带宽和开销。305（使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。307（暂时重定向） 服 务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个页面或网站已经移动，因为 Googlebot 会继续抓取原有位置并编入索引。 4xx（请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。 代码 说明400（错误请求） 服务器不理解请求的语法。401（未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。403（禁止） 服务器拒绝请求。 如果您看到 Googlebot 在尝试抓取您网站上的有效网页时收到此状态代码（可以在 Google 网站管理员工具诊 断 下的网络抓取 页面上看到此信息），可能是您的服务器或主机拒绝 Googlebot 访问。404（未找到） 服务器找不到请求的网页。 例如，如果请求服务器上不存在的网页，服务器通常会返回此代码。如果您的网站上没有 robots.txt 文件，而您在 Google 网站管理员工具”诊断”标签的 robots.txt 页 上看到此状态，那么这是正确的状态。 但是，如果您有 robots.txt 文件而又看到此状态，则说明您的 robots.txt 文件可能命名错误或位于错误的位置 （该文件应当位于顶级域名，名为 robots.txt）。如果您看到有关 Googlebot 尝试抓取的网址的此状态（在”诊断”标签的 HTTP 错误页上），则表示 Googlebot 追踪的可能是另一个页面的无效链接（是旧链接或输入有误的链接）。405（禁用的方法） 禁用请求中指定的方法。406（不可接受） 无法使用请求的内容特性响应请求的网页。407（需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。 如果服务器返回此响应，还会指明请求者应当使用的代理。408（请求超时） 服务器等候请求时发生超时。409（冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 服务器在响应与前一个请求相冲突的 PUT 请求时可能会返回此代码，同时会附上两个请求的差异列表。410（已删除） 如果请求的资源已永久删除，服务器就会返回此响应。 该代码与 404（未找到）代码相似，但在资源以前存在而现在不存在的情况下，有时会用来替代 404 代码。 如果资源已永久删除，您应当使用 301 指定资源的新位置。411（需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。412（未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。413（请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。414（请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。415（不支持的媒体类型） 请求的格式不受请求页面的支持。416（请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。417（未满足期望要求） 服务器未满足”期望”请求标头字段的要求。 5xx （服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。 代码 说明500（服务器内部错误） 服务器遇到错误，无法完成请求。501（尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。502（错误网关） 服务器充当网关或代理，从上游服务器收到无效响应。503（服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。504（网关超时） 服务器充当网关或代理，但没有及时从上游服务器收到请求。505（HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。 HTML+CSS1.对WEB标准以及W3C的理解与认识标签闭合、标签小写、不乱嵌套、提高搜索机器人搜索几率、使用外 链css和js脚本、结构行为表现的分离、文件下载与页面速度更快、内容能被更多的用户所访问、内容能被更广泛的设备所访问、更少的代码和组件，容易维 护、改版方便，不需要变动页面内容、提供打印版本而不需要复制内容、提高网站易用性； 2.xhtml和html有什么区别HTML是一种基本的WEB网页设计语言，XHTML是一个基于XML的置标语言最主要的不同：XHTML 元素必须被正确地嵌套。XHTML 元素必须被关闭。标签名必须用小写字母。XHTML 文档必须拥有根元素。 3.Doctype? 严格模式与混杂模式-如何触发这两种模式，区分它们有何意义?用于声明文档使用那种规范（html/Xhtml）一般为 严格 过度 基于框架的html文档加入XMl声明可触发，解析方式更改为IE5.5 拥有IE5.5的bug 4.行内元素有哪些?块级元素有哪些?CSS的盒模型?块级元素：div p h1 h2 h3 h4 form ul行内元素: a b br i span input selectCss盒模型:内容，border ,margin，padding 5.CSS引入的方式有哪些? link和@import的区别是?内联 内嵌 外链 导入区别 ：同时加载前者无兼容性，后者CSS2.1以下浏览器不支持Link 支持使用javascript改变样式，后者不可 6.CSS选择符有哪些?哪些属性可以继承?优先级算法如何计算?内联和important哪个优先级高?标签选择符 类选择符 id选择符继承不如指定 Id&gt;class&gt;标签选择后者优先级高 7.前端页面有哪三层构成，分别是什么?作用是什么?结构层 Html 表示层 CSS 行为层 js 8.css的基本语句构成是?选择器{属性1:值1;属性2:值2;……} 9.你做的页面在哪些流览器测试过?这些浏览器的内核分别是什么?Ie(Ie内核) 火狐（Gecko） 谷歌（webkit） opear(Presto) 10.写出几种IE6 BUG的解决方法1.双边距BUG float引起的 使用display2.3像素问题 使用float引起的 使用dislpay:inline -3px3.超链接hover 点击后失效 使用正确的书写顺序 link visited hover active4.Ie z-index问题 给父级添加position:relative5.Png 透明 使用js代码 改6.Min-height 最小高度 ！Important 解决’7.select 在ie6下遮盖 使用iframe嵌套8.为什么没有办法定义1px左右的宽度容器（IE6默认的行高造成的，使用over:hidden,zoom:0.08 line-height:1px） 11.标签上title与alt属性的区别是什么?Alt 当图片不显示是 用文字代表。Title 为该属性提供信息 12.描述css reset的作用和用途。Reset重置浏览器的css默认属性 浏览器的品种不同，样式不同，然后重置，让他们统一 13.解释css sprites，如何使用。Css 精灵 把一堆小的图片整合到一张大的图片上，减轻服务器对图片的请求数量 14.浏览器标准模式和怪异模式之间的区别是什么?盒子模型 渲染模式的不同使用 window.top.document.compatMode 可显示为什么模式 15.你如何对网站的文件和资源进行优化?期待的解决方案包括：文件合并文件最小化/文件压缩使用CDN托管缓存的使用 16.什么是语义化的HTML?直观的认识标签 对于搜索引擎的抓取有好处 17.清除浮动的几种方式，各自的优缺点1.使用空标签清除浮动 clear:both（理论上能清楚任何标签，，，增加无意义的标签）2.使用overflow:auto（空标签元素清除浮动而不得不增加无意代码的弊端,,使用zoom:1用于兼容IE）3.是用afert伪元素清除浮动(用于非IE浏览器) Javascript1.javascript的typeof返回哪些数据类型Object number function boolean underfind 2.例举3种强制类型转换和2种隐式类型转换?强制（parseInt,parseFloat,number）隐式（== – ===） 3.split() join() 的区别前者是切割成数组的形式，后者是将数组转换成字符串 4.数组方法pop() push() unshift() shift()Push()尾部添加 pop()尾部删除Unshift()头部添加 shift()头部删除 5.事件绑定和普通事件有什么区别6.IE和DOM事件流的区别1.执行顺序不一样、2.参数不一样3.事件加不加on4.this指向问题 7.IE和标准下有哪些兼容性的写法Var ev = ev || window.eventdocument.documentElement.clientWidth || document.body.clientWidthVar target = ev.srcElement||ev.target 8.ajax请求的时候get 和post方式的区别一个在url后面 一个放在虚拟载体里面有大小限制安全问题应用不同 一个是论坛等只需要请求的，一个是类似修改密码的 9.call和apply的区别Object.call(this,obj1,obj2,obj3)Object.apply(this,arguments)obj.call(thisObj, arg1, arg2, …);obj.apply(thisObj, [arg1, arg2, …]);两者作用一致，都是把obj(即this)绑定到thisObj，这时候thisObj具备了obj的属性和方法。或者说thisObj『继承』了obj的属性和方法。唯一区别是apply接受的是数组参数，call接受的是连续参数。1234567function add(j, k)&#123; return j+k;&#125;function sub(j, k)&#123; return j-k;&#125; 我们在控制台运行：1234567add(5,3); //8add.call(sub, 5, 3); //8add.apply(sub, [5, 3]); //8sub(5, 3); //2sub.call(add, 5, 3); //2sub.apply(add, [5, 3]); //2 10.ajax请求时，如何解释json数据使用eval parse 鉴于安全性考虑 使用parse更靠谱11.b继承a的方法 12.写一个获取非行间样式的函数123456789101112131415161718function getStyle(obj,attr,value)&#123;if(!value)&#123;if(obj.currentStyle)&#123;return obj.currentStyle(attr)&#125;else&#123;obj.getComputedStyle(attr,false)&#125;&#125;else&#123;obj.style[attr]=value&#125;&#125; 13.事件委托是什么让利用事件冒泡的原理，让自己的所触发的事件，让他的父元素代替执行！http://www.webasily.com/?p=78 例子可见此链接 14.闭包是什么，有什么特性，对页面有什么影响闭包就是能够读取其他函数内部变量的函数。http://blog.csdn.net/gaoshanwudi/article/details/7355794 此链接可查看（问这个问题的不是一个公司） 15.如何阻止事件冒泡和默认事件canceBubble return false 16.添加 删除 替换 插入到某个接点的方法obj.appendChidl()obj.innersetBeforeobj.replaceChildobj.removeChild 17.解释jsonp的原理，以及为什么不是真正的ajax动态创建script标签，回调函数Ajax是页面无刷新请求数据操作 18.javascript的本地对象，内置对象和宿主对象本地对象为array obj regexp等可以new实例化内置对象为gload Math 等不可以实例化的宿主为浏览器自带的document,window 等 19.document load 和document ready的区别Document.onload 是在结构和样式加载完才执行jsDocument.ready原生种没有这个方法，jquery中有 $().ready(function) 20.”==”和“===”的不同前者会自动转换类型后者不会 21.javascript的同源策略一段脚本只能读取来自于同一来源的窗口和文档的属性，这里的同一来源指的是主机名、协议和端口号的组合 22.编写一个数组去重的方法function oSort(arr){ var result ={}; var newArr=[];for(var i=0;i&lt;arr.length;i++){ if(!result[arr]) { newArr.push(arr) result[arr]=1 }}return newArr} 23.cookie sessionstorage localstoragecookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。Web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者。Web Storage 的 api 接口使用更方便。24.split var str=”How are you doing today?” document.write(str.split(“ “) + ““)document.write(str.split(“”) + ““)document.write(str.split(“ “,3)) 输出：How,are,you,doing,today?H,o,w, ,a,r,e, ,y,o,u, ,d,o,i,n,g, ,t,o,d,a,y,?How,are,you 25. 对象创建过程1.分配空间。要注意的是，分配空间不光是分配子类的空间，子类对象中包含的父类对象所需要的空间，一样在这一步统一分配。在分配的空间的时候，会把所有的属性设置为默认值。 2.递归的构造父类对象。 3.初始化本类属性。 4.调用本类的构造方法。 总结一下，创建B类对象的步骤一共有5步 1.分配空间 2.初始化A类属性。 3.调用A类的构造方法. 4.初始化B的属性。 5.调用B的构造方法。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[跨域]]></title>
      <url>%2F2017%2F04%2F06%2F%E8%B7%A8%E5%9F%9F%2F</url>
      <content type="text"><![CDATA[什么是跨域JavaScript出于安全方面的考虑，不允许跨域调用其他页面的对象。但在安全限制的同时也给注入iframe或是ajax应用上带来了不少麻烦。这里把涉及到跨域的一些问题简单地整理一下：首先什么是跨域，简单地理解就是因为JavaScript同源策略的限制，a.com 域名下的js无法操作b.com或是c.a.com域名下的对象。更详细的说明可以看下表： 特别注意两点： 第一，如果是协议和端口造成的跨域问题“前台”是无能为力的，第二：在跨域问题上，域仅仅是通过“URL的首部”来识别而不会去尝试判断相同的ip地址对应着两个域或两个域是否在同一个ip上。“URL的首部”指window.location.protocol +window.location.host，也可以理解为“Domains, protocols and ports must match”。接下来简单地总结一下在“前台”一般处理跨域的办法，后台proxy这种方案牵涉到后台配置，这里就不阐述了，有兴趣的可以看看yahoo的这篇文章：《JavaScript: Use a Web Proxy for Cross-Domain XMLHttpRequest Calls》 1、document.domain+iframe的设置对于主域相同而子域不同的例子，可以通过设置document.domain的办法来解决。 具体的做法是可以在http://www.a.com/a.html和http://script.a.com/b.html两个文件中分别加上 document.domain = ‘a.com’；然后通过a.html文件中创建一个iframe，去控制iframe的contentDocument，这样两个js文件之间就可以 “交互”了。当然这种办法只能解决主域相同而二级域名不同的情况，如果你异想天开的把script.a.com的domian设为alibaba.com 那显然是会报错地！代码如下： www.a.com上的a.html12345678910document.domain = &apos;a.com&apos;;var ifr = document.createElement(&apos;iframe&apos;);ifr.src = &apos;http://script.a.com/b.html&apos;;ifr.style.display = &apos;none&apos;;document.body.appendChild(ifr);ifr.onload = function()&#123; var doc = ifr.contentDocument || ifr.contentWindow.document; // 在这里操纵b.html alert(doc.getElementsByTagName(&quot;h1&quot;)[0].childNodes[0].nodeValue);&#125;; script.a.com上的b.htmldocument.domain = ‘a.com’; 这种方式适用于{www.kuqin.com, kuqin.com, script.kuqin.com, css.kuqin.com}中的任何页面相互通信。 备注：某一页面的domain默认等于window.location.hostname。主域名是不带www的域名，例如a.com，主域名前面带前缀的通常都为二级域名或多级域名，例如www.a.com其实是二级域名。 domain只能设置为主域名，不可以在b.a.com中将domain设置为c.a.com。 问题： 1、安全性，当一个站点（b.a.com）被攻击后，另一个站点（c.a.com）会引起安全漏洞。2、如果一个页面中引入多个iframe，要想能够操作所有iframe，必须都得设置相同domain。 2、动态创建script虽然浏览器默认禁止了跨域访问，但并不禁止在页面中引用其他域的JS文件，并可以自由执行引入的JS文件中的function（包括操作cookie、Dom等等）。根据这一点，可以方便地通过创建script节点的方法来实现完全跨域的通信。具体的做法可以参考YUI的Get Utility 这里判断script节点加载完毕还是蛮有意思的：ie只能通过script的readystatechange属性，其它浏览器是script的load事件。以下是部分判断script加载完毕的方法。123456js.onload = js.onreadystatechange = function() &#123; if (!this.readyState || this.readyState === &apos;loaded&apos; || this.readyState === &apos;complete&apos;) &#123; // callback在此处执行 js.onload = js.onreadystatechange = null; &#125;&#125;; 3、利用iframe和location.hash这个办法比较绕，但是可以解决完全跨域情况下的脚步置换问题。原理是利用location.hash来进行传值。在url： http://a.com#helloword中的‘#helloworld’就是location.hash，改变hash并不会导致页面刷新，所以可 以利用hash值来进行数据传递，当然数据容量是有限的。假设域名a.com下的文件cs1.html要和cnblogs.com域名下的 cs2.html传递信息，cs1.html首先创建自动创建一个隐藏的iframe，iframe的src指向cnblogs.com域名下的 cs2.html页面，这时的hash值可以做参数传递用。cs2.html响应请求后再将通过修改cs1.html的hash值来传递数据（由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于a.com域名下的一个代理iframe；Firefox可以修改）。同时在cs1.html上加一个定时器，隔一段时间来判断location.hash的值有没有变化，一点有变化则获取获取hash值。代码如下： 先是a.com下的文件cs1.html文件：12345678910111213141516function startRequest()&#123; var ifr = document.createElement(&apos;iframe&apos;); ifr.style.display = &apos;none&apos;; ifr.src = &apos;http://www.cnblogs.com/lab/cscript/cs2.html#paramdo&apos;; document.body.appendChild(ifr);&#125;function checkHash() &#123; try &#123; var data = location.hash ? location.hash.substring(1) : &apos;&apos;; if (console.log) &#123; console.log(&apos;Now the data is &apos;+data); &#125; &#125; catch(e) &#123;&#125;;&#125;setInterval(checkHash, 2000); cnblogs.com域名下的cs2.html:12345678910111213141516171819202122//模拟一个简单的参数处理操作switch(location.hash)&#123; case &apos;#paramdo&apos;: callBack(); break; case &apos;#paramset&apos;: //do something…… break;&#125;function callBack()&#123; try &#123; parent.location.hash = &apos;somedata&apos;; &#125; catch (e) &#123; // ie、chrome的安全机制无法修改parent.location.hash， // 所以要利用一个中间的cnblogs域下的代理iframe var ifrproxy = document.createElement(&apos;iframe&apos;); ifrproxy.style.display = &apos;none&apos;; ifrproxy.src = &apos;http://a.com/test/cscript/cs3.html#somedata&apos;; // 注意该文件在&quot;a.com&quot;域下 document.body.appendChild(ifrproxy); &#125;&#125; a.com下的域名cs3.html //因为parent.parent和自身属于同一个域，所以可以改变其location.hash的值parent.parent.location.hash = self.location.hash.substring(1); 当然这样做也存在很多缺点，诸如数据直接暴露在了url中，数据容量和类型都有限等…… 4、window.name实现的跨域数据传输文章较长列在此处不便于阅读，详细请看 window.name实现的跨域数据传输（http://www.cnblogs.com/rainman/archive/2011/02/21/1960044.html）。 5、使用HTML5 postMessageHTML5中最酷的新功能之一就是 跨文档消息传输Cross Document Messaging。 下一代浏览器都将支持这个功能：Chrome 2.0+、Internet Explorer 8.0+, Firefox 3.0+, Opera 9.6+, 和 Safari 4.0+ 。 Facebook已经使用了这个功能，用postMessage支持基于web的实时消息传递。 otherWindow.postMessage(message, targetOrigin);otherWindow: 对接收信息页面的window的引用。可以是页面中iframe的contentWindow属性；window.open的返回值；通过name或下标从window.frames取到的值。message: 所要发送的数据，string类型。targetOrigin: 用于限制otherWindow，“*”表示不作限制a.com/index.html中的代码：1234567891011&lt;iframe id=&quot;ifr&quot; src=&quot;b.com/index.html&quot;&gt;&lt;/iframe&gt;&lt;script type=&quot;text/javascript&quot;&gt;window.onload = function() &#123; var ifr = document.getElementById(&apos;ifr&apos;); var targetOrigin = &apos;http://b.com&apos;; // 若写成&apos;http://b.com/c/proxy.html&apos;效果一样 // 若写成&apos;http://c.com&apos;就不会执行postMessage了 ifr.contentWindow.postMessage(&apos;I was there!&apos;, targetOrigin);&#125;;&lt;/script&gt;b.co```m/index.html中的代码： 12345678910&lt;script type=&quot;text/javascript&quot;&gt; window.addEventListener(&apos;message&apos;, function(event)&#123; // 通过origin属性判断消息来源地址 if (event.origin == &apos;http://a.com&apos;) &#123; alert(event.data); // 弹出&quot;I was there!&quot; alert(event.source); // 对a.com、index.html中window对象的引用 // 但由于同源策略，这里event.source不可以访问window对象 &#125; &#125;, false);&lt;/script&gt; 参考文章：《精通HTML5编程》第五章——跨文档消息机制、https://developer.mozilla.org/en/dom/window.postmessage 6、利用flash这是从YUI3的IO组件中看到的办法，具体可见http://developer.yahoo.com/yui/3/io/。可以看在Adobe Developer Connection看到更多的跨域代理文件规范：ross-Domain Policy File Specifications、HTTP Headers Blacklist。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端知识点1]]></title>
      <url>%2F2017%2F04%2F06%2F%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B91%2F</url>
      <content type="text"><![CDATA[1. 常用那几种浏览器测试？有哪些内核(Layout Engine)?(Q1) 浏览器：IE，Chrome，FireFox，Safari，Opera。(Q2) 内核：Trident，Gecko，Presto，Webkit。 2. 说下行内元素和块级元素的区别？行内块元素的兼容性使用？（IE8 以下）(Q1) 行内元素：会在水平方向排列，不能包含块级元素，设置width无效，height无效(可以设置line-height)，margin上下无效，padding上下无效。 块级元素：各占据一行，垂直方向排列。从新行开始结束接着一个断行。 (Q2)兼容性：display:inline-block;display:inline;zoom:1; 3. 清除浮动有哪些方式？比较好的方式是哪一种？(Q1)（1）父级div定义height。（2）结尾处加空div标签clear:both。（3）父级div定义伪类:after和zoom。（4）父级div定义overflow:hidden。（5）父级div定义overflow:auto。（6）父级div也浮动，需要定义宽度。（7）父级div定义display:table。（8）结尾处加br标签clear:both。 (Q2) 比较好的是第3种方式，好多网站都这么用。 4. box-sizing常用的属性有哪些？分别有什么作用？(Q1)box-sizing: content-box|border-box|inherit; (Q2)content-box:宽度和高度分别应用到元素的内容框。在宽度和高度之外绘制元素的内边距和边框(元素默认效果)。border-box:元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。 5. Doctype作用？标准模式与兼容模式各有什么区别?(Q1) &lt;!DOCTYPE&gt;告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。 (Q2) 标准模式的排版和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。 6. HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;？HTML5不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）。 而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。 7. 页面导入样式时，使用link和@import有什么区别？（1）link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS;（2）页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;（3）import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题。 8. 介绍一下你对浏览器内核的理解？主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。 渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、我们组建一大牛裙前面是4七一，整理讯息（例如加入CSS等），中间是零2七，以及计算网页的显示方式，后面是壹武四，是学习的就加，不是学习的请勿打扰。然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。 JS引擎则：解析和执行javascript来实现网页的动态效果。 最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。 9. html5有哪些新特性？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？(Q1)HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。(1)绘画 canvas;(2)用于媒介回放的 video 和 audio 元素;(3)本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;(4)sessionStorage 的数据在浏览器关闭后自动删除;(5)语意化更好的内容元素，比如 article、footer、header、nav、section;(6)表单控件，calendar、date、time、email、url、search;(7)新的技术webworker, websocket, Geolocation; (Q2)IE8/IE7/IE6支持通过document.createElement方法产生的标签，可以利用这一特性让这些浏览器支持HTML5新标签，浏览器支持新标签后，还需要添加标签默认的样式。当然也可以直接使用成熟的框架、比如html5shim， &lt; !–[if lt IE 9]&gt;&lt; ![endif]–&gt; 10. 简述一下你对HTML语义化的理解？用正确的标签做正确的事情。 html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的;搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO;使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。 JavaScript1. 介绍js的基本数据类型Undefined、Null、Boolean、Number、String 2. js有哪些内置对象？数据封装类对象：Object、Array、Boolean、Number 和 String其他对象：Function、Arguments、Math、Date、RegExp、Error 3. this对象的理解this总是指向函数的直接调用者（而非间接调用者）；如果有new关键字，this指向new出来的那个对象；在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window。 4. eval是做什么的？它的功能是把对应的字符串解析成JS代码并运行；应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval(‘(‘+ str +’)’)。 5. DOM怎样添加、移除、移动、复制、创建和查找节点// 创建新节点123createDocumentFragment() //创建一个DOM片段createElement() //创建一个具体的元素createTextNode() //创建一个文本节点 // 添加、移除、替换、插入1234appendChild()removeChild()replaceChild()insertBefore() //在已有的子节点前插入一个新的子节点 // 查找123getElementsByTagName() //通过标签名称getElementsByName() //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)getElementById() //通过元素Id，唯一性 6. null和undefined的区别？null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。undefined：（1）变量被声明了，但没有赋值时，就等于undefined。（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。（3）对象没有赋值的属性，该属性的值为undefined。（4）函数没有返回值时，默认返回undefined。null：（1） 作为函数的参数，表示该函数的参数不是对象。（2） 作为对象原型链的终点。 7. new操作符具体干了什么呢?（1）创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。（2）属性和方法被加入到 this 引用的对象中。（3）新创建的对象由 this 所引用，并且最后隐式的返回 this 。 8. JSON 的了解？JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小。格式：采用键值对，例如：{‘age’:’12’, ‘name’:’back’} 9. call() 和 apply() 的区别和作用？apply()函数有两个参数：第一个参数是上下文，第二个参数是参数组成的数组。如果上下文是null，则使用全局对象代替。如：function.apply(this,[1,2,3]);call()的第一个参数是上下文，后续是实例传入的参数序列。如：function.call(this,1,2,3); 10. 如何获取UA？123456function whatBrowser() &#123; document.Browser.Name.value=navigator.appName; document.Browser.Version.value=navigator.appVersion; document.Browser.Code.value=navigator.appCodeName; document.Browser.Agent.value=navigator.userAgent; &#125; 其他1. HTTP状态码知道哪些？100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息200 OK 正常返回信息201 Created 请求成功并且服务器创建了新的资源202 Accepted 服务器已接受请求，但尚未处理301 Moved Permanently 请求的网页已永久移动到新位置。302 Found 临时性重定向。303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。304 Not Modified 自从上次请求后，请求的网页未修改过。400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。401 Unauthorized 请求未授权。403 Forbidden 禁止访问。404 Not Found 找不到如何与 URI 相匹配的资源。500 Internal Server Error 最常见的服务器端错误。503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。 2. 你有哪些性能优化的方法？（1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。（2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数（3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。（4） 当需要设置的样式很多时设置className而不是直接操作style。（5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。（6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。（7） 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。 3. 什么叫优雅降级和渐进增强？优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了,为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效。渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能,向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。 4. 哪些常见操作会造成内存泄漏？内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）。 5. 线程与进程的区别一个程序至少有一个进程,一个进程至少有一个线程。线程的划分尺度小于进程，使得多线程程序的并发性高。另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML5 标签列表]]></title>
      <url>%2F2017%2F04%2F05%2F%E6%A0%87%E7%AD%BE%E5%88%97%E8%A1%A8%2F</url>
      <content type="text"><![CDATA[HTML5 &lt;article&gt; 标签article 标签是 HTML 5 的新标签, article 标签的内容独立于文档的其余部分。HTML5 &lt;canvas&gt; 标签html5 canvas 标签定义图形，比如图表和其他图像。canvas 标签只是图形容器，您必须使用脚本来绘制图形。HTML5 &lt;!--...--&gt; 标签comment 注释标签用于在源文档中插入注释。注释内容不会被浏览器显示。为代码编写注释的好处是，有助于增强代码的可读性。HTML5 &lt;!DOCTYPE&gt; 标签!DOCTYPE 文档声明必须位于 HTML5 文档中的第一行，也就是位于 html 标签之前。该标签告知浏览器文档所使用的 HTML 规范。HTML5 &lt;a&gt; 标签html5 a 标签定义超链接，用于从一个页面链接到另一个页面。a 标签最重要的属性是 href 属性，它指定链接的目标 url 。HTML5 &lt;abbr&gt; 标签abbr 标签最初是在 HTML 4.0 中引入的，表示它所包含的文本是一个更长的单词或短语的缩写形式。HTML5 &lt;address&gt; 标签address 标签定义文档作者或拥有者的联系信息。通常的做法是将 address 元素添加到网页的头部或底部。HTML5 &lt;applet&gt; 标签定义和用法 applet 定义嵌入的 applet。 HTML 5 中不支持 applet 标签 请使用 object 标签代替它。HTML5 &lt;acronym&gt; 标签定义和用法 HTML 5 不支持 acronym 标签。 请使用 abbr 标签代替它。 在 HTML 4.01 中，acronym 标签定义首字母缩略词。 如果首字母缩略词是一个单词，则可以被读出来，例如 NATO、NASA、ASAP、GUI。HTML5 &lt;area&gt; 标签area 元素始终嵌套在 map 标签内部。area 标签定义图像映射内部的区域（图像映射指的是带有可点击区域的图像）。HTML5 &lt;aside&gt; 标签html5 aside 标签定义其所处内容之外的内容。aside 标签的内容应该与附近的内容相关。HTML5 &lt;audio&gt; 标签audio 标签是 HTML 5 的新标签, audio 标签想网页中插入声音，比如音乐或其他音频流。HTML5 &lt;b&gt; 标签html5 b 标签定义粗体的文本。b 标签用于强调某些文本。如果您希望把文本标记为相比其他文本更为重要，应该使用 strong 标签。HTML5 &lt;base&gt; 标签base 标签为页面上的所有链接规定默认地址或默认目标。base 标签必须位于 head 元素内部。HTML5 &lt;basefont&gt; 标签HTML5 中不支持 basefont 标签。请用 CSS 代替。HTML5 &lt;bdi&gt; 标签bdi 标签是 HTML5 中的新标签。bdi 标签允许您设置一段文本，使其脱离其父元素的文本方向设置。HTML5 &lt;bdo&gt; 标签bdo 标签覆盖默认的文本方向。通过设置 dir 属性来设置文本的显示方向。HTML5 &lt;big&gt; 标签HTML5 中不支持 big 标签。请用 CSS 代替HTML5 &lt;blockquote&gt; 标签blockquote 标签之间的所有文本都会从常规文本中分离出来，经常会在左、右两边进行缩进，而且有时会使用斜体。HTML5 &lt;body&gt; 标签body 标签定义文档的主体。 body 标签包含文档的所有内容，比如文本、超链接、图像、表格、列表等。在 HTML 5 中，删除了所有 的特殊属性。HTML5 &lt;br&gt; 标签br 标签插入简单的换行符。br 标签是一个空标签，意味着它没有结束标签。br 标签常用来输出空行HTML5 &lt;button&gt; 标签button 标签定义按钮。您可以在 button 标签内放置内容，比如文本或图像。但是在 form 中通常使用 input 标签创建按钮。HTML5 &lt;caption&gt; 标签caption 标签定义表格的标题。caption 标签必须直接放置到 table 标签之后。通常标题会居中显示在表格上方。HTML5 &lt;center&gt; 标签HTML5 中不支持该 center 标签。请使用 CSS 代替。HTML5 &lt;cite&gt; 标签cite 标签定义作品（比如书籍、歌曲、电影、电视节目、绘画、雕塑等等）的标题，通常斜体显示。HTML5 &lt;code&gt; 标签em,strong,dfn,code,samp,kbd,var,cite 标签常用来格式话文本，使用 css 样式表可以显示更丰富的效果。HTML5 &lt;col&gt; 标签col 标签为表格中的一个或多个列定义属性值。通过使用 col 标签，可以向整个列应用样式，而不需要重复为每个单元格或每一行设置样式。HTML5 &lt;colgroup&gt; 标签通过使用 colgroup 标签，可以向整个列应用样式，而不需要重复为每个单元格或每一行设置样式。只能在 table 元素内使用 colgroup 标签。HTML5 &lt;command&gt; 标签command 元素表示用户能够调用的命令。可以用它规定键盘快捷键。只有当 command 元素位于 menu 元素内时，该元素才是可见的。HTML5 &lt;datalist&gt; 标签datalist 标签定义选项列表。请与 input 元素配合使用该元素，来定义 input 可能的值。HTML5 &lt;dd&gt; 标签dd 标签定义一个定义列表中对项目的描述。dt 标签定义列表中的项目，而 dd&gt; 标签描述这些项目。HTML5 &lt;del&gt; 标签del 标签定义文档中已删除的文本。与 ins 标签一起使用，描述文档中的更新和修正。HTML5 &lt;details&gt; 标签details 标签是 HTML 5 中的新标签。details 标签用于描述文档或文档某个部分的细节。目前只有 Chrome 支持 details 标签。HTML5 &lt;dfn&gt; 标签HTML5 &lt;dir&gt; 标签HTML5 中不支持 dir 标签。请用 CSS 代替。HTML5 &lt;div&gt; 标签div 标签常用于组合块级元素，以便通过样式表来对这些元素进行格式化。通常使用 div + css 对网页进行布局。HTML5 &lt;dl&gt; 标签dl 标签定义一个定义列表。dl 标签内部使用 dd 和 dt 定义列表中的项目。HTML5 &lt;dt&gt; 标签dt 标签定义一个定义列表中的一个项目。dd 标签描述这些项目。HTML5 &lt;em&gt; 标签HTML5 &lt;embed&gt; 标签embed 标签是 HTML 5 中的新标签。embed 标签定义嵌入的内容，比如插件。HTML5 &lt;fieldset&gt; 标签fieldset 标签会在相关表单元素周围绘制边框。fieldset 标签会在相关表单元素周围绘制边框。HTML5 &lt;figcaption&gt; 标签figcaption 标签是 HTML 5 中的新标签。figcaption 标签定义 figure 元素的标题（caption）。HTML5 &lt;figure&gt; 标签figure 标签是 HTML 5 中的新标签。figure 标签规定独立的流内容（图像、图表、照片、代码等等）。HTML5 &lt;font&gt; 标签定义和用法 在 HTML 5 中，不支持 font 标签。请用 CSS 代替它。 font 标签规定文本的字体、大小和颜色。HTML5 &lt;footer&gt; 标签footer 标签是 HTML 5 中的新标签。footer 标签定义 section 或 document 的页脚。HTML5 &lt;form&gt; 标签form 标签标签用于创建供用户输入的 HTML 表单。form 标签包含多个表单元素，如：button,input,keygen,object,output,select,textareaHTML5 &lt;frame&gt; 标签定义和用法 在 HTML 5 中不支持 frame 标签。 frame 标签定义框架集中的子窗口（框架）。 由于该标签对网页可用性的负面影响，在 HTML 5 中 frame 和 frameset 标签没有得到支持。HTML5 &lt;frameset&gt; 标签定义和用法 在 HTML 5 中不支持 frameset 标签。 frameset 标签定义框架集。它用于组织多个窗口（框架）。 由于该标签对网页可用性的负面影响，在 HTML 5 中 frame 和 frameset 标签没有得到支持。HTML5 &lt;h1 - h6&gt; 标签h1,h2,h3,h4,h5,h6 标签用来定义文档中的标题。h1 定义最大的标题。h6 定义最小的标题。HTML5 &lt;head&gt; 标签head 标签是所有头部元素的容器。位于 head 内部的元素可以包含 title,base,link,meta,script,style等。HTML5 &lt;header&gt; 标签header 标签是 HTML 5 中的新标签。header 标签定义文档的页眉（介绍信息）。HTML5 &lt;hgroup&gt; 标签hgroup 标签是 HTML 5 中的新标签。hgroup 标签用于对网页或区段（section）的标题进行组合。HTML5 &lt;hr&gt; 标签在 HTML 5 中，hr 标签定义内容中的主题变化，并显示为一条水平线。在 HTML 4.01 中，hr 标签仅仅显示为一条水平线。HTML5 &lt;html&gt; 标签html 标签告知浏览器这是一个 HTML 文档。html 元素是 HTML 文档中最外层的根元素。HTML5 &lt;i&gt; 标签i 标签定义的文本在 html 文档中呈现为斜体，以便与文档中其余部分区别开来。HTML5 &lt;iframe&gt; 标签iframe 标签创建包含另一个文档的行内框架。在 HTML 5 中，仅仅支持 src 属性。HTML5 &lt;img&gt; 标签img 标签定义 HTML 页面中的图像。img 标签定义 HTML 页面中的图像。img 标签定义 HTML 页面中的图像。HTML5 &lt;input&gt; 标签input 标签规定 form 表单中用户可输入数据的输入字段。根据不同的 type 属性，输入字段可以是文本字段、复选框、密码字段、单选按钮、按钮等。HTML5 &lt;ins&gt; 标签ins 标签定义文档的其余部分之外的插入文本。通常能够与 del 标签一起使用，来描述对文档的更新和修正。HTML5 &lt;keygen&gt; 标签keygen 是 HTML5 中的新元素。keygen 标签规定用于表单的密钥对生成器字段。当提交表单时，私钥存储在本地，公钥发送到服务器。HTML5 &lt;kbd&gt; 标签HTML5 &lt;label&gt; 标签label 标签为 input 元素定义文字标识，label 标签的 for 属性应该等于相关元素的 id 元素，以便将它们捆绑起来。HTML5 &lt;legend&gt; 标签legend 元素为以下元素定义标题（caption）：fieldset、figure、details 。 legend 元素为以下元素定义标题（caption）：fieldset、figure&gt;、details。HTML5 &lt;li&gt; 标签li 标签定义列表项，有序列表 ol 和无序列表 ul 中都使用 li 标签。 HTML 5 中，li 标签不再支持 type 属性。HTML5 &lt;link&gt; 标签link 标签定义文档与外部资源之间的关系。link 标签大多数时候都用来连接 css 样式表。link 标签只能位于head 标签中。HTML5 &lt;map&gt; 标签map 标签用于定义图像中可点击的热点区域。map 标签的 name 属性与 img 标签的 usemap 属性相关联，以创建图像与映射之间的关系HTML5 &lt;mark&gt; 标签mark 标签是 HTML 5 中的新标签。mark 标签定义带有记号的文本。请在需要突出显示文本时使用 mark 标签。HTML5 &lt;menu&gt; 标签menu 标签定义菜单列表。当希望列出表单控件时使用该标签。在 HTML 5 中，重新定义了 menu 元素，且使用用于排列表单控件。HTML5 &lt;meta&gt; 标签meta 标签位于文档的头部 head 标签中，meta 标签的属性用来定义有关页面的元信息，比如 字符集，关键词，描述，重定向等。HTML5 &lt;meter&gt; 标签meter 标签是 HTML 5 中的新标签。meter 标签定义度量的范围，既可以在元素的文本中，也可以在 min/max 属性中定义。HTML5 &lt;nav&gt; 标签nav 标签是 HTML 5 中的新标签。nav 标签定义导航链接的部分。HTML5 &lt;noframes&gt; 标签定义和用法 在 HTML 5 中不支持 noframes 标签。 noframes 标签向浏览器显示无法处理框架的提示文本。HTML5 标签noscript 元素用来定义在脚本未被执行时的替代内容（文本）。此标签用于可识别 script 标签但无法支持其中脚本的浏览器。HTML5 &lt;object&gt; 标签object 定义一个嵌入的对象。请使用此元素向您的 HTML5 页面添加多媒体。HTML5 &lt;ol&gt; 标签ol 标签定义有序列表。在 HTML 5 中，不再支持 compact 和 type 这两个属性HTML5 &lt;optgroup&gt; 标签optgroup 标签定义选项组。此元素允许您组合选项。当您使用一个长的选项列表时，对相关的选项进行组合会使处理更加容易。HTML5 &lt;option&gt; 标签option 标签定义下拉列表中的一个选项。在 HTML 5 中，option 标签也用于新元素 datalist 中。HTML5 &lt;output&gt; 标签output 标签是 HTML 5 中的新标签。output 标签定义不同类型的输出，比如脚本的输出。HTML5 &lt;p&gt; 标签p 标签定义段落。在 HTML 5 中不再支持 p 标签的 align 属性。HTML5 &lt;param&gt; 标签param 标签允许您为插入 XHTML 文档的对象规定 run-time 设置，也就是说，此标签可为包含它的 object 标签提供参数。HTML5 &lt;pre&gt; 标签pre 标签可定义预格式化的文本。pre 标签的一个常见应用就是用来表示计算机的源代码。HTML5 &lt;progress&gt; 标签progress 标签是 HTML 5 中的新标签。progress 标签定义运行中的进度（进程）。HTML5 &lt;q&gt; 标签q 标签定义一个短的引用。浏览器经常会在这种引用的周围插入引号。HTML5 &lt;rp&gt; 标签rp 标签是 HTML 5 的新标签。rp 标签在 ruby 注释中使用，以定义不支持 ruby 元素的浏览器所显示的内容。HTML5 &lt;ruby&gt; 标签ruby 标签是 HTML 5 的新标签。ruby 标签定义 ruby 注释（中文注音或字符）。HTML5 &lt;s&gt; 标签s 标签定义加删除线的文本。HTML 5 中不再支持 s 标签。HTML5 &lt;samp&gt; 标签HTML5 &lt;script&gt; 标签script 标签用于定义客户端脚本，比如 JavaScript。script 元素既可包含脚本语句，也可以通过 src 属性指向外部脚本文件。HTML5 &lt;select&gt; 标签select 标签创建下拉列表。请在 form 元素中使用此标签来接受用户的输入HTML5 &lt;small&gt; 标签在 HTML5 中，small 元素定义旁注信息，并显示为更小的文本。对于由 em 元素强调过的或由 strong 元素标记为重要的文本，small 元素不会取消对文本的强调，也不会降低这些文本的重要性。HTML5 &lt;source&gt; 标签source 标签是 HTML 5 中的新标签。source 标签为媒介元素（比如 video 和 audio）定义媒介资源。HTML5 &lt;span&gt; 标签span 标签用于对文档中的行内元素进行组合,以便通过样式表 css 对它们进行格式化。HTML5 &lt;strike&gt; 标签定义和用法 在 HTML 5 中不支持 strike 标签。请使用 CSS 代替。 strike 标签定义加删除线的文本。请使用 del 标签代替。HTML5 &lt;strong&gt; 标签HTML5 &lt;style&gt; 标签style 标签定义 HTML 文档的样式信息。scoped 属性是 HTML 5 中的新属性，它允许我们为文档的指定部分定义样式，而不是整个文档。HTML5 &lt;sub&gt; 标签sub 标签可定义下标文本。sup 可定义上标文本。HTML5 &lt;summary&gt; 标签summary 标签是 HTML 5 中的新标签。是 details 元素的第一个子元素，定义 details 元素的标题。HTML5 &lt;sup&gt; 标签HTML5 &lt;table&gt; 标签table 标签定义 HTML 表格。一个简单的 HTML 表格包括 table 元素，一个或多个 tr、th 以及 td 元素。HTML5 &lt;tbody&gt; 标签使用 tbody 标签，可以将表格分为一个单独的部分。tbody 标签可将表格中的一行或几行合成一组。在 HTML 5 中，不支持 tbody 标签的任何属性。HTML5 &lt;td&gt; 标签td 标签定义 HTML 表格中的标准单元格。thead 元素中只能使用 th 标签按，不允许使用 td 标签。HTML5 &lt;textarea&gt; 标签textarea 定义一个多行的文本输入区域。文本区中的默认字体是等宽字体 (fixed pitch)。HTML5 &lt;tfoot&gt; 标签tfoot 定义表格的页脚（脚注），tfoot 内部必须拥有 tr 标签！tfoot 表亲必须位于 table 标签内。HTML5 &lt;th&gt; 标签th 标签定义 HTML 表格中的表头单元格。th 元素中的文本呈现为粗体并且居中。th 标签在 tr 标签中定义。HTML5 &lt;thead&gt; 标签thead 标签在 table 标签中使用，定义表格的表头。thead 内部必须拥有 tr 标签！HTML5 &lt;time&gt; 标签time 标签是 HTML 5 中的新标签。time 标签定义公历的时间（24 小时制）或日期，时间和时区偏移是可选的。HTML5 &lt;title&gt; 标签title 位于 head 部分，用来定义文档的标题。title 元素在所有 HTML 文档中是必需且唯一的。HTML5 &lt;tr&gt; 标签tr 标签定义表格中的行，一个 tr 元素包含一个或多个 td 或 th 标签。HTML5 &lt;track&gt; 标签track 标签是 HTML 5 中的新标签。track 标签为诸如 video 元素之类的媒介规定外部字幕文件或其他包含的文版文件。HTML5 &lt;tt&gt; 标签定义和用法 在 HTML 5 中不支持 tt 标签。 tt 标签定义打字机文本。HTML5 &lt;u&gt; 标签在 HTML 5 中不支持 u 标签HTML5 &lt;ul&gt; 标签ul 标签定义无序列表。请使用 CSS 来定义列表的显示样式。HTML5 &lt;var&gt; 标签HTML5 &lt;video&gt; 标签video 标签是 HTML 5 的新标签。video 标签定义视频，比如电影片段或其他视频流。HTML5 &lt;wbr&gt; 标签wbr 标签是 HTML 5 中的新标签。wbr 规定在文本中的何处适合添加换行符。HTML5 &lt;rt&gt; 标签定义和用法 rt 标签定义字符（中文注音或字符）的解释或发音。 ruby 注释是中文注音或字符。 在东亚使用，显示的是东亚字符的发音。 与 ruby 以及 rt 标签一同使用： ruby 元素由一个或多个字符（需要一个解释/发音）和一个提供该信息的 rt 元素组成，还包括可选的 rp 元素，定义当浏览器不支持 ruby 元素时显示的内容。 实例 一个 ruby 注释： ruby漢 rt ㄏㄢˋ /rt/ruby HTML 4.01 与 HTML 5 之间的差异 rt 标签是 HTML 5 的新标HTML5 &lt;section&gt; 标签section 标签是 HTML 5 中的新标签。section 标签定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F03%2F09%2Fhello-world%2F</url>
      <content type="text"><![CDATA[环境准备需要git,Node.js环境 安装hexo利用 npm 命令即可安装。（在任意位置点击鼠标右键，选择Git bash） 1npm install -g hexo 创建hexo文件夹选择存放hexo文件的位置,执行以下指令(Git bash终端下)，Hexo即会自动在目标文件夹建立网站所需要的所有文件。 1hexo init 安装依赖包1npm install 本地查看现在我们已经搭建起本地的hexo博客了，执行以下命令(在hexo文件下)，然后到浏览器输入localhost:4000看看。 12hexo generate #此命令是生成静态页面，不执行该命令也可以hexo server 到此，本地服务以及搭建好了。 打包上传到github如果没有github账户，则需要注册 创建仓库，配置ssh秘钥 注意：Repository name命名规则：你的github账号.github.io (这个一定要这么命名，具体我也不清楚) hexo使用目录结构12345678910├── .deploy #需要部署的文件├── node_modules #Hexo插件├── public #生成的静态网页文件├── scaffolds #模板├── source #博客正文和其他源文件，404、favicon、CNAME├── _drafts #草稿├── _posts #文章,可以用子文件来存放文章├── themes #主题├── _config.yml #全局配置文件└── package.json 配置文件的冒号“:”后面有一个空格repo: 刚刚github创库地址.githexo命令行使用12345678hexo help #查看帮助hexo init #初始化一个目录hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成网页，可以在 public 目录查看整个网站的文件hexo server #本地预览，&apos;Ctrl+C&apos;关闭hexo deploy #部署.deploy目录hexo clean #清除缓存，**强烈建议每次执行命令前先清理缓存，每次部署前先删除 .deploy 文件夹** 简写 1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 编辑文章新建文章1hexo new &quot;标题&quot; 在 _posts 目录下会生成文件 标题.md12345678910title: Hello Worlddate: 2015-07-30 07:56:29 #发表日期，一般不改动categories: hexo #文章文类tags: [hexo,github] #文章标签，多于一项时用这种格式---正文，使用Markdown语法书写编辑完后保存，hexo server 预览hexo部署执行下列指令即可完成部署。 123hexo generatehexo deployhexo deploy问题：Deployer not found: git 1npm install hexo-deployer-git --save 重新deploy即可 图片我这里是使用本地的图片 安装 1npm install hexo-asset-image --save 安装该插件后，每次hexo new 新建博文后，会在该文件同级目录下生成一个和文件同名的文件夹，该文件夹就是用来存放图片的确保你的_config.yml 配置 post_asset_folder: true然后使用1![logo](logo.jpg) 在博文中插入logo.jpg. 来源：http://wuxiaolong.me/2015/07/31/build-blog-by-hexo/http://www.tuicool.com/articles/umEBVfI]]></content>
    </entry>

    
  
  
</search>
